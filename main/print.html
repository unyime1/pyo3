<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PyO3 user guide</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="module.html"><strong aria-hidden="true">1.</strong> Python Modules</a></li><li class="chapter-item expanded "><a href="function.html"><strong aria-hidden="true">2.</strong> Python Functions</a></li><li class="chapter-item expanded "><a href="class.html"><strong aria-hidden="true">3.</strong> Python Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/protocols.html"><strong aria-hidden="true">3.1.</strong> Class customizations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/object.html"><strong aria-hidden="true">3.1.1.</strong> Basic object customization</a></li><li class="chapter-item expanded "><a href="class/numeric.html"><strong aria-hidden="true">3.1.2.</strong> Emulating numeric types</a></li><li class="chapter-item expanded "><a href="class/call.html"><strong aria-hidden="true">3.1.3.</strong> Emulating callable objects</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> Type Conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversions/tables.html"><strong aria-hidden="true">4.1.</strong> Mapping of Rust types to Python types</a></li><li class="chapter-item expanded "><a href="conversions/traits.html"><strong aria-hidden="true">4.2.</strong> Conversion traits</a></li></ol></li><li class="chapter-item expanded "><a href="exception.html"><strong aria-hidden="true">5.</strong> Python Exceptions</a></li><li class="chapter-item expanded "><a href="python_from_rust.html"><strong aria-hidden="true">6.</strong> Calling Python from Rust</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">7.</strong> GIL, mutability and object types</a></li><li class="chapter-item expanded "><a href="parallelism.html"><strong aria-hidden="true">8.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">9.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">10.</strong> Features Reference</a></li><li class="chapter-item expanded "><a href="memory.html"><strong aria-hidden="true">11.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">12.</strong> Advanced Topics</a></li><li class="chapter-item expanded "><a href="building_and_distribution.html"><strong aria-hidden="true">13.</strong> Building and Distribution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building_and_distribution/multiple_python_versions.html"><strong aria-hidden="true">13.1.</strong> Supporting multiple Python versions</a></li></ol></li><li class="chapter-item expanded "><a href="ecosystem.html"><strong aria-hidden="true">14.</strong> Useful Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecosystem/logging.html"><strong aria-hidden="true">14.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="ecosystem/async-await.html"><strong aria-hidden="true">14.2.</strong> Async / Await</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">15.</strong> FAQ &amp; Troubleshooting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="migration.html">Appendix A: Migration Guide</a></li><li class="chapter-item expanded affix "><a href="rust_cpython.html">Appendix B: PyO3 and rust-cpython</a></li><li class="chapter-item expanded affix "><a href="trait_bounds.html">Appendix C: Trait bounds</a></li><li class="chapter-item expanded affix "><a href="python_typing_hints.html">Appendix D: Python typing hints</a></li><li class="chapter-item expanded affix "><a href="changelog.html">CHANGELOG</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributing.html">Contributing</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-pyo3-user-guide"><a class="header" href="#the-pyo3-user-guide">The PyO3 user guide</a></h1>
<p>Welcome to the PyO3 user guide! This book is a companion to <a href="https://docs.rs/pyo3">PyO3's API docs</a>. It contains examples and documentation to explain all of PyO3's use cases in detail.</p>
<p>Please choose from the chapters on the left to jump to individual topics, or continue below to start with PyO3's README.</p>
<h1 id="pyo3"><a class="header" href="#pyo3">PyO3</a></h1>
<p><a href="https://github.com/PyO3/pyo3/actions"><img src="https://github.com/PyO3/pyo3/workflows/CI/badge.svg" alt="actions status" /></a>
<a href="https://pyo3.rs/dev/bench/"><img src="https://github.com/PyO3/pyo3/actions/workflows/bench.yml/badge.svg" alt="benchmark" /></a>
<a href="https://codecov.io/gh/PyO3/pyo3"><img src="https://codecov.io/gh/PyO3/pyo3/branch/main/graph/badge.svg" alt="codecov" /></a>
<a href="https://crates.io/crates/pyo3"><img src="https://img.shields.io/crates/v/pyo3" alt="crates.io" /></a>
<a href="https://rust-lang.github.io/rfcs/2495-min-rust-version.html"><img src="https://img.shields.io/badge/rustc-1.48+-blue.svg" alt="minimum rustc 1.48" /></a>
<a href="https://gitter.im/PyO3/Lobby"><img src="https://img.shields.io/gitter/room/nwjs/nw.js.svg" alt="dev chat" /></a>
<a href="https://github.com/PyO3/pyo3/blob/main/Contributing.md"><img src="https://img.shields.io/badge/contribute-on%20github-Green" alt="contributing notes" /></a></p>
<p><a href="https://www.rust-lang.org/">Rust</a> bindings for <a href="https://www.python.org/">Python</a>, including tools for creating native Python extension modules. Running and interacting with Python code from a Rust binary is also supported.</p>
<ul>
<li>
<p>User Guide: <a href="https://pyo3.rs">stable</a> | <a href="https://pyo3.rs/main">main</a></p>
</li>
<li>
<p>API Documentation: <a href="https://docs.rs/pyo3/">stable</a> | <a href="https://pyo3.rs/main/doc">main</a></p>
</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>PyO3 supports the following software versions:</p>
<ul>
<li>Python 3.7 and up (CPython and PyPy)</li>
<li>Rust 1.48 and up</li>
</ul>
<p>You can use PyO3 to write a native Python module in Rust, or to embed Python in a Rust binary. The following sections explain each of these in turn.</p>
<h3 id="using-rust-from-python"><a class="header" href="#using-rust-from-python">Using Rust from Python</a></h3>
<p>PyO3 can be used to generate a native Python module. The easiest way to try this out for the first time is to use <a href="https://github.com/PyO3/maturin"><code>maturin</code></a>. <code>maturin</code> is a tool for building and publishing Rust-based Python packages with minimal configuration. The following steps install <code>maturin</code>, use it to generate and build a new Python package, and then launch Python to import and execute a function from the package.</p>
<p>First, follow the commands below to create a new directory containing a new Python <code>virtualenv</code>, and install <code>maturin</code> into the virtualenv using Python's package manager, <code>pip</code>:</p>
<pre><code class="language-bash"># (replace string_sum with the desired package name)
$ mkdir string_sum
$ cd string_sum
$ python -m venv .env
$ source .env/bin/activate
$ pip install maturin
</code></pre>
<p>Still inside this <code>string_sum</code> directory, now run <code>maturin init</code>. This will generate the new package source. When given the choice of bindings to use, select pyo3 bindings:</p>
<pre><code class="language-bash">$ maturin init
✔ 🤷 What kind of bindings to use? · pyo3
  ✨ Done! New project created string_sum
</code></pre>
<p>The most important files generated by this command are <code>Cargo.toml</code> and <code>lib.rs</code>, which will look roughly like the following:</p>
<p><strong><code>Cargo.toml</code></strong></p>
<pre><code class="language-toml">[package]
name = &quot;string_sum&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[lib]
# The name of the native library. This is the name which will be used in Python to import the
# library (i.e. `import string_sum`). If you change this, you must also change the name of the
# `#[pymodule]` in `src/lib.rs`.
name = &quot;string_sum&quot;
# &quot;cdylib&quot; is necessary to produce a shared library for Python to import from.
#
# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) will not be able
# to `use string_sum;` unless the &quot;rlib&quot; or &quot;lib&quot; crate type is also included, e.g.:
# crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
crate-type = [&quot;cdylib&quot;]

[dependencies]
pyo3 = { version = &quot;0.16.5&quot;, features = [&quot;extension-module&quot;] }
</code></pre>
<p><strong><code>src/lib.rs</code></strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// Formats the sum of two numbers as string.
#[pyfunction]
fn sum_as_string(a: usize, b: usize) -&gt; PyResult&lt;String&gt; {
    Ok((a + b).to_string())
}

/// A Python module implemented in Rust. The name of this function must match
/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to
/// import the module.
#[pymodule]
fn string_sum(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, run <code>maturin develop</code>. This will build the package and install it into the Python virtualenv previously created and activated. The package is then ready to be used from <code>python</code>:</p>
<pre><code class="language-bash">$ maturin develop
# lots of progress output as maturin runs the compilation...
$ python
&gt;&gt;&gt; import string_sum
&gt;&gt;&gt; string_sum.sum_as_string(5, 20)
'25'
</code></pre>
<p>To make changes to the package, just edit the Rust source code and then re-run <code>maturin develop</code> to recompile.</p>
<p>To run this all as a single copy-and-paste, use the bash script below (replace <code>string_sum</code> in the first command with the desired package name):</p>
<pre><code class="language-bash">mkdir string_sum &amp;&amp; cd &quot;$_&quot;
python -m venv .env
source .env/bin/activate
pip install maturin
maturin init --bindings pyo3
maturin develop
</code></pre>
<p>As well as with <code>maturin</code>, it is possible to build using <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> or <a href="https://pyo3.rs/latest/building_and_distribution.html#manual-builds">manually</a>. Both offer more flexibility than <code>maturin</code> but require more configuration to get started.</p>
<h3 id="using-python-from-rust"><a class="header" href="#using-python-from-rust">Using Python from Rust</a></h3>
<p>To embed Python into a Rust binary, you need to ensure that your Python installation contains a shared library. The following steps demonstrate how to ensure this (for Ubuntu), and then give some example code which runs an embedded Python interpreter.</p>
<p>To install the Python shared library on Ubuntu:</p>
<pre><code class="language-bash">sudo apt install python3-dev
</code></pre>
<p>Start a new project with <code>cargo new</code> and add  <code>pyo3</code> to the <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[dependencies.pyo3]
version = &quot;0.16.5&quot;
features = [&quot;auto-initialize&quot;]
</code></pre>
<p>Example program displaying the value of <code>sys.version</code> and the current user name:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;

fn main() -&gt; PyResult&lt;()&gt; {
    Python::with_gil(|py| {
        let sys = py.import(&quot;sys&quot;)?;
        let version: String = sys.getattr(&quot;version&quot;)?.extract()?;

        let locals = [(&quot;os&quot;, py.import(&quot;os&quot;)?)].into_py_dict(py);
        let code = &quot;os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'&quot;;
        let user: String = py.eval(code, None, Some(&amp;locals))?.extract()?;

        println!(&quot;Hello {}, I'm Python {}&quot;, user, version);
        Ok(())
    })
}
</code></pre></pre>
<p>The guide has <a href="https://pyo3.rs/latest/python_from_rust.html">a section</a> with lots of examples
about this topic.</p>
<h2 id="tools-and-libraries"><a class="header" href="#tools-and-libraries">Tools and libraries</a></h2>
<ul>
<li><a href="https://github.com/PyO3/maturin">maturin</a> <em>Build and publish crates with pyo3, rust-cpython or cffi bindings as well as rust binaries as python packages</em></li>
<li><a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a> <em>Setuptools plugin for Rust support</em>.</li>
<li><a href="https://github.com/PyO3/pyo3-built">pyo3-built</a> <em>Simple macro to expose metadata obtained with the <a href="https://crates.io/crates/built"><code>built</code></a> crate as a <a href="https://docs.rs/pyo3/*/pyo3/types/struct.PyDict.html"><code>PyDict</code></a></em></li>
<li><a href="https://github.com/PyO3/rust-numpy">rust-numpy</a> <em>Rust binding of NumPy C-API</em></li>
<li><a href="https://github.com/gperinazzo/dict-derive">dict-derive</a> <em>Derive FromPyObject to automatically transform Python dicts into Rust structs</em></li>
<li><a href="https://github.com/vorner/pyo3-log">pyo3-log</a> <em>Bridge from Rust to Python logging</em></li>
<li><a href="https://github.com/davidhewitt/pythonize">pythonize</a> <em>Serde serializer for converting Rust objects to JSON-compatible Python objects</em></li>
<li><a href="https://github.com/awestlake87/pyo3-asyncio">pyo3-asyncio</a> <em>Utilities for working with Python's Asyncio library and async functions</em></li>
<li><a href="https://github.com/mityax/rustimport">rustimport</a> <em>Directly import Rust files or crates from Python, without manual compilation step. Provides pyo3 integration by default and generates pyo3 binding code automatically.</em></li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li><a href="https://github.com/mre/hyperjson">hyperjson</a> <em>A hyper-fast Python module for reading/writing JSON data using Rust's serde-json</em></li>
<li><a href="https://github.com/PyO3/setuptools-rust/tree/main/examples/html-py-ever">html-py-ever</a> <em>Using <a href="https://github.com/servo/html5ever">html5ever</a> through <a href="https://github.com/kuchiki-rs/kuchiki">kuchiki</a> to speed up html parsing and css-selecting.</em></li>
<li><a href="https://github.com/ManifoldFR/point-process-rust/tree/master/pylib">point-process</a> <em>High level API for pointprocesses as a Python library</em></li>
<li><a href="https://github.com/autopilot-rs/autopy">autopy</a> <em>A simple, cross-platform GUI automation library for Python and Rust.</em>
<ul>
<li>Contains an example of building wheels on TravisCI and appveyor using <a href="https://github.com/pypa/cibuildwheel">cibuildwheel</a></li>
</ul>
</li>
<li><a href="https://github.com/ijl/orjson">orjson</a> <em>Fast Python JSON library</em></li>
<li><a href="https://github.com/fusion-engineering/inline-python">inline-python</a> <em>Inline Python code directly in your Rust code</em></li>
<li><a href="https://github.com/kngwyu/rogue-gym">Rogue-Gym</a> <em>Customizable rogue-like game for AI experiments</em>
<ul>
<li>Contains an example of building wheels on Azure Pipelines</li>
</ul>
</li>
<li><a href="https://github.com/thedrow/fastuuid/">fastuuid</a> <em>Python bindings to Rust's UUID library</em></li>
<li><a href="https://github.com/wasmerio/wasmer-python">wasmer-python</a> <em>Python library to run WebAssembly binaries</em></li>
<li><a href="https://github.com/cds-astro/mocpy">mocpy</a> <em>Astronomical Python library offering data structures for describing any arbitrary coverage regions on the unit sphere</em></li>
<li><a href="https://github.com/huggingface/tokenizers/tree/master/bindings/python">tokenizers</a> <em>Python bindings to the Hugging Face tokenizers (NLP) written in Rust</em></li>
<li><a href="https://github.com/Project-Dream-Weaver/pyre-http">pyre</a> <em>Fast Python HTTP server written in Rust</em></li>
<li><a href="https://github.com/Stranger6667/jsonschema-rs/tree/master/bindings/python">jsonschema-rs</a> <em>Fast JSON Schema validation library</em></li>
<li><a href="https://github.com/Stranger6667/css-inline/tree/master/bindings/python">css-inline</a> <em>CSS inlining for Python implemented in Rust</em></li>
<li><a href="https://github.com/pyca/cryptography/tree/main/src/rust">cryptography</a> <em>Python cryptography library with some functionality in Rust</em></li>
<li><a href="https://github.com/daggy1234/polaroid">polaroid</a> <em>Hyper Fast and safe image manipulation library for Python written in Rust</em></li>
<li><a href="https://github.com/aviramha/ormsgpack">ormsgpack</a> <em>Fast Python msgpack library</em></li>
<li><a href="https://github.com/fastlmm/bed-reader">bed-reader</a> <em>Read and write the PLINK BED format, simply and efficiently</em>
<ul>
<li>Shows Rayon/ndarray::parallel (including capturing errors, controlling thread num), Python types to Rust generics, Github Actions</li>
</ul>
</li>
<li><a href="https://github.com/kevinheavey/pyheck">pyheck</a> <em>Fast case conversion library, built by wrapping <a href="https://github.com/withoutboats/heck">heck</a></em>
<ul>
<li>Quite easy to follow as there's not much code.</li>
</ul>
</li>
<li><a href="https://github.com/pola-rs/polars">polars</a> <em>Fast multi-threaded DataFrame library in Rust | Python | Node.js</em></li>
<li><a href="https://github.com/cjermain/rust-python-coverage">rust-python-coverage</a> <em>Example PyO3 project with automated test coverage for Rust and Python</em></li>
</ul>
<h2 id="articles-and-other-media"><a class="header" href="#articles-and-other-media">Articles and other media</a></h2>
<ul>
<li><a href="https://towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29?sk=f8d808d5f414154fdb811e4137011437">Nine Rules for Writing Python Extensions in Rust</a> - Dec 31, 2021</li>
<li><a href="https://saidvandeklundert.net/learn/2021-11-18-calling-rust-from-python-using-pyo3/">Calling Rust from Python using PyO3</a> - Nov 18, 2021</li>
<li><a href="https://www.youtube.com/watch?v=-XyWG_klSAw&amp;t=320s">davidhewitt's 2021 talk at Rust Manchester meetup</a> - Aug 19, 2021</li>
<li><a href="https://blog.waleedkhan.name/port-python-to-rust/">Incrementally porting a small Python project to Rust</a> - Apr 29, 2021</li>
<li><a href="https://www.vortexa.com/insight/integrating-rust-into-python">Vortexa - Integrating Rust into Python</a> - Apr 12, 2021</li>
<li><a href="https://blog.yossarian.net/2020/08/02/Writing-and-publishing-a-python-module-in-rust">Writing and publishing a Python module in Rust</a> - Aug 2, 2020</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Everyone is welcomed to contribute to PyO3! There are many ways to support the project, such as:</p>
<ul>
<li>help PyO3 users with issues on GitHub and Gitter</li>
<li>improve documentation</li>
<li>write features and bugfixes</li>
<li>publish blogs and examples of how to use PyO3</li>
</ul>
<p>Our <a href="https://github.com/PyO3/pyo3/blob/main/Contributing.md">contributing notes</a> and <a href="https://github.com/PyO3/pyo3/blob/main/Architecture.md">architecture guide</a> have more resources if you wish to volunteer time for PyO3 and are searching where to start.</p>
<p>If you don't have time to contribute yourself but still wish to support the project's future success, some of our maintainers have GitHub sponsorship pages:</p>
<ul>
<li><a href="https://github.com/sponsors/davidhewitt">davidhewitt</a></li>
<li><a href="https://github.com/sponsors/messense">messense</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>PyO3 is licensed under the <a href="https://opensource.org/licenses/APACHE-2.0">Apache-2.0 license</a>.
Python is licensed under the <a href="https://docs.python.org/3/license.html">Python License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-modules"><a class="header" href="#python-modules">Python Modules</a></h1>
<p>You can create a module using <code>#[pymodule]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

/// This module is implemented in Rust.
#[pymodule]
fn my_extension(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>#[pymodule]</code> procedural macro takes care of exporting the initialization function of your
module to Python.</p>
<p>The module's name defaults to the name of the Rust function. You can override the module name by
using <code>#[pyo3(name = &quot;custom_name&quot;)]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
#[pyo3(name = &quot;custom_name&quot;)]
fn my_extension(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>The name of the module must match the name of the <code>.so</code> or <code>.pyd</code>
file. Otherwise, you will get an import error in Python with the following message:
<code>ImportError: dynamic module does not define module export function (PyInit_name_of_your_module)</code></p>
<p>To import the module, either:</p>
<ul>
<li>copy the shared library as described in <a href="building_and_distribution.html#manual-builds">Manual builds</a>, or</li>
<li>use a tool, e.g. <code>maturin develop</code> with <a href="https://github.com/PyO3/maturin">maturin</a> or
<code>python setup.py develop</code> with <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>.</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The <a href="https://doc.rust-lang.org/stable/book/ch03-04-comments.html">Rust doc comments</a> of the module
initialization function will be applied automatically as the Python docstring of your module.</p>
<p>For example, building off of the above code, this will print <code>This module is implemented in Rust.</code>:</p>
<pre><code class="language-python">import my_extension

print(my_extension.__doc__)
</code></pre>
<h2 id="organizing-your-module-registration-code"><a class="header" href="#organizing-your-module-registration-code">Organizing your module registration code</a></h2>
<p>For most projects, it's adequate to centralize all your FFI code into a single Rust module.</p>
<p>However, for larger projects, it can be helpful to split your Rust code into several Rust modules to keep your code 
readable. Unfortunately, though, some of the macros like <code>wrap_pyfunction!</code> do not yet work when used on code defined 
in other modules (<a href="https://github.com/PyO3/pyo3/issues/1709">#1709</a>). One way to work around this is to pass 
references to the <code>PyModule</code> so that each module registers its own FFI code. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use pyo3::prelude::*;

#[pymodule]
fn my_extension(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    dirutil::register(py, m)?;
    osutil::register(py, m)?;
    Ok(())
}

// src/dirutil.rs
<span class="boring">mod dirutil {
</span>use pyo3::prelude::*;

pub(crate) fn register(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;SomeClass&gt;()?;
    Ok(())
}

#[pyclass]
struct SomeClass {/* ... */}
<span class="boring">}
</span>
// src/osutil.rs
<span class="boring">mod osutil {
</span>use pyo3::prelude::*;

pub(crate) fn register(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(determine_current_os, m)?)?;
    Ok(())
}

#[pyfunction]
fn determine_current_os() -&gt; String {
    &quot;linux&quot;.to_owned()
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Another workaround for splitting FFI code across multiple modules (<a href="https://github.com/PyO3/pyo3/issues/1709">#1709</a>)
is to add <code>use module::*</code>, like this: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use pyo3::prelude::*;
use osutil::*;

#[pymodule]
fn my_extension(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(determine_current_os, m)?)?;
    Ok(())
}

// src/osutil.rs
<span class="boring">mod osutil {
</span>use pyo3::prelude::*;

#[pyfunction]
pub(crate) fn determine_current_os() -&gt; String {
    &quot;linux&quot;.to_owned()
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="python-submodules"><a class="header" href="#python-submodules">Python submodules</a></h2>
<p>You can create a module hierarchy within a single extension module by using 
<a href="https://pyo3.rs/main/doc/pyo3/prelude/struct.PyModule.html#method.add_submodule"><code>PyModule.add_submodule()</code></a>.
For example, you could define the modules <code>parent_module</code> and <code>parent_module.child_module</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pymodule]
fn parent_module(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    register_child_module(py, m)?;
    Ok(())
}

fn register_child_module(py: Python&lt;'_&gt;, parent_module: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    let child_module = PyModule::new(py, &quot;child_module&quot;)?;
    child_module.add_function(wrap_pyfunction!(func, child_module)?)?;
    parent_module.add_submodule(child_module)?;
    Ok(())
}

#[pyfunction]
fn func() -&gt; String {
    &quot;func&quot;.to_string()
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">   use pyo3::wrap_pymodule;
</span><span class="boring">   use pyo3::types::IntoPyDict;
</span><span class="boring">   let parent_module = wrap_pymodule!(parent_module)(py);
</span><span class="boring">   let ctx = [(&quot;parent_module&quot;, parent_module)].into_py_dict(py);
</span><span class="boring">
</span><span class="boring">   py.run(&quot;assert parent_module.child_module.func() == 'func'&quot;, None, Some(&amp;ctx)).unwrap();
</span><span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>Note that this does not define a package, so this won’t allow Python code to directly import 
submodules by using <code>from parent_module import child_module</code>. For more information, see 
<a href="https://github.com/PyO3/pyo3/issues/759">#759</a> and 
<a href="https://github.com/PyO3/pyo3/issues/1517#issuecomment-808664021">#1517</a>.</p>
<p>It is not necessary to add <code>#[pymodule]</code> on nested modules, which is only required on the top-level module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-functions"><a class="header" href="#python-functions">Python Functions</a></h1>
<p>The <code>#[pyfunction]</code> attribute is used to define a Python function from a Rust function. Once defined, the function needs to be added to a <a href="./module.html">module</a> using the <code>wrap_pyfunction!</code> macro.</p>
<p>The following example defines a function called <code>double</code> in a Python module called <code>my_extension</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
fn my_extension(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>This chapter of the guide explains full usage of the <code>#[pyfunction]</code> attribute. The following topics are covered:</p>
<ul>
<li><a href="function.html#function-options">Function options</a>
<ul>
<li><a href="function.html#name"><code>#[pyo3(name = &quot;...&quot;)]</code></a></li>
<li><a href="function.html#text_signature"><code>#[pyo3(text_signature = &quot;...&quot;)]</code></a></li>
<li><a href="function.html#pass_module"><code>#[pyo3(pass_module)]</code></a></li>
</ul>
</li>
<li><a href="function.html#argument-parsing">Argument parsing</a>
<ul>
<li><a href="function.html#from_py_with"><code>#[pyo3(from_py_with = &quot;...&quot;)]</code></a></li>
</ul>
</li>
<li><a href="function.html#advanced-function-patterns">Advanced function patterns</a></li>
<li><a href="function.html#pyfn-shorthand"><code>#[pyfn]</code> shorthand</a></li>
</ul>
<h2 id="function-options"><a class="header" href="#function-options">Function options</a></h2>
<p>The <code>#[pyo3]</code> attribute can be used to modify properties of the generated Python function. It can take any combination of the following options:</p>
<ul>
<li>
<p><a name="name"></a> <code>#[pyo3(name = &quot;...&quot;)]</code></p>
<p>Overrides the name exposed to Python.</p>
<p>In the following example, the Rust function <code>no_args_py</code> will be added to the Python module
<code>module_with_functions</code> as the Python function <code>no_args</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
#[pyo3(name = &quot;no_args&quot;)]
fn no_args_py() -&gt; usize { 42 }

#[pymodule]
fn module_with_functions(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(no_args_py, m)?)?;
    Ok(())
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let m = pyo3::wrap_pymodule!(module_with_functions)(py);
</span><span class="boring">    assert!(m.getattr(py, &quot;no_args&quot;).is_ok());
</span><span class="boring">    assert!(m.getattr(py, &quot;no_args_py&quot;).is_err());
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a name="text_signature"></a> <code>#[pyo3(text_signature = &quot;...&quot;)]</code></p>
<p>Sets the function signature visible in Python tooling (such as via <a href="https://docs.python.org/3/library/inspect.html#inspect.signature"><code>inspect.signature</code></a>).</p>
<p>The example below creates a function <code>add</code> which has a signature describing two positional-only
arguments <code>a</code> and <code>b</code>.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

/// This function adds two unsigned 64-bit integers.
#[pyfunction]
#[pyo3(text_signature = &quot;(a, b, /)&quot;)]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let fun = pyo3::wrap_pyfunction!(add, py)?;
</span><span class="boring">
</span><span class="boring">        let doc: String = fun.getattr(&quot;__doc__&quot;)?.extract()?;
</span><span class="boring">        assert_eq!(doc, &quot;This function adds two unsigned 64-bit integers.&quot;);
</span><span class="boring">
</span><span class="boring">        let inspect = PyModule::import(py, &quot;inspect&quot;)?.getattr(&quot;signature&quot;)?;
</span><span class="boring">        let sig: String = inspect
</span><span class="boring">            .call1((fun,))?
</span><span class="boring">            .call_method0(&quot;__str__&quot;)?
</span><span class="boring">            .extract()?;
</span><span class="boring">        assert_eq!(sig, &quot;(a, b, /)&quot;);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><a name="pass_module" ></a> <code>#[pyo3(pass_module)]</code></p>
<p>Set this option to make PyO3 pass the containing module as the first argument to the function. It is then possible to use the module in the function body. The first argument <strong>must</strong> be of type <code>&amp;PyModule</code>.</p>
<p>The following example creates a function <code>pyfunction_with_module</code> which returns the containing module's name (i.e. <code>module_with_fn</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
#[pyo3(pass_module)]
fn pyfunction_with_module(module: &amp;PyModule) -&gt; PyResult&lt;&amp;str&gt; {
    module.name()
}

#[pymodule]
fn module_with_fn(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(pyfunction_with_module, m)?)
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h2 id="argument-parsing"><a class="header" href="#argument-parsing">Argument parsing</a></h2>
<p>The <code>#[pyfunction]</code> attribute supports specifying details of argument parsing. The details are given in the section <a href="class.html#method-arguments">&quot;Method arguments&quot; of the Classes chapter</a>.  Here is an example for a function that accepts arbitrary keyword arguments (<code>**kwargs</code> in Python syntax) and returns the number that was passed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyDict;

#[pyfunction(kwds=&quot;**&quot;)]
fn num_kwds(kwds: Option&lt;&amp;PyDict&gt;) -&gt; usize {
    kwds.map_or(0, |dict| dict.len())
}

#[pymodule]
fn module_with_functions(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(num_kwds, m)?).unwrap();
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="per-argument-options"><a class="header" href="#per-argument-options">Per-argument options</a></h3>
<p>The <code>#[pyo3]</code> attribute can be used on individual arguments to modify properties of them in the generated function. It can take any combination of the following options:</p>
<ul>
<li>
<p><a name="from_py_with"></a> <code>#[pyo3(from_py_with = &quot;...&quot;)]</code></p>
<p>Set this on an option to specify a custom function to convert the function argument from Python to the desired Rust type, instead of using the default <code>FromPyObject</code> extraction. The function signature must be <code>fn(&amp;PyAny) -&gt; PyResult&lt;T&gt;</code> where <code>T</code> is the Rust type of the argument.</p>
<p>The following example uses <code>from_py_with</code> to convert the input Python object to its length:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

fn get_length(obj: &amp;PyAny) -&gt; PyResult&lt;usize&gt; {
    let length = obj.len()?;
    Ok(length)
}

#[pyfunction]
fn object_length(
    #[pyo3(from_py_with = &quot;get_length&quot;)] argument: usize
) -&gt; usize {
    argument
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let f = pyo3::wrap_pyfunction!(object_length)(py).unwrap();
</span><span class="boring">    assert_eq!(f.call1((vec![1, 2, 3],)).unwrap().extract::&lt;usize&gt;().unwrap(), 3);
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h2 id="advanced-function-patterns"><a class="header" href="#advanced-function-patterns">Advanced function patterns</a></h2>
<h3 id="making-the-function-signature-available-to-python-old-method"><a class="header" href="#making-the-function-signature-available-to-python-old-method">Making the function signature available to Python (old method)</a></h3>
<p>Alternatively, simply make sure the first line of your docstring is
formatted like in the following example. Please note that the newline after the
<code>--</code> is mandatory. The <code>/</code> signifies the end of positional-only arguments.</p>
<p><code>#[pyo3(text_signature)]</code> should be preferred, since it will override automatically
generated signatures when those are added in a future version of PyO3.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

/// add(a, b, /)
/// --
///
/// This function adds two unsigned 64-bit integers.
#[pyfunction]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}

// a function with a signature but without docs. Both blank lines after the `--` are mandatory.

/// sub(a, b, /)
/// --
///
///
#[pyfunction]
fn sub(a: u64, b: u64) -&gt; u64 {
    a - b
}
<span class="boring">}
</span></code></pre></pre>
<p>When annotated like this, signatures are also correctly displayed in IPython.</p>
<pre><code class="language-text">&gt;&gt;&gt; pyo3_test.add?
Signature: pyo3_test.add(a, b, /)
Docstring: This function adds two unsigned 64-bit integers.
Type:      builtin_function_or_method
</code></pre>
<h3 id="closures"><a class="header" href="#closures">Closures</a></h3>
<p>Currently, there are no conversions between <code>Fn</code>s in Rust and callables in Python. This would
definitely be possible and very useful, so contributions are welcome. In the meantime, you can do
the following:</p>
<h3 id="calling-python-functions-in-rust"><a class="header" href="#calling-python-functions-in-rust">Calling Python functions in Rust</a></h3>
<p>You can pass Python <code>def</code>'d functions and built-in functions to Rust functions <a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyFunction.html"><code>PyFunction</code></a>
corresponds to regular Python functions while <a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyCFunction.html"><code>PyCFunction</code></a> describes built-ins such as
<code>repr()</code>.</p>
<p>You can also use <a href="https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#tymethod.is_callable"><code>PyAny::is_callable</code></a> to check if you have a callable object. <code>is_callable</code> will
return <code>true</code> for functions (including lambdas), methods and objects with a <code>__call__</code> method.
You can call the object with <a href="https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#tymethod.call"><code>PyAny::call</code></a> with the args as first parameter and the kwargs
(or <code>None</code>) as second parameter. There are also <a href="https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#tymethod.call0"><code>PyAny::call0</code></a> with no args and <a href="https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#tymethod.call1"><code>PyAny::call1</code></a>
with only positional args.</p>
<h3 id="calling-rust-functions-in-python"><a class="header" href="#calling-rust-functions-in-python">Calling Rust functions in Python</a></h3>
<p>If you have a static function, you can expose it with <code>#[pyfunction]</code> and use <a href="https://pyo3.rs/main/doc/pyo3/macro.wrap_pyfunction.html"><code>wrap_pyfunction!</code></a>
to get the corresponding <a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyCFunction.html"><code>PyCFunction</code></a>. For dynamic functions, e.g. lambdas and functions that
were passed as arguments, you must put them in some kind of owned container, e.g. a <code>Box</code>.
(A long-term solution will be a special container similar to wasm-bindgen's <code>Closure</code>). You can
then use a <code>#[pyclass]</code> struct with that container as a field as a way to pass the function over
the FFI barrier. You can even make that class callable with <code>__call__</code> so it looks like a function
in Python code.</p>
<h3 id="accessing-the-ffi-functions"><a class="header" href="#accessing-the-ffi-functions">Accessing the FFI functions</a></h3>
<p>In order to make Rust functions callable from Python, PyO3 generates an <code>extern &quot;C&quot;</code>
function whose exact signature depends on the Rust signature.  (PyO3 chooses the optimal
Python argument passing convention.) It then embeds the call to the Rust function inside this
FFI-wrapper function. This wrapper handles extraction of the regular arguments and the keyword
arguments from the input <code>PyObject</code>s.</p>
<p>The <code>wrap_pyfunction</code> macro can be used to directly get a <code>PyCFunction</code> given a
<code>#[pyfunction]</code> and a <code>PyModule</code>: <code>wrap_pyfunction!(rust_fun, module)</code>.</p>
<h2 id="pyfn-shorthand"><a class="header" href="#pyfn-shorthand"><code>#[pyfn]</code> shorthand</a></h2>
<p>There is a shorthand to <code>#[pyfunction]</code> and <code>wrap_pymodule!</code>: the function can be placed inside the module definition and
annotated with <code>#[pyfn]</code>. To simplify PyO3, it is expected that <code>#[pyfn]</code> may be removed in a future release (See <a href="https://github.com/PyO3/pyo3/issues/694">#694</a>).</p>
<p>An example of <code>#[pyfn]</code> is below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pymodule]
fn my_extension(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    #[pyfn(m)]
    fn double(x: usize) -&gt; usize {
        x * 2
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>#[pyfn(m)]</code> is just syntactic sugar for <code>#[pyfunction]</code>, and takes all the same options
documented in the rest of this chapter. The code above is expanded to the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pymodule]
fn my_extension(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    #[pyfunction]
    fn double(x: usize) -&gt; usize {
        x * 2
    }

    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-classes"><a class="header" href="#python-classes">Python Classes</a></h1>
<p>PyO3 exposes a group of attributes powered by Rust's proc macro system for defining Python classes as Rust structs.</p>
<p>The main attribute is <code>#[pyclass]</code>, which is placed upon a Rust <code>struct</code> or a fieldless <code>enum</code> (a.k.a. C-like enum) to generate a Python type for it. They will usually also have <em>one</em> <code>#[pymethods]</code>-annotated <code>impl</code> block for the struct, which is used to define Python methods and constants for the generated Python type. (If the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature is enabled each <code>#[pyclass]</code> is allowed to have multiple <code>#[pymethods]</code> blocks.) <code>#[pymethods]</code> may also have implementations for Python magic methods such as <code>__str__</code>.</p>
<p>This chapter will discuss the functionality and configuration these attributes offer. Below is a list of links to the relevant section of this chapter for each:</p>
<ul>
<li><a href="class.html#defining-a-new-class"><code>#[pyclass]</code></a>
<ul>
<li><a href="class.html#object-properties-using-pyo3get-set"><code>#[pyo3(get, set)]</code></a></li>
</ul>
</li>
<li><a href="class.html#instance-methods"><code>#[pymethods]</code></a>
<ul>
<li><a href="class.html#constructor"><code>#[new]</code></a></li>
<li><a href="class.html#object-properties-using-getter-and-setter"><code>#[getter]</code></a></li>
<li><a href="class.html#object-properties-using-getter-and-setter"><code>#[setter]</code></a></li>
<li><a href="class.html#static-methods"><code>#[staticmethod]</code></a></li>
<li><a href="class.html#class-methods"><code>#[classmethod]</code></a></li>
<li><a href="class.html#class-attributes"><code>#[classattr]</code></a></li>
<li><a href="class.html#method-arguments"><code>#[args]</code></a></li>
</ul>
</li>
<li><a href="class/protocols.html">Magic methods and slots</a></li>
</ul>
<h2 id="defining-a-new-class"><a class="header" href="#defining-a-new-class">Defining a new class</a></h2>
<p>To define a custom Python class, add the <code>#[pyclass]</code> attribute to a Rust struct or a fieldless enum.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

#[pyclass]
struct Integer{
    inner: i32
}

// A &quot;tuple&quot; struct
#[pyclass]
struct Number(i32);

// PyO3 supports custom discriminants in enums
#[pyclass]
enum HttpResponse {
    Ok = 200,
    NotFound = 404,
    Teapot = 418,
    // ...
}

#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant = 30, // PyO3 supports custom discriminants.
}
<span class="boring">}
</span></code></pre></pre>
<p>Because Python objects are freely shared between threads by the Python interpreter, all types annotated with <code>#[pyclass]</code> must implement <code>Send</code> (unless annotated with <a href="class.html#customizing-the-class"><code>#[pyclass(unsendable)]</code></a>).</p>
<p>The above example generates implementations for <a href="https://pyo3.rs/main/doc/pyo3/type_object/trait.PyTypeInfo.html"><code>PyTypeInfo</code></a> and <a href="https://pyo3.rs/main/doc/pyo3/pyclass/trait.PyClass.html"><code>PyClass</code></a> for <code>MyClass</code> and <code>MyEnum</code>. To see these generated implementations, refer to the <a href="class.html#implementation-details">implementation details</a> at the end of this chapter.</p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>By default it is not possible to create an instance of a custom class from Python code.
To declare a constructor, you need to define a method and annotate it with the <code>#[new]</code>
attribute. Only Python's <code>__new__</code> method can be specified, <code>__init__</code> is not available.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Number(value)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, if your <code>new</code> method may fail you can return <code>PyResult&lt;Self&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::exceptions::PyValueError;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Nonzero(i32);
</span><span class="boring">
</span>#[pymethods]
impl Nonzero {
    #[new]
    fn py_new(value: i32) -&gt; PyResult&lt;Self&gt; {
        if value == 0 {
            Err(PyValueError::new_err(&quot;cannot be zero&quot;))
        } else {
            Ok(Nonzero(value))
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, the Rust method name is not important here; this way you can
still use <code>new()</code> for a Rust-level constructor.</p>
<p>If no method marked with <code>#[new]</code> is declared, object instances can only be
created from Rust, but not from Python.</p>
<p>For arguments, see the <code>Method arguments</code> section below.</p>
<h2 id="adding-the-class-to-a-module"><a class="header" href="#adding-the-class-to-a-module">Adding the class to a module</a></h2>
<p>The next step is to create the module initializer and add our class to it</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="pycell-and-interior-mutability"><a class="header" href="#pycell-and-interior-mutability">PyCell and interior mutability</a></h2>
<p>You sometimes need to convert your <code>pyclass</code> into a Python object and access it
from Rust code (e.g., for testing it).
<a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a> is the primary interface for that.</p>
<p><code>PyCell&lt;T: PyClass&gt;</code> is always allocated in the Python heap, so Rust doesn't have ownership of it.
In other words, Rust code can only extract a <code>&amp;PyCell&lt;T&gt;</code>, not a <code>PyCell&lt;T&gt;</code>.</p>
<p>Thus, to mutate data behind <code>&amp;PyCell</code> safely, PyO3 employs the
<a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">Interior Mutability Pattern</a>
like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>.</p>
<p>Users who are familiar with <code>RefCell</code> can use <code>PyCell</code> just like <code>RefCell</code>.</p>
<p>For users who are not very familiar with <code>RefCell</code>, here is a reminder of Rust's rules of borrowing:</p>
<ul>
<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p><code>PyCell</code>, like <code>RefCell</code>, ensures these borrowing rules by tracking references at runtime.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get)]
    num: i32,
}
Python::with_gil(|py| {
    let obj = PyCell::new(py, MyClass { num: 3}).unwrap();
    {
        let obj_ref = obj.borrow(); // Get PyRef
        assert_eq!(obj_ref.num, 3);
        // You cannot get PyRefMut unless all PyRefs are dropped
        assert!(obj.try_borrow_mut().is_err());
    }
    {
        let mut obj_mut = obj.borrow_mut(); // Get PyRefMut
        obj_mut.num = 5;
        // You cannot get any other refs until the PyRefMut is dropped
        assert!(obj.try_borrow().is_err());
        assert!(obj.try_borrow_mut().is_err());
    }

    // You can convert `&amp;PyCell` to a Python object
    pyo3::py_run!(py, obj, &quot;assert obj.num == 5&quot;);
});
<span class="boring">}
</span></code></pre></pre>
<p><code>&amp;PyCell&lt;T&gt;</code> is bounded by the same lifetime as a <a href="https://pyo3.rs/main/doc/pyo3/struct.GILGuard.html"><code>GILGuard</code></a>.
To make the object longer lived (for example, to store it in a struct on the
Rust side), you can use <code>Py&lt;T&gt;</code>, which stores an object longer than the GIL
lifetime, and therefore needs a <code>Python&lt;'_&gt;</code> token to access.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

fn return_myclass() -&gt; Py&lt;MyClass&gt; {
    Python::with_gil(|py| Py::new(py, MyClass { num: 1 }).unwrap())
}

let obj = return_myclass();

Python::with_gil(|py|{
    let cell = obj.as_ref(py); // Py&lt;MyClass&gt;::as_ref returns &amp;PyCell&lt;MyClass&gt;
    let obj_ref = cell.borrow(); // Get PyRef&lt;T&gt;
    assert_eq!(obj_ref.num, 1);
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="customizing-the-class"><a class="header" href="#customizing-the-class">Customizing the class</a></h2>
<p><code>#[pyclass]</code> can be used with the following parameters:</p>
<table><thead><tr><th align="left">Parameter</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><span style="white-space: pre"><code>crate = &quot;some::path&quot;</code></span></td><td align="left">Path to import the <code>pyo3</code> crate, if it's not accessible at <code>::pyo3</code>.</td></tr>
<tr><td align="left"><code>dict</code></td><td align="left">Gives instances of this class an empty <code>__dict__</code> to store custom attributes.</td></tr>
<tr><td align="left"><span style="white-space: pre"><code>extends = BaseType</code></span></td><td align="left">Use a custom baseclass. Defaults to <a href="https://pyo3.rs/main/doc/pyo3/prelude/struct.PyAny.html"><code>PyAny</code></a></td></tr>
<tr><td align="left"><span style="white-space: pre"><code>freelist = N</code></span></td><td align="left">Implements a <a href="https://en.wikipedia.org/wiki/Free_list">free list</a> of size N. This can improve performance for types that are often created and deleted in quick succession. Profile your code to see whether <code>freelist</code> is right for you.</td></tr>
<tr><td align="left"><code>mapping</code></td><td align="left">Inform PyO3 that this class is a <a href="./class/protocols.html#mapping--sequence-types"><code>Mapping</code></a>, and so leave its implementation of sequence C-API slots empty.</td></tr>
<tr><td align="left"><span style="white-space: pre"><code>module = &quot;module_name&quot;</code></span></td><td align="left">Python code will see the class as being defined in this module. Defaults to <code>builtins</code>.</td></tr>
<tr><td align="left"><span style="white-space: pre"><code>name = &quot;python_name&quot;</code></span></td><td align="left">Sets the name that Python sees this class as. Defaults to the name of the Rust struct.</td></tr>
<tr><td align="left"><span style="white-space: pre"><code>text_signature = &quot;(arg1, arg2, ...)&quot;</code></span></td><td align="left">Sets the text signature for the Python class' <code>__new__</code> method.</td></tr>
<tr><td align="left"><code>subclass</code></td><td align="left">Allows other Python classes and <code>#[pyclass]</code> to inherit from this class. Enums cannot be subclassed.</td></tr>
<tr><td align="left"><code>unsendable</code></td><td align="left">Required if your struct is not <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a>. Rather than using <code>unsendable</code>, consider implementing your struct in a threadsafe way by e.g. substituting <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>Rc</code></a> with <a href="https://doc.rust-lang.org/stable/std/sync/struct.Rc.html"><code>Arc</code></a>. By using <code>unsendable</code>, your class will panic when accessed by another thread.</td></tr>
<tr><td align="left"><code>weakref</code></td><td align="left">Allows this class to be <a href="https://docs.python.org/3/library/weakref.html">weakly referenceable</a>.</td></tr>
</tbody></table>
<p>All of these parameters can either be passed directly on the <code>#[pyclass(...)]</code> annotation, or as one or
more accompanying <code>#[pyo3(...)]</code> annotations, e.g.:</p>
<pre><code class="language-rust ignore">// Argument supplied directly to the `#[pyclass]` annotation.
#[pyclass(name = &quot;SomeName&quot;, subclass)]
struct MyClass { }

// Argument supplied as a separate annotation.
#[pyclass]
#[pyo3(name = &quot;SomeName&quot;, subclass)]
struct MyClass { }
</code></pre>
<p>These parameters are covered in various sections of this guide.</p>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>Generally, <code>#[new]</code> method have to return <code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code> or
<code>PyResult&lt;T&gt; where T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>.</p>
<p>For constructors that may fail, you should wrap the return type in a PyResult as well.
Consult the table below to determine which type your constructor should return:</p>
<table><thead><tr><th></th><th><strong>Cannot fail</strong></th><th><strong>May fail</strong></th></tr></thead><tbody>
<tr><td><strong>No inheritance</strong></td><td><code>T</code></td><td><code>PyResult&lt;T&gt;</code></td></tr>
<tr><td><strong>Inheritance(T Inherits U)</strong></td><td><code>(T, U)</code></td><td><code>PyResult&lt;(T, U)&gt;</code></td></tr>
<tr><td><strong>Inheritance(General Case)</strong></td><td><a href="https://pyo3.rs/main/doc/pyo3/pyclass_init/struct.PyClassInitializer.html"><code>PyClassInitializer&lt;T&gt;</code></a></td><td><code>PyResult&lt;PyClassInitializer&lt;T&gt;&gt;</code></td></tr>
</tbody></table>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>By default, <code>PyAny</code> is used as the base class. To override this default,
use the <code>extends</code> parameter for <code>pyclass</code> with the full path to the base class.</p>
<p>For convenience, <code>(T, U)</code> implements <code>Into&lt;PyClassInitializer&lt;T&gt;&gt;</code> where <code>U</code> is the
baseclass of <code>T</code>.
But for more deeply nested inheritance, you have to return <code>PyClassInitializer&lt;T&gt;</code>
explicitly.</p>
<p>To get a parent class from a child, use <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> instead of <code>&amp;self</code> for methods,
or <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a> instead of <code>&amp;mut self</code>.
Then you can access a parent class by <code>self_.as_ref()</code> as <code>&amp;Self::BaseClass</code>,
or by <code>self_.into_super()</code> as <code>PyRef&lt;Self::BaseClass&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(subclass)]
struct BaseClass {
    val1: usize,
}

#[pymethods]
impl BaseClass {
    #[new]
    fn new() -&gt; Self {
        BaseClass { val1: 10 }
    }

    pub fn method(&amp;self) -&gt; PyResult&lt;usize&gt; {
        Ok(self.val1)
    }
}

#[pyclass(extends=BaseClass, subclass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; (Self, BaseClass) {
        (SubClass { val2: 15 }, BaseClass::new())
    }

    fn method2(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let super_ = self_.as_ref();  // Get &amp;BaseClass
        super_.method().map(|x| x * self_.val2)
    }
}

#[pyclass(extends=SubClass)]
struct SubSubClass {
    val3: usize,
}

#[pymethods]
impl SubSubClass {
    #[new]
    fn new() -&gt; PyClassInitializer&lt;Self&gt; {
        PyClassInitializer::from(SubClass::new())
            .add_subclass(SubSubClass{val3: 20})
    }

    fn method3(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let v = self_.val3;
        let super_ = self_.into_super();  // Get PyRef&lt;'_, SubClass&gt;
        SubClass::method2(super_).map(|x| x * v)
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let subsub = pyo3::PyCell::new(py, SubSubClass::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, subsub, &quot;assert subsub.method3() == 3000&quot;)
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
<p>You can also inherit native types such as <code>PyDict</code>, if they implement
<a href="https://pyo3.rs/main/doc/pyo3/type_object/trait.PySizedLayout.html"><code>PySizedLayout</code></a>. However, this is not supported when building for the Python limited API (aka the <code>abi3</code> feature of PyO3).</p>
<p>However, because of some technical problems, we don't currently provide safe upcasting methods for types
that inherit native types. Even in such cases, you can unsafely get a base class by raw pointer conversion.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(not(Py_LIMITED_API))] {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;
use pyo3::AsPyPointer;
use std::collections::HashMap;

#[pyclass(extends=PyDict)]
#[derive(Default)]
struct DictWithCounter {
    counter: HashMap&lt;String, usize&gt;,
}

#[pymethods]
impl DictWithCounter {
    #[new]
    fn new() -&gt; Self {
        Self::default()
    }
    fn set(mut self_: PyRefMut&lt;'_, Self&gt;, key: String, value: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
        self_.counter.entry(key.clone()).or_insert(0);
        let py = self_.py();
        let dict: &amp;PyDict = unsafe { py.from_borrowed_ptr_or_err(self_.as_ptr())? };
        dict.set_item(key, value)
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let cnt = pyo3::PyCell::new(py, DictWithCounter::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, cnt, &quot;cnt.set('abc', 10); assert cnt['abc'] == 10&quot;)
</span><span class="boring">});
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>If <code>SubClass</code> does not provide a baseclass initialization, the compilation fails.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; Self {
        SubClass { val2: 15 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="object-properties"><a class="header" href="#object-properties">Object properties</a></h2>
<p>PyO3 supports two ways to add properties to your <code>#[pyclass]</code>:</p>
<ul>
<li>For simple struct fields with no side effects, a <code>#[pyo3(get, set)]</code> attribute can be added directly to the field definition in the <code>#[pyclass]</code>.</li>
<li>For properties which require computation you can define <code>#[getter]</code> and <code>#[setter]</code> functions in the <a href="class.html#instance-methods"><code>#[pymethods]</code></a> block.</li>
</ul>
<p>We'll cover each of these in the following sections.</p>
<h3 id="object-properties-using-pyo3get-set"><a class="header" href="#object-properties-using-pyo3get-set">Object properties using <code>#[pyo3(get, set)]</code></a></h3>
<p>For simple cases where a member variable is just read and written with no side effects, you can declare getters and setters in your <code>#[pyclass]</code> field definition using the <code>pyo3</code> attribute, like in the example below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get, set)]
    num: i32
}
<span class="boring">}
</span></code></pre></pre>
<p>The above would make the <code>num</code> field available for reading and writing as a <code>self.num</code> Python property. To expose the property with a different name to the field, specify this alongside the rest of the options, e.g. <code>#[pyo3(get, set, name = &quot;custom_name&quot;)]</code>.</p>
<p>Properties can be readonly or writeonly by using just <code>#[pyo3(get)]</code> or <code>#[pyo3(set)]</code> respectively.</p>
<p>To use these annotations, your field type must implement some conversion traits:</p>
<ul>
<li>For <code>get</code> the field type must implement both <code>IntoPy&lt;PyObject&gt;</code> and <code>Clone</code>.</li>
<li>For <code>set</code> the field type must implement <code>FromPyObject</code>.</li>
</ul>
<h3 id="object-properties-using-getter-and-setter"><a class="header" href="#object-properties-using-getter-and-setter">Object properties using <code>#[getter]</code> and <code>#[setter]</code></a></h3>
<p>For cases which don't satisfy the <code>#[pyo3(get, set)]</code> trait requirements, or need side effects, descriptor methods can be defined in a <code>#[pymethods]</code> <code>impl</code> block.</p>
<p>This is done using the <code>#[getter]</code> and <code>#[setter]</code> attributes, like in the example below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[getter]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A getter or setter's function name is used as the property name by default. There are several
ways how to override the name.</p>
<p>If a function name starts with <code>get_</code> or <code>set_</code> for getter or setter respectively,
the descriptor name becomes the function name with this prefix removed. This is also useful in case of
Rust keywords like <code>type</code>
(<a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/raw-identifiers.html">raw identifiers</a>
can be used since Rust 2018).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter]
    fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, a property <code>num</code> is defined and available from Python code as <code>self.num</code>.</p>
<p>Both the <code>#[getter]</code> and <code>#[setter]</code> attributes accept one parameter.
If this parameter is specified, it is used as the property name, i.e.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter(number)]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter(number)]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the property <code>number</code> is defined and available from Python code as <code>self.number</code>.</p>
<p>Attributes defined by <code>#[setter]</code> or <code>#[pyo3(set)]</code> will always raise <code>AttributeError</code> on <code>del</code>
operations. Support for defining custom <code>del</code> behavior is tracked in
<a href="https://github.com/PyO3/pyo3/issues/1778">#1778</a>.</p>
<h2 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h2>
<p>To define a Python compatible method, an <code>impl</code> block for your struct has to be annotated with the
<code>#[pymethods]</code> attribute. PyO3 generates Python compatible wrappers for all functions in this
block with some variations, like descriptors, class method static methods, etc.</p>
<p>Since Rust allows any number of <code>impl</code> blocks, you can easily split methods
between those accessible to Python (and Rust) and those accessible only to Rust. However to have multiple
<code>#[pymethods]</code>-annotated <code>impl</code> blocks for the same struct you must enable the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature of PyO3.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }

    fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calls to these methods are protected by the GIL, so both <code>&amp;self</code> and <code>&amp;mut self</code> can be used.
The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>;
the latter is allowed if the method cannot raise Python exceptions.</p>
<p>A <code>Python</code> parameter can be specified as part of method signature, in this case the <code>py</code> argument
gets injected by the method wrapper, e.g.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method2(&amp;self, py: Python&lt;'_&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>From the Python perspective, the <code>method2</code> in this example does not accept any arguments.</p>
<h2 id="class-methods"><a class="header" href="#class-methods">Class methods</a></h2>
<p>To create a class method for a custom class, the method needs to be annotated
with the <code>#[classmethod]</code> attribute.
This is the equivalent of the Python decorator <code>@classmethod</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    #[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[classmethod]
    fn cls_method(cls: &amp;PyType) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Declares a class method callable from Python.</p>
<ul>
<li>The first parameter is the type object of the class on which the method is called.
This may be the type object of a derived class.</li>
<li>The first parameter implicitly has type <code>&amp;PyType</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>.</li>
</ul>
<h2 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h2>
<p>To create a static method for a custom class, the method needs to be annotated with the
<code>#[staticmethod]</code> attribute. The return type must be <code>T</code> or <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements
<code>IntoPy&lt;PyObject&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    #[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[staticmethod]
    fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="class-attributes"><a class="header" href="#class-attributes">Class attributes</a></h2>
<p>To create a class attribute (also called <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables">class variable</a>), a method without
any arguments can be annotated with the <code>#[classattr]</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    fn my_attribute() -&gt; String {
        &quot;hello&quot;.to_string()
    }
}

Python::with_gil(|py| {
    let my_class = py.get_type::&lt;MyClass&gt;();
    pyo3::py_run!(py, my_class, &quot;assert my_class.my_attribute == 'hello'&quot;)
});
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: if the method has a <code>Result</code> return type and returns an <code>Err</code>, PyO3 will panic during
class creation.</p>
</blockquote>
<p>If the class attribute is defined with <code>const</code> code only, one can also annotate associated
constants:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    const MY_CONST_ATTRIBUTE: &amp;'static str = &quot;foobar&quot;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="method-arguments"><a class="header" href="#method-arguments">Method arguments</a></h2>
<p>By default, PyO3 uses function signatures to determine which arguments are required. Then it scans
the incoming <code>args</code> and <code>kwargs</code> parameters. If it can not find all required
parameters, it raises a <code>TypeError</code> exception. It is possible to override the default behavior
with the <code>#[args(...)]</code> attribute. This attribute accepts a comma separated list of parameters in
the form of <code>attr_name=&quot;default value&quot;</code>. Each parameter has to match the method parameter by name.</p>
<p>Each parameter can be one of the following types:</p>
<ul>
<li><code>&quot;/&quot;</code>: positional-only arguments separator, each parameter defined before <code>&quot;/&quot;</code> is a
positional-only parameter.
Corresponds to python's <code>def meth(arg1, arg2, ..., /, argN..)</code>.</li>
<li><code>&quot;*&quot;</code>: var arguments separator, each parameter defined after <code>&quot;*&quot;</code> is a keyword-only parameter.
Corresponds to python's <code>def meth(*, arg1.., arg2=..)</code>.</li>
<li><code>args=&quot;*&quot;</code>: &quot;args&quot; is var args, corresponds to Python's <code>def meth(*args)</code>. Type of the <code>args</code>
parameter has to be <code>&amp;PyTuple</code>.</li>
<li><code>kwargs=&quot;**&quot;</code>: &quot;kwargs&quot; receives keyword arguments, corresponds to Python's <code>def meth(**kwargs)</code>.
The type of the <code>kwargs</code> parameter has to be <code>Option&lt;&amp;PyDict&gt;</code>.</li>
<li><code>arg=&quot;Value&quot;</code>: arguments with default value. Corresponds to Python's <code>def meth(arg=Value)</code>.
If the <code>arg</code> argument is defined after var arguments, it is treated as a keyword-only argument.
Note that <code>Value</code> has to be valid rust code, PyO3 just inserts it into the generated
code unmodified.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::{PyDict, PyTuple};
<span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[new]
    #[args(num = &quot;-1&quot;)]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }

    #[args(
        num = &quot;10&quot;,
        py_args = &quot;*&quot;,
        name = &quot;\&quot;Hello\&quot;&quot;,
        py_kwargs = &quot;**&quot;
    )]
    fn method(
        &amp;mut self,
        num: i32,
        name: &amp;str,
        py_args: &amp;PyTuple,
        py_kwargs: Option&lt;&amp;PyDict&gt;,
    ) -&gt; PyResult&lt;String&gt; {
        self.num = num;
        Ok(format!(
            &quot;py_args={:?}, py_kwargs={:?}, name={}, num={}&quot;,
            py_args, py_kwargs, name, self.num
        ))
    }

    fn make_change(&amp;mut self, num: i32) -&gt; PyResult&lt;String&gt; {
        self.num = num;
        Ok(format!(&quot;num={}&quot;, self.num))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>N.B. the position of the <code>&quot;/&quot;</code> and <code>&quot;*&quot;</code> arguments (if included) control the system of handling positional and keyword arguments. In Python:</p>
<pre><code class="language-python">import mymodule

mc = mymodule.MyClass()
print(mc.method(44, False, &quot;World&quot;, 666, x=44, y=55))
print(mc.method(num=-1, name=&quot;World&quot;))
print(mc.make_change(44, False))
</code></pre>
<p>Produces output:</p>
<pre><code class="language-text">py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44
py_args=(), py_kwargs=None, name=World, num=-1
num=44
num=-1
</code></pre>
<h2 id="making-class-method-signatures-available-to-python"><a class="header" href="#making-class-method-signatures-available-to-python">Making class method signatures available to Python</a></h2>
<p>The <a href="./function.html#text_signature"><code>text_signature = &quot;...&quot;</code></a> option for <code>#[pyfunction]</code> also works for classes and methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;
use pyo3::types::PyType;

// it works even if the item is not documented:
#[pyclass(text_signature = &quot;(c, d, /)&quot;)]
struct MyClass {}

#[pymethods]
impl MyClass {
    // the signature for the constructor is attached
    // to the struct definition instead.
    #[new]
    fn new(c: i32, d: &amp;str) -&gt; Self {
        Self {}
    }
    // the self argument should be written $self
    #[pyo3(text_signature = &quot;($self, e, f)&quot;)]
    fn my_method(&amp;self, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[classmethod]
    #[pyo3(text_signature = &quot;(cls, e, f)&quot;)]
    fn my_class_method(cls: &amp;PyType, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[staticmethod]
    #[pyo3(text_signature = &quot;(e, f)&quot;)]
    fn my_static_method(e: i32, f: i32) -&gt; i32 {
        e + f
    }
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let inspect = PyModule::import(py, &quot;inspect&quot;)?.getattr(&quot;signature&quot;)?;
</span><span class="boring">        let module = PyModule::new(py, &quot;my_module&quot;)?;
</span><span class="boring">        module.add_class::&lt;MyClass&gt;()?;
</span><span class="boring">        let class = module.getattr(&quot;MyClass&quot;)?;
</span><span class="boring">
</span><span class="boring">        if cfg!(not(Py_LIMITED_API)) || py.version_info() &gt;= (3, 10)  {
</span><span class="boring">            let doc: String = class.getattr(&quot;__doc__&quot;)?.extract()?;
</span><span class="boring">            assert_eq!(doc, &quot;&quot;);
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((class,))?
</span><span class="boring">                .call_method0(&quot;__str__&quot;)?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, &quot;(c, d, /)&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            let doc: String = class.getattr(&quot;__doc__&quot;)?.extract()?;
</span><span class="boring">            assert_eq!(doc, &quot;&quot;);
</span><span class="boring">
</span><span class="boring">            inspect.call1((class,)).expect_err(&quot;`text_signature` on classes is not compatible with compilation in `abi3` mode until Python 3.10 or greater&quot;);
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr(&quot;my_method&quot;)?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr(&quot;__doc__&quot;)?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0(&quot;__str__&quot;)?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, &quot;(self, /, e, f)&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr(&quot;my_class_method&quot;)?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr(&quot;__doc__&quot;)?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0(&quot;__str__&quot;)?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, &quot;(cls, e, f)&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr(&quot;my_static_method&quot;)?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr(&quot;__doc__&quot;)?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0(&quot;__str__&quot;)?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, &quot;(e, f)&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>Note that <code>text_signature</code> on classes is not compatible with compilation in
<code>abi3</code> mode until Python 3.10 or greater.</p>
<h2 id="pyclass-enums"><a class="header" href="#pyclass-enums">#[pyclass] enums</a></h2>
<p>Currently PyO3 only supports fieldless enums. PyO3 adds a class attribute for each variant, so you can access them in Python without defining <code>#[new]</code>. PyO3 also provides default implementations of <code>__richcmp__</code> and <code>__int__</code>, so they can be compared using <code>==</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant,
}

Python::with_gil(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let y = Py::new(py, MyEnum::OtherVariant).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x y cls, r#&quot;
        assert x == cls.Variant
        assert y == cls.OtherVariant
        assert x != y
    &quot;#)
})
<span class="boring">}
</span></code></pre></pre>
<p>You can also convert your enums into <code>int</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant = 10,
}

Python::with_gil(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let x = MyEnum::Variant as i32; // The exact value is assigned by the compiler.
    pyo3::py_run!(py, cls x, r#&quot;
        assert int(cls.Variant) == x
        assert int(cls.OtherVariant) == 10
        assert cls.OtherVariant == 10  # You can also compare against int.
        assert 10 == cls.OtherVariant
    &quot;#)
})
<span class="boring">}
</span></code></pre></pre>
<p>PyO3 also provides <code>__repr__</code> for enums:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum{
    Variant,
    OtherVariant,
}

Python::with_gil(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let x = Py::new(py, MyEnum::Variant).unwrap();
    pyo3::py_run!(py, cls x, r#&quot;
        assert repr(x) == 'MyEnum.Variant'
        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'
    &quot;#)
})
<span class="boring">}
</span></code></pre></pre>
<p>All methods defined by PyO3 can be overridden. For example here's how you override <code>__repr__</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Answer = 42,
}

#[pymethods]
impl MyEnum {
    fn __repr__(&amp;self) -&gt; &amp;'static str {
        &quot;42&quot;
    }
}

Python::with_gil(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, cls, &quot;assert repr(cls.Answer) == '42'&quot;)
})
<span class="boring">}
</span></code></pre></pre>
<p>You may not use enums as a base class or let enums inherit from other classes.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(subclass)]
enum BadBase{
    Var1,
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(subclass)]
struct Base;

#[pyclass(extends=Base)]
enum BadSubclass{
    Var1,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>#[pyclass]</code> enums are currently not interoperable with <code>IntEnum</code> in Python.</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>The <code>#[pyclass]</code> macros rely on a lot of conditional code generation: each <code>#[pyclass]</code> can optionally have a <code>#[pymethods]</code> block.</p>
<p>To support this flexibility the <code>#[pyclass]</code> macro expands to a blob of boilerplate code which sets up the structure for <a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">&quot;dtolnay specialization&quot;</a>. This implementation pattern enables the Rust compiler to use <code>#[pymethods]</code> implementations when they are present, and fall back to default (empty) definitions when they are not.</p>
<p>This simple technique works for the case when there is zero or one implementations. To support multiple <code>#[pymethods]</code> for a <code>#[pyclass]</code> (in the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature), a registry mechanism provided by the <a href="https://github.com/dtolnay/inventory"><code>inventory</code></a> crate is used instead. This collects <code>impl</code>s at library load time, but isn't supported on all platforms. See <a href="https://github.com/dtolnay/inventory#how-it-works">inventory: how it works</a> for more details.</p>
<p>The <code>#[pyclass]</code> macro expands to roughly the code seen below. The <code>PyClassImplCollector</code> is the type used internally by PyO3 for dtolnay specialization:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(not(feature = &quot;multiple-pymethods&quot;))] {
</span><span class="boring">use pyo3::prelude::*;
</span>// Note: the implementation differs slightly with the `multiple-pymethods` feature enabled.
struct MyClass {
<span class="boring">    #[allow(dead_code)]
</span>    num: i32,
}
unsafe impl ::pyo3::type_object::PyTypeInfo for MyClass {
    type AsRefTarget = ::pyo3::PyCell&lt;Self&gt;;
    const NAME: &amp;'static str = &quot;MyClass&quot;;
    const MODULE: ::std::option::Option&lt;&amp;'static str&gt; = ::std::option::Option::None;
    #[inline]
    fn type_object_raw(py: pyo3::Python&lt;'_&gt;) -&gt; *mut pyo3::ffi::PyTypeObject {
        use pyo3::type_object::LazyStaticType;
        static TYPE_OBJECT: LazyStaticType = LazyStaticType::new();
        TYPE_OBJECT.get_or_init::&lt;Self&gt;(py)
    }
}

impl ::pyo3::PyClass for MyClass { }

impl&lt;'a&gt; ::pyo3::derive_utils::ExtractExt&lt;'a&gt; for &amp;'a mut MyClass {
    type Target = ::pyo3::PyRefMut&lt;'a, MyClass&gt;;
}

impl&lt;'a&gt; ::pyo3::derive_utils::ExtractExt&lt;'a&gt; for &amp;'a MyClass {
    type Target = ::pyo3::PyRef&lt;'a, MyClass&gt;;
}

impl pyo3::IntoPy&lt;PyObject&gt; for MyClass {
    fn into_py(self, py: pyo3::Python&lt;'_&gt;) -&gt; pyo3::PyObject {
        pyo3::IntoPy::into_py(pyo3::Py::new(py, self).unwrap(), py)
    }
}

impl pyo3::impl_::pyclass::PyClassImpl for MyClass {
    const DOC: &amp;'static str = &quot;Class for demonstration\u{0}&quot;;
    const IS_BASETYPE: bool = false;
    const IS_SUBCLASS: bool = false;
    type Layout = PyCell&lt;MyClass&gt;;
    type BaseType = PyAny;
    type ThreadChecker = pyo3::impl_::pyclass::ThreadCheckerStub&lt;MyClass&gt;;
    type Mutability = pyo3::pycell::Mutable;
    type PyClassMutability = pyo3::pycell::MutableClass;
    type Dict = ::pyo3::impl_::pyclass::PyClassDummySlot;
    type WeakRef = ::pyo3::impl_::pyclass::PyClassDummySlot;
    type BaseNativeType = ::pyo3::PyAny;

    fn for_all_items(visitor: &amp;mut dyn FnMut(&amp;pyo3::impl_::pyclass::PyClassItems)) {
        use pyo3::impl_::pyclass::*;
        let collector = PyClassImplCollector::&lt;MyClass&gt;::new();
        static INTRINSIC_ITEMS: PyClassItems = PyClassItems { slots: &amp;[], methods: &amp;[] };
        visitor(&amp;INTRINSIC_ITEMS);
        visitor(collector.py_methods());
    }
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let cls = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">    pyo3::py_run!(py, cls, &quot;assert cls.__name__ == 'MyClass'&quot;)
</span><span class="boring">});
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magic-methods-and-slots"><a class="header" href="#magic-methods-and-slots">Magic methods and slots</a></h1>
<p>Python's object model defines several protocols for different object behavior, such as the sequence, mapping, and number protocols. You may be familiar with implementing these protocols in Python classes by &quot;magic&quot; methods, such as <code>__str__</code> or <code>__repr__</code>. Because of the double-underscores surrounding their name, these are also known as &quot;dunder&quot; methods.</p>
<p>In the Python C-API which PyO3 is implemented upon, many of these magic methods have to be placed into special &quot;slots&quot; on the class type object, as covered in the previous section. There are two ways in which this can be done:</p>
<ul>
<li>In <code>#[pymethods]</code>, if the name of the method is a recognised magic method, PyO3 will place it in the type object automatically.</li>
<li>[Deprecated since PyO3 0.16] In special traits combined with the <code>#[pyproto]</code> attribute.</li>
</ul>
<p>(There are also many magic methods which don't have a special slot, such as <code>__dir__</code>. These methods can be implemented as normal in <code>#[pymethods]</code>.)</p>
<p>If a function name in <code>#[pymethods]</code> is a recognised magic method, it will be automatically placed into the correct slot in the Python type object. The function name is taken from the usual rules for naming <code>#[pymethods]</code>: the <code>#[pyo3(name = &quot;...&quot;)]</code> attribute is used if present, otherwise the Rust function name is used.</p>
<p>The magic methods handled by PyO3 are very similar to the standard Python ones on <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names">this page</a> - in particular they are the the subset which have slots as <a href="https://docs.python.org/3/c-api/typeobj.html">defined here</a>. Some of the slots do not have a magic method in Python, which leads to a few additional magic methods defined only in PyO3:</p>
<ul>
<li>Magic methods for garbage collection</li>
<li>Magic methods for the buffer protocol</li>
</ul>
<p>When PyO3 handles a magic method, a couple of changes apply compared to other <code>#[pymethods]</code>:</p>
<ul>
<li>The <code>#[pyo3(text_signature = &quot;...&quot;)]</code> attribute is not allowed</li>
<li>The signature is restricted to match the magic method</li>
</ul>
<p>The following sections list of all magic methods PyO3 currently handles.  The
given signatures should be interpreted as follows:</p>
<ul>
<li>All methods take a receiver as first argument, shown as <code>&lt;self&gt;</code>. It can be
<code>&amp;self</code>, <code>&amp;mut self</code> or a <code>PyCell</code> reference like <code>self_: PyRef&lt;'_, Self&gt;</code> and
<code>self_: PyRefMut&lt;'_, Self&gt;</code>, as described <a href="class/../class.html#inheritance">here</a>.</li>
<li>An optional <code>Python&lt;'py&gt;</code> argument is always allowed as the first argument.</li>
<li>Return values can be optionally wrapped in <code>PyResult</code>.</li>
<li><code>object</code> means that any type is allowed that can be extracted from a Python
object (if argument) or converted to a Python object (if return value).</li>
<li>Other types must match what's given, e.g. <code>pyo3::basic::CompareOp</code> for
<code>__richcmp__</code>'s second argument.</li>
<li>For the comparison and arithmetic methods, extraction errors are not
propagated as exceptions, but lead to a return of <code>NotImplemented</code>.</li>
<li>For some magic methods, the return values are not restricted by PyO3, but
checked by the Python interpreter. For example, <code>__str__</code> needs to return a
string object.  This is indicated by <code>object (Python type)</code>.</li>
</ul>
<h3 id="basic-object-customization"><a class="header" href="#basic-object-customization">Basic object customization</a></h3>
<ul>
<li>
<p><code>__str__(&lt;self&gt;) -&gt; object (str)</code></p>
</li>
<li>
<p><code>__repr__(&lt;self&gt;) -&gt; object (str)</code></p>
</li>
<li>
<p><code>__hash__(&lt;self&gt;) -&gt; isize</code></p>
<p>Objects that compare equal must have the same hash value.</p>
<details>
<summary>Disabling Python's default hash</summary>
By default, all `#[pyclass]` types have a default hash implementation from Python. Types which should not be hashable can override this by setting `__hash__` to `None`. This is the same mechanism as for a pure-Python class. This is done like so:
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span>#[pyclass]
struct NotHashable { }

#[pymethods]
impl NotHashable {
    #[classattr]
    const __hash__: Option&lt;PyObject&gt; = None;
}
<span class="boring">}
</span></code></pre></pre>
</details>
</li>
<li>
<p><code>__richcmp__(&lt;self&gt;, object, pyo3::basic::CompareOp) -&gt; object</code></p>
<p>Overloads Python comparison operations (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>).
The <code>CompareOp</code> argument indicates the comparison operation being performed.</p>
<details>
<summary>Return type</summary>
The return type will normally be `PyResult<bool>`, but any Python object can be returned.
If the `object` is not of the type specified in the signature, the generated code will
automatically `return NotImplemented`.
</details>
</li>
<li>
<p><code>__getattr__(&lt;self&gt;, object) -&gt; object</code></p>
</li>
<li>
<p><code>__getattribute__(&lt;self&gt;, object) -&gt; object</code></p>
<details>
<summary>Differences between `__getattr__` and `__getattribute__`</summary>
As in Python, `__getattr__` is only called if the attribute is not found
by normal attribute lookup.  `__getattribute__`, on the other hand, is
called for *every* attribute access.  If it wants to access existing
attributes on `self`, it needs to be very careful not to introduce
infinite recursion, and use `baseclass.__getattribute__()`.
</details>
</li>
<li>
<p><code>__setattr__(&lt;self&gt;, value: object) -&gt; ()</code></p>
</li>
<li>
<p><code>__delattr__(&lt;self&gt;, object) -&gt; ()</code></p>
<p>Overrides attribute access.</p>
</li>
<li>
<p><code>__bool__(&lt;self&gt;) -&gt; bool</code></p>
<p>Determines the &quot;truthyness&quot; of an object.</p>
</li>
<li>
<p><code>__call__(&lt;self&gt;, ...) -&gt; object</code> - here, any argument list can be defined
as for normal <code>pymethods</code></p>
</li>
</ul>
<h3 id="iterable-objects"><a class="header" href="#iterable-objects">Iterable objects</a></h3>
<p>Iterators can be defined using these methods:</p>
<ul>
<li><code>__iter__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__next__(&lt;self&gt;) -&gt; Option&lt;object&gt; or IterNextOutput</code> (<a href="class/protocols.html#returning-a-value-from-iteration">see details</a>)</li>
</ul>
<p>Returning <code>None</code> from <code>__next__</code> indicates that that there are no further items.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct MyIterator {
    iter: Box&lt;dyn Iterator&lt;Item = PyObject&gt; + Send&gt;,
}

#[pymethods]
impl MyIterator {
    fn __iter__(slf: PyRef&lt;'_, Self&gt;) -&gt; PyRef&lt;'_, Self&gt; {
        slf
    }
    fn __next__(mut slf: PyRefMut&lt;'_, Self&gt;) -&gt; Option&lt;PyObject&gt; {
        slf.iter.next()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In many cases you'll have a distinction between the type being iterated over
(i.e. the <em>iterable</em>) and the iterator it provides. In this case, the iterable
only needs to implement <code>__iter__()</code> while the iterator must implement both
<code>__iter__()</code> and <code>__next__()</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct Iter {
    inner: std::vec::IntoIter&lt;usize&gt;,
}

#[pymethods]
impl Iter {
    fn __iter__(slf: PyRef&lt;'_, Self&gt;) -&gt; PyRef&lt;'_, Self&gt; {
        slf
    }

    fn __next__(mut slf: PyRefMut&lt;'_, Self&gt;) -&gt; Option&lt;usize&gt; {
        slf.inner.next()
    }
}

#[pyclass]
struct Container {
    iter: Vec&lt;usize&gt;,
}

#[pymethods]
impl Container {
    fn __iter__(slf: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;Py&lt;Iter&gt;&gt; {
        let iter = Iter {
            inner: slf.iter.clone().into_iter(),
        };
        Py::new(slf.py(), iter)
    }
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let container = Container { iter: vec![1, 2, 3, 4] };
</span><span class="boring">    let inst = pyo3::PyCell::new(py, container).unwrap();
</span><span class="boring">    pyo3::py_run!(py, inst, &quot;assert list(inst) == [1, 2, 3, 4]&quot;);
</span><span class="boring">    pyo3::py_run!(py, inst, &quot;assert list(iter(iter(inst))) == [1, 2, 3, 4]&quot;);
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
<p>For more details on Python's iteration protocols, check out <a href="https://docs.python.org/library/stdtypes.html#iterator-types">the &quot;Iterator Types&quot; section of the library
documentation</a>.</p>
<h4 id="returning-a-value-from-iteration"><a class="header" href="#returning-a-value-from-iteration">Returning a value from iteration</a></h4>
<p>This guide has so far shown how to use <code>Option&lt;T&gt;</code> to implement yielding values
during iteration.  In Python a generator can also return a value. To express
this in Rust, PyO3 provides the <a href="https://pyo3.rs/main/doc/pyo3/class/iter/enum.IterNextOutput.html"><code>IterNextOutput</code></a> enum to both <code>Yield</code> values
and <code>Return</code> a final value - see its docs for further details and an example.</p>
<h3 id="awaitable-objects"><a class="header" href="#awaitable-objects">Awaitable objects</a></h3>
<ul>
<li><code>__await__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__aiter__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__anext__(&lt;self&gt;) -&gt; Option&lt;object&gt; or IterANextOutput</code></li>
</ul>
<h3 id="mapping--sequence-types"><a class="header" href="#mapping--sequence-types">Mapping &amp; Sequence types</a></h3>
<p>The magic methods in this section can be used to implement Python container types. They are two main categories of container in Python: &quot;mappings&quot; such as <code>dict</code>, with arbitrary keys, and &quot;sequences&quot; such as <code>list</code> and <code>tuple</code>, with integer keys.</p>
<p>The Python C-API which PyO3 is built upon has separate &quot;slots&quot; for sequences and mappings. When writing a <code>class</code> in pure Python, there is no such distinction in the implementation - a <code>__getitem__</code> implementation will fill the slots for both the mapping and sequence forms, for example.</p>
<p>By default PyO3 reproduces the Python behaviour of filling both mapping and sequence slots. This makes sense for the &quot;simple&quot; case which matches Python, and also for sequences, where the mapping slot is used anyway to implement slice indexing.</p>
<p>Mapping types usually will not want the sequence slots filled. Having them filled will lead to outcomes which may be unwanted, such as:</p>
<ul>
<li>The mapping type will successfully cast to <a href="https://pyo3.rs/main/doc/pyo3/types/struct.PySequence.html"><code>PySequence</code></a>. This may lead to consumers of the type handling it incorrectly.</li>
<li>Python provides a default implementation of <code>__iter__</code> for sequences, which calls <code>__getitem__</code> with consecutive positive integers starting from 0 until an <code>IndexError</code> is returned. Unless the mapping only contains consecutive positive integer keys, this <code>__iter__</code> implementation will likely not be the intended behavior.</li>
</ul>
<p>Use the <code>#[pyclass(mapping)]</code> annotation to instruct PyO3 to only fill the mapping slots, leaving the sequence ones empty. This will apply to <code>__getitem__</code>, <code>__setitem__</code>, and <code>__delitem__</code>.</p>
<ul>
<li>
<p><code>__len__(&lt;self&gt;) -&gt; usize</code></p>
<p>Implements the built-in function <code>len()</code> for the sequence.</p>
</li>
<li>
<p><code>__contains__(&lt;self&gt;, object) -&gt; bool</code></p>
<p>Implements membership test operators.
Should return true if <code>item</code> is in <code>self</code>, false otherwise.
For objects that don’t define <code>__contains__()</code>, the membership test simply
traverses the sequence until it finds a match.</p>
<details>
<summary>Disabling Python's default contains</summary>
<p>By default, all <code>#[pyclass]</code> types with an <code>__iter__</code> method support a
default implementation of the <code>in</code> operator. Types which do not want this
can override this by setting <code>__contains__</code> to <code>None</code>. This is the same
mechanism as for a pure-Python class. This is done like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span>#[pyclass]
struct NoContains { }

#[pymethods]
impl NoContains {
    #[classattr]
    const __contains__: Option&lt;PyObject&gt; = None;
}
<span class="boring">}
</span></code></pre></pre>
</details>
</li>
<li>
<p><code>__getitem__(&lt;self&gt;, object) -&gt; object</code></p>
<p>Implements retrieval of the <code>self[a]</code> element.</p>
<p><em>Note:</em> Negative integer indexes are not handled specially.</p>
</li>
<li>
<p><code>__setitem__(&lt;self&gt;, object, object) -&gt; ()</code></p>
<p>Implements assignment to the <code>self[a]</code> element.
Should only be implemented if elements can be replaced.</p>
</li>
<li>
<p><code>__delitem__(&lt;self&gt;, object) -&gt; ()</code></p>
<p>Implements deletion of the <code>self[a]</code> element.
Should only be implemented if elements can be deleted.</p>
</li>
</ul>
<ul>
<li>
<p><code>fn __concat__(&amp;self, other: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Concatenates two sequences.
Used by the <code>+</code> operator, after trying the numeric addition via
the <code>__add__</code> and <code>__radd__</code> methods.</p>
</li>
<li>
<p><code>fn __repeat__(&amp;self, count: isize) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Repeats the sequence <code>count</code> times.
Used by the <code>*</code> operator, after trying the numeric multiplication via
the <code>__mul__</code> and <code>__rmul__</code> methods.</p>
</li>
<li>
<p><code>fn __inplace_concat__(&amp;self, other: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Concatenates two sequences.
Used by the <code>+=</code> operator, after trying the numeric addition via
the <code>__iadd__</code> method.</p>
</li>
<li>
<p><code>fn __inplace_repeat__(&amp;self, count: isize) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Concatenates two sequences.
Used by the <code>*=</code> operator, after trying the numeric multiplication via
the <code>__imul__</code> method.</p>
</li>
</ul>
<h3 id="descriptors"><a class="header" href="#descriptors">Descriptors</a></h3>
<ul>
<li><code>__get__(&lt;self&gt;, object, object) -&gt; object</code></li>
<li><code>__set__(&lt;self&gt;, object, object) -&gt; ()</code></li>
<li><code>__delete__(&lt;self&gt;, object) -&gt; ()</code></li>
</ul>
<h3 id="numeric-types"><a class="header" href="#numeric-types">Numeric types</a></h3>
<p>Binary arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>divmod()</code>,
<code>pow()</code> and <code>**</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, and <code>|</code>) and their reflected versions:</p>
<p>(If the <code>object</code> is not of the type specified in the signature, the generated code
will automatically <code>return NotImplemented</code>.)</p>
<ul>
<li><code>__add__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__radd__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__sub__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rsub__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__mul__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rmul__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__matmul__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rmatmul__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__floordiv__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rfloordiv__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__truediv__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rtruediv__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__divmod__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rdivmod__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__mod__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rmod__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__lshift__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rlshift__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rshift__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rrshift__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__and__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rand__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__xor__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rxor__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__or__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__ror__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__pow__(&lt;self&gt;, object, object) -&gt; object</code></li>
<li><code>__rpow__(&lt;self&gt;, object, object) -&gt; object</code></li>
</ul>
<p>In-place assignment operations (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>@=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>,
<code>**=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>):</p>
<ul>
<li><code>__iadd__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__isub__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__imul__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__imatmul__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__itruediv__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__ifloordiv__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__imod__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__ipow__(&lt;self&gt;, object, object) -&gt; ()</code></li>
<li><code>__ilshift__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__irshift__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__iand__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__ixor__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__ior__(&lt;self&gt;, object) -&gt; ()</code></li>
</ul>
<p>Unary operations (<code>-</code>, <code>+</code>, <code>abs()</code> and <code>~</code>):</p>
<ul>
<li><code>__pos__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__neg__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__abs__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__invert__(&lt;self&gt;) -&gt; object</code></li>
</ul>
<p>Coercions:</p>
<ul>
<li><code>__index__(&lt;self&gt;) -&gt; object (int)</code></li>
<li><code>__int__(&lt;self&gt;) -&gt; object (int)</code></li>
<li><code>__float__(&lt;self&gt;) -&gt; object (float)</code></li>
</ul>
<h3 id="buffer-objects"><a class="header" href="#buffer-objects">Buffer objects</a></h3>
<ul>
<li><code>__getbuffer__(&lt;self&gt;, *mut ffi::Py_buffer, flags) -&gt; ()</code></li>
<li><code>__releasebuffer__(&lt;self&gt;, *mut ffi::Py_buffer)</code> (no return value, not even <code>PyResult</code>)</li>
</ul>
<h3 id="garbage-collector-integration"><a class="header" href="#garbage-collector-integration">Garbage Collector Integration</a></h3>
<p>If your type owns references to other Python objects, you will need to integrate
with Python's garbage collector so that the GC is aware of those references.  To
do this, implement the two methods <code>__traverse__</code> and <code>__clear__</code>.  These
correspond to the slots <code>tp_traverse</code> and <code>tp_clear</code> in the Python C API.
<code>__traverse__</code> must call <code>visit.call()</code> for each reference to another Python
object.  <code>__clear__</code> must clear out any mutable references to other Python
objects (thus breaking reference cycles). Immutable references do not have to be
cleared, as every cycle must contain at least one mutable reference.</p>
<ul>
<li><code>__traverse__(&lt;self&gt;, pyo3::class::gc::PyVisit&lt;'_&gt;) -&gt; Result&lt;(), pyo3::class::gc::PyTraverseError&gt;</code></li>
<li><code>__clear__(&lt;self&gt;) -&gt; ()</code></li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::PyTraverseError;
use pyo3::gc::PyVisit;

#[pyclass]
struct ClassWithGCSupport {
    obj: Option&lt;PyObject&gt;,
}

#[pymethods]
impl ClassWithGCSupport {
    fn __traverse__(&amp;self, visit: PyVisit&lt;'_&gt;) -&gt; Result&lt;(), PyTraverseError&gt; {
        if let Some(obj) = &amp;self.obj {
            visit.call(obj)?
        }
        Ok(())
    }

    fn __clear__(&amp;mut self) {
        // Clear reference, this decrements ref counter.
        self.obj = None;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="pyproto-traits"><a class="header" href="#pyproto-traits"><code>#[pyproto]</code> traits</a></h3>
<p>PyO3 can use the <code>#[pyproto]</code> attribute in combination with special traits to implement the magic methods which need slots. The special traits are listed below. See also the <a href="https://pyo3.rs/main/doc/pyo3/class/index.html">documentation for the <code>pyo3::class</code> module</a>.</p>
<p>Due to complexity in the implementation and usage, these traits were deprecated in PyO3 0.16 in favour of the <code>#[pymethods]</code> solution.</p>
<p>All <code>#[pyproto]</code> methods can return <code>T</code> instead of <code>PyResult&lt;T&gt;</code> if the method implementation is infallible. In addition, if the return type is <code>()</code>, it can be omitted altogether.</p>
<h4 id="basic-object-customization-1"><a class="header" href="#basic-object-customization-1">Basic object customization</a></h4>
<p>The <a href="https://pyo3.rs/main/doc/pyo3/class/basic/trait.PyObjectProtocol.html"><code>PyObjectProtocol</code></a> trait provides several basic customizations.</p>
<ul>
<li><code>fn __str__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></li>
<li><code>fn __repr__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></li>
<li><code>fn __hash__(&amp;self) -&gt; PyResult&lt;impl PrimInt&gt;</code></li>
<li><code>fn __richcmp__(&amp;self, other: impl FromPyObject, op: CompareOp) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __getattr__(&amp;self, name: impl FromPyObject) -&gt; PyResult&lt;impl IntoPy&lt;PyObject&gt;&gt;</code></li>
<li><code>fn __setattr__(&amp;mut self, name: impl FromPyObject, value: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __delattr__(&amp;mut self, name: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __bool__(&amp;self) -&gt; PyResult&lt;bool&gt;</code></li>
</ul>
<h4 id="emulating-numeric-types"><a class="header" href="#emulating-numeric-types">Emulating numeric types</a></h4>
<p>The <a href="https://pyo3.rs/main/doc/pyo3/class/number/trait.PyNumberProtocol.html"><code>PyNumberProtocol</code></a> trait can be implemented to emulate <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types">numeric types</a>.</p>
<ul>
<li><code>fn __add__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __sub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __mul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __matmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __truediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __floordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __mod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __divmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __pow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: Option&lt;impl FromPyObject&gt;) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __lshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __and__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __or__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __xor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<p>These methods are called to implement the binary arithmetic operations.</p>
<p>The reflected operations are also available:</p>
<ul>
<li><code>fn __radd__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rsub__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rmatmul__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rtruediv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rfloordiv__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rdivmod__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rpow__(lhs: impl FromPyObject, rhs: impl FromPyObject, modulo: Option&lt;impl FromPyObject&gt;) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rlshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rrshift__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rand__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __ror__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __rxor__(lhs: impl FromPyObject, rhs: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<p>The code generated for these methods expect that all arguments match the
signature, or raise a TypeError.</p>
<ul>
<li><code>fn __iadd__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __isub__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __imul__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __imatmul__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __itruediv__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ifloordiv__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __imod__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ipow__(&amp;'p mut self, other: impl FromPyObject, modulo: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code> on Python 3.8^</li>
<li><code>fn __ipow__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code> on Python 3.7 see https://bugs.python.org/issue36379</li>
<li><code>fn __ilshift__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __irshift__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __iand__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ior__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __ixor__(&amp;'p mut self, other: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
</ul>
<p>The following methods implement the unary arithmetic operations:</p>
<ul>
<li><code>fn __neg__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __pos__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __abs__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __invert__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<p>Support for coercions:</p>
<ul>
<li><code>fn __int__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __float__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
<li><code>fn __index__(&amp;'p self) -&gt; PyResult&lt;impl ToPyObject&gt;</code></li>
</ul>
<h4 id="emulating-sequential-containers-such-as-lists-or-tuples"><a class="header" href="#emulating-sequential-containers-such-as-lists-or-tuples">Emulating sequential containers (such as lists or tuples)</a></h4>
<p>The <a href="https://pyo3.rs/main/doc/pyo3/class/sequence/trait.PySequenceProtocol.html"><code>PySequenceProtocol</code></a> trait can be implemented to emulate
<a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types">sequential container types</a>.</p>
<p>For a sequence, the keys are the integers <em>k</em> for which <em>0 &lt;= k &lt; N</em>,
where <em>N</em> is the length of the sequence.</p>
<ul>
<li>
<p><code>fn __len__(&amp;self) -&gt; PyResult&lt;usize&gt;</code></p>
<p>Implements the built-in function <code>len()</code> for the sequence.</p>
</li>
<li>
<p><code>fn __getitem__(&amp;self, idx: isize) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Implements evaluation of the <code>self[idx]</code> element.
If the <code>idx</code> value is outside the set of indexes for the sequence, <code>IndexError</code> should be raised.</p>
<p><em>Note:</em> Negative integer indexes are handled as follows: if <code>__len__()</code> is defined,
it is called and the sequence length is used to compute a positive index,
which is passed to <code>__getitem__()</code>.
If <code>__len__()</code> is not defined, the index is passed as is to the function.</p>
</li>
<li>
<p><code>fn __setitem__(&amp;mut self, idx: isize, value: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></p>
<p>Implements assignment to the <code>self[idx]</code> element. Same note as for <code>__getitem__()</code>.
Should only be implemented if sequence elements can be replaced.</p>
</li>
<li>
<p><code>fn __delitem__(&amp;mut self, idx: isize) -&gt; PyResult&lt;()&gt;</code></p>
<p>Implements deletion of the <code>self[idx]</code> element. Same note as for <code>__getitem__()</code>.
Should only be implemented if sequence elements can be deleted.</p>
</li>
<li>
<p><code>fn __contains__(&amp;self, item: impl FromPyObject) -&gt; PyResult&lt;bool&gt;</code></p>
<p>Implements membership test operators.
Should return true if <code>item</code> is in <code>self</code>, false otherwise.
For objects that don’t define <code>__contains__()</code>, the membership test simply
traverses the sequence until it finds a match.</p>
</li>
<li>
<p><code>fn __concat__(&amp;self, other: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Concatenates two sequences.
Used by the <code>+</code> operator, after trying the numeric addition via
the <code>PyNumberProtocol</code> trait method.</p>
</li>
<li>
<p><code>fn __repeat__(&amp;self, count: isize) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Repeats the sequence <code>count</code> times.
Used by the <code>*</code> operator, after trying the numeric multiplication via
the <code>PyNumberProtocol</code> trait method.</p>
</li>
<li>
<p><code>fn __inplace_concat__(&amp;mut self, other: impl FromPyObject) -&gt; PyResult&lt;Self&gt;</code></p>
<p>Concatenates two sequences in place. Returns the modified first operand.
Used by the <code>+=</code> operator, after trying the numeric in place addition via
the <code>PyNumberProtocol</code> trait method.</p>
</li>
<li>
<p><code>fn __inplace_repeat__(&amp;mut self, count: isize) -&gt; PyResult&lt;Self&gt;</code></p>
<p>Repeats the sequence <code>count</code> times in place. Returns the modified first operand.
Used by the <code>*=</code> operator, after trying the numeric in place multiplication via
the <code>PyNumberProtocol</code> trait method.</p>
</li>
</ul>
<h4 id="emulating-mapping-containers-such-as-dictionaries"><a class="header" href="#emulating-mapping-containers-such-as-dictionaries">Emulating mapping containers (such as dictionaries)</a></h4>
<p>The <a href="https://pyo3.rs/main/doc/pyo3/class/mapping/trait.PyMappingProtocol.html"><code>PyMappingProtocol</code></a> trait allows to emulate
<a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types">mapping container types</a>.</p>
<p>For a mapping, the keys may be Python objects of arbitrary type.</p>
<ul>
<li>
<p><code>fn __len__(&amp;self) -&gt; PyResult&lt;usize&gt;</code></p>
<p>Implements the built-in function <code>len()</code> for the mapping.</p>
</li>
<li>
<p><code>fn __getitem__(&amp;self, key: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Implements evaluation of the <code>self[key]</code> element.
If <code>key</code> is of an inappropriate type, <code>TypeError</code> may be raised;
if <code>key</code> is missing (not in the container), <code>KeyError</code> should be raised.</p>
</li>
<li>
<p><code>fn __setitem__(&amp;mut self, key: impl FromPyObject, value: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></p>
<p>Implements assignment to the <code>self[key]</code> element or insertion of a new <code>key</code>
mapping to <code>value</code>.
Should only be implemented if the mapping support changes to the values for keys,
or if new keys can be added.
The same exceptions should be raised for improper key values as
for the <code>__getitem__()</code> method.</p>
</li>
<li>
<p><code>fn __delitem__(&amp;mut self, key: impl FromPyObject) -&gt; PyResult&lt;()&gt;</code></p>
<p>Implements deletion of the <code>self[key]</code> element.
Should only be implemented if the mapping supports removal of keys.
The same exceptions should be raised for improper key values as
for the <code>__getitem__()</code> method.</p>
</li>
</ul>
<h4 id="iterator-types"><a class="header" href="#iterator-types">Iterator Types</a></h4>
<p>Iterators can be defined using the <a href="https://pyo3.rs/main/doc/pyo3/class/iter/trait.PyIterProtocol.html"><code>PyIterProtocol</code></a> trait.
It includes two methods <code>__iter__</code> and <code>__next__</code>:</p>
<ul>
<li><code>fn __iter__(slf: PyRefMut&lt;'_, Self&gt;) -&gt; PyResult&lt;impl IntoPy&lt;PyObject&gt;&gt;</code></li>
<li><code>fn __next__(slf: PyRefMut&lt;'_, Self&gt;) -&gt; PyResult&lt;Option&lt;impl IntoPy&lt;PyObject&gt;&gt;&gt;</code></li>
</ul>
<p>These two methods can be take either <code>PyRef&lt;'_, Self&gt;</code> or <code>PyRefMut&lt;'_, Self&gt;</code> as their
first argument, so that mutable borrow can be avoided if needed.</p>
<p>For details, look at the <code>#[pymethods]</code> regarding iterator methods.</p>
<h4 id="garbage-collector-integration-1"><a class="header" href="#garbage-collector-integration-1">Garbage Collector Integration</a></h4>
<p>Implement the <a href="https://pyo3.rs/main/doc/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait for your struct.
For details, look at the <code>#[pymethods]</code> regarding GC methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-object-customization-2"><a class="header" href="#basic-object-customization-2">Basic object customization</a></h1>
<p>Recall the <code>Number</code> class from the previous chapter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Self(value)
    }
}

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>At this point Python code can import the module, access the class and create class instances - but
nothing else.</p>
<pre><code class="language-python">from my_module import Number

n = Number(5)
print(n)
</code></pre>
<pre><code class="language-text">&lt;builtins.Number object at 0x000002B4D185D7D0&gt;
</code></pre>
<h3 id="string-representations"><a class="header" href="#string-representations">String representations</a></h3>
<p>It can't even print an user-readable representation of itself! We can fix that by defining the
<code>__repr__</code> and <code>__str__</code> methods inside a <code>#[pymethods]</code> block. We do this by accessing the value
contained inside <code>Number</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
   // For `__repr__` we want to return a string that Python code could use to recreate
   // the `Number`, like `Number(5)` for example.
   fn __repr__(&amp;self) -&gt; String {
       // We use the `format!` macro to create a string. Its first argument is a
       // format string, followed by any number of parameters which replace the
       // `{}`'s in the format string.
       //
       //                       👇 Tuple field access in Rust uses a dot
       format!(&quot;Number({})&quot;, self.0)
   }

   // `__str__` is generally used to create an &quot;informal&quot; representation, so we
   // just forward to `i32`'s `ToString` trait implementation to print a bare number.
   fn __str__(&amp;self) -&gt; String {
       self.0.to_string()
   }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="hashing"><a class="header" href="#hashing">Hashing</a></h3>
<p>Let's also implement hashing. We'll just hash the <code>i32</code>. For that we need a <a href="https://doc.rust-lang.org/std/hash/trait.Hasher.html"><code>Hasher</code></a>. The one
provided by <code>std</code> is <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html"><code>DefaultHasher</code></a>, which uses the <a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> algorithm.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::hash_map::DefaultHasher;

// Required to call the `.hash` and `.finish` methods, which are defined on traits.
use std::hash::{Hash, Hasher};

<span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __hash__(&amp;self) -&gt; u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&amp;mut hasher);
        hasher.finish()
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: When implementing <code>__hash__</code> and comparisons, it is important that the following property holds:</p>
<pre><code class="language-text">k1 == k2 -&gt; hash(k1) == hash(k2)
</code></pre>
<p>In other words, if two keys are equal, their hashes must also be equal. In addition you must take
care that your classes' hash doesn't change during its lifetime. In this tutorial we do that by not
letting Python code change our <code>Number</code> class. In other words, it is immutable.</p>
<p>By default, all <code>#[pyclass]</code> types have a default hash implementation from Python.
Types which should not be hashable can override this by setting <code>__hash__</code> to None.
This is the same mechanism as for a pure-Python class. This is done like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct NotHashable { }

#[pymethods]
impl NotHashable {
   #[classattr]
   const __hash__: Option&lt;Py&lt;PyAny&gt;&gt; = None;
}
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<h3 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h3>
<p>Unlike in Python, PyO3 does not provide the magic comparison methods you might expect like <code>__eq__</code>,
<code>__lt__</code> and so on. Instead you have to implement all six operations at once with <code>__richcmp__</code>.
This method will be called with a value of <code>CompareOp</code> depending on the operation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::class::basic::CompareOp;

<span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __richcmp__(&amp;self, other: &amp;Self, op: CompareOp) -&gt; PyResult&lt;bool&gt; {
        match op {
            CompareOp::Lt =&gt; Ok(self.0 &lt; other.0),
            CompareOp::Le =&gt; Ok(self.0 &lt;= other.0),
            CompareOp::Eq =&gt; Ok(self.0 == other.0),
            CompareOp::Ne =&gt; Ok(self.0 != other.0),
            CompareOp::Gt =&gt; Ok(self.0 &gt; other.0),
            CompareOp::Ge =&gt; Ok(self.0 &gt;= other.0),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="truthyness"><a class="header" href="#truthyness">Truthyness</a></h3>
<p>We'll consider <code>Number</code> to be <code>True</code> if it is nonzero:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __bool__(&amp;self) -&gt; bool {
        self.0 != 0
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="final-code"><a class="header" href="#final-code">Final code</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

use pyo3::prelude::*;
use pyo3::class::basic::CompareOp;

#[pyclass]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Self(value)
    }

    fn __repr__(&amp;self) -&gt; String {
        format!(&quot;Number({})&quot;, self.0)
    }

    fn __str__(&amp;self) -&gt; String {
        self.0.to_string()
    }

    fn __hash__(&amp;self) -&gt; u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&amp;mut hasher);
        hasher.finish()
    }

    fn __richcmp__(&amp;self, other: &amp;Self, op: CompareOp) -&gt; PyResult&lt;bool&gt; {
        match op {
            CompareOp::Lt =&gt; Ok(self.0 &lt; other.0),
            CompareOp::Le =&gt; Ok(self.0 &lt;= other.0),
            CompareOp::Eq =&gt; Ok(self.0 == other.0),
            CompareOp::Ne =&gt; Ok(self.0 != other.0),
            CompareOp::Gt =&gt; Ok(self.0 &gt; other.0),
            CompareOp::Ge =&gt; Ok(self.0 &gt;= other.0),
        }
    }

    fn __bool__(&amp;self) -&gt; bool {
        self.0 != 0
    }
}

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="emulating-numeric-types-1"><a class="header" href="#emulating-numeric-types-1">Emulating numeric types</a></h1>
<p>At this point we have a <code>Number</code> class that we can't actually do any math on!</p>
<p>Before proceeding, we should think about how we want to handle overflows. There are three obvious solutions:</p>
<ul>
<li>We can have infinite precision just like Python's <code>int</code>. However that would be quite boring - we'd
be reinventing the wheel.</li>
<li>We can raise exceptions whenever <code>Number</code> overflows, but that makes the API painful to use.</li>
<li>We can wrap around the boundary of <code>i32</code>. This is the approach we'll take here. To do that we'll just forward to <code>i32</code>'s
<code>wrapping_*</code> methods.</li>
</ul>
<h3 id="fixing-our-constructor"><a class="header" href="#fixing-our-constructor">Fixing our constructor</a></h3>
<p>Let's address the first overflow, in <code>Number</code>'s constructor:</p>
<pre><code class="language-python">from my_module import Number

n = Number(1 &lt;&lt; 1337)
</code></pre>
<pre><code class="language-text">Traceback (most recent call last):
  File &quot;example.py&quot;, line 3, in &lt;module&gt;
    n = Number(1 &lt;&lt; 1337)
OverflowError: Python int too large to convert to C long
</code></pre>
<p>Instead of relying on the default <a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> extraction to parse arguments, we can specify our
own extraction function, using the <code>#[pyo3(from_py_with = &quot;...&quot;)]</code> attribute. Unfortunately PyO3
doesn't provide a way to wrap Python integers out of the box, but we can do a Python call to mask it
and cast it to an <code>i32</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

fn wrap(obj: &amp;PyAny) -&gt; Result&lt;i32, PyErr&gt; {
    let val = obj.call_method1(&quot;__and__&quot;, (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    //     👇 This intentionally overflows!
    Ok(val as i32)
}
<span class="boring">}
</span></code></pre></pre>
<p>We also add documentation, via <code>///</code> comments and the <code>#[pyo3(text_signature = &quot;...&quot;)]</code> attribute, both of which are visible to Python users.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

fn wrap(obj: &amp;PyAny) -&gt; Result&lt;i32, PyErr&gt; {
    let val = obj.call_method1(&quot;__and__&quot;, (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    Ok(val as i32)
}

/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.
/// It's not a story C would tell you. It's a Rust legend.
#[pyclass(module = &quot;my_module&quot;)]
#[pyo3(text_signature = &quot;(int)&quot;)]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(#[pyo3(from_py_with = &quot;wrap&quot;)] value: i32) -&gt; Self {
        Self(value)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>With that out of the way, let's implement some operators:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryInto;
use pyo3::exceptions::{PyZeroDivisionError, PyValueError};

<span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __add__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_add(other.0))
    }

    fn __sub__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_sub(other.0))
    }

    fn __mul__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_mul(other.0))
    }

    fn __truediv__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match self.0.checked_div(other.0) {
            Some(i) =&gt; Ok(Self(i)),
            None =&gt; Err(PyZeroDivisionError::new_err(&quot;division by zero&quot;)),
        }
    }

    fn __floordiv__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match self.0.checked_div(other.0) {
            Some(i) =&gt; Ok(Self(i)),
            None =&gt; Err(PyZeroDivisionError::new_err(&quot;division by zero&quot;)),
        }
    }

    fn __rshift__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match other.0.try_into() {
            Ok(rhs) =&gt; Ok(Self(self.0.wrapping_shr(rhs))),
            Err(_) =&gt; Err(PyValueError::new_err(&quot;negative shift count&quot;)),
        }
    }

    fn __lshift__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match other.0.try_into() {
            Ok(rhs) =&gt; Ok(Self(self.0.wrapping_shl(rhs))),
            Err(_) =&gt; Err(PyValueError::new_err(&quot;negative shift count&quot;)),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="unary-arithmetic-operations"><a class="header" href="#unary-arithmetic-operations">Unary arithmetic operations</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __pos__(slf: PyRef&lt;'_, Self&gt;) -&gt; PyRef&lt;'_, Self&gt; {
        slf
    }

    fn __neg__(&amp;self) -&gt; Self {
        Self(-self.0)
    }

    fn __abs__(&amp;self) -&gt; Self {
        Self(self.0.abs())
    }

    fn __invert__(&amp;self) -&gt; Self {
        Self(!self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="support-for-the-complex-int-and-float-built-in-functions"><a class="header" href="#support-for-the-complex-int-and-float-built-in-functions">Support for the <code>complex()</code>, <code>int()</code> and <code>float()</code> built-in functions.</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>use pyo3::types::PyComplex;

#[pymethods]
impl Number {
    fn __int__(&amp;self) -&gt; i32 {
        self.0
    }

    fn __float__(&amp;self) -&gt; f64 {
        self.0 as f64
    }

    fn __complex__&lt;'py&gt;(&amp;self, py: Python&lt;'py&gt;) -&gt; &amp;'py PyComplex {
        PyComplex::from_doubles(py, self.0 as f64, 0.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We do not implement the in-place operations like <code>__iadd__</code> because we do not wish to mutate <code>Number</code>.
Similarly we're not interested in supporting operations with different types, so we do not implement
the reflected operations like <code>__radd__</code> either.</p>
<p>Now Python can use our <code>Number</code> class:</p>
<pre><code class="language-python">from my_module import Number

def hash_djb2(s: str):
	'''
	A version of Daniel J. Bernstein's djb2 string hashing algorithm
	Like many hashing algorithms, it relies on integer wrapping.
	'''

	n = Number(0)
	five = Number(5)

	for x in s:
		n = Number(ord(x)) + ((n &lt;&lt; five) - n)
	return n

assert hash_djb2('l50_50') == Number(-1152549421)
</code></pre>
<h3 id="final-code-1"><a class="header" href="#final-code-1">Final code</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::convert::TryInto;

use pyo3::exceptions::{PyValueError, PyZeroDivisionError};
use pyo3::prelude::*;
use pyo3::class::basic::CompareOp;
use pyo3::types::PyComplex;

fn wrap(obj: &amp;PyAny) -&gt; Result&lt;i32, PyErr&gt; {
    let val = obj.call_method1(&quot;__and__&quot;, (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    Ok(val as i32)
}
/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.
/// It's not a story C would tell you. It's a Rust legend.
#[pyclass(module = &quot;my_module&quot;)]
#[pyo3(text_signature = &quot;(int)&quot;)]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(#[pyo3(from_py_with = &quot;wrap&quot;)] value: i32) -&gt; Self {
        Self(value)
    }

    fn __repr__(&amp;self) -&gt; String {
        format!(&quot;Number({})&quot;, self.0)
    }

    fn __str__(&amp;self) -&gt; String {
        self.0.to_string()
    }

    fn __hash__(&amp;self) -&gt; u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&amp;mut hasher);
        hasher.finish()
    }

    fn __richcmp__(&amp;self, other: &amp;Self, op: CompareOp) -&gt; PyResult&lt;bool&gt; {
        match op {
            CompareOp::Lt =&gt; Ok(self.0 &lt; other.0),
            CompareOp::Le =&gt; Ok(self.0 &lt;= other.0),
            CompareOp::Eq =&gt; Ok(self.0 == other.0),
            CompareOp::Ne =&gt; Ok(self.0 != other.0),
            CompareOp::Gt =&gt; Ok(self.0 &gt; other.0),
            CompareOp::Ge =&gt; Ok(self.0 &gt;= other.0),
        }
    }

    fn __bool__(&amp;self) -&gt; bool {
        self.0 != 0
    }

    fn __add__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_add(other.0))
    }

    fn __sub__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_sub(other.0))
    }

    fn __mul__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_mul(other.0))
    }

    fn __truediv__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match self.0.checked_div(other.0) {
            Some(i) =&gt; Ok(Self(i)),
            None =&gt; Err(PyZeroDivisionError::new_err(&quot;division by zero&quot;)),
        }
    }

    fn __floordiv__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match self.0.checked_div(other.0) {
            Some(i) =&gt; Ok(Self(i)),
            None =&gt; Err(PyZeroDivisionError::new_err(&quot;division by zero&quot;)),
        }
    }

    fn __rshift__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match other.0.try_into() {
            Ok(rhs) =&gt; Ok(Self(self.0.wrapping_shr(rhs))),
            Err(_) =&gt; Err(PyValueError::new_err(&quot;negative shift count&quot;)),
        }
    }

    fn __lshift__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match other.0.try_into() {
            Ok(rhs) =&gt; Ok(Self(self.0.wrapping_shl(rhs))),
            Err(_) =&gt; Err(PyValueError::new_err(&quot;negative shift count&quot;)),
        }
    }

    fn __xor__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0 ^ other.0)
    }

    fn __or__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0 | other.0)
    }

    fn __and__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0 &amp; other.0)
    }

    fn __int__(&amp;self) -&gt; i32 {
        self.0
    }

    fn __float__(&amp;self) -&gt; f64 {
        self.0 as f64
    }

    fn __complex__&lt;'py&gt;(&amp;self, py: Python&lt;'py&gt;) -&gt; &amp;'py PyComplex {
        PyComplex::from_doubles(py, self.0 as f64, 0.0)
    }
}

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}
<span class="boring">const SCRIPT: &amp;'static str = r#&quot;
</span><span class="boring">def hash_djb2(s: str):
</span><span class="boring">    n = Number(0)
</span><span class="boring">    five = Number(5)
</span><span class="boring">
</span><span class="boring">    for x in s:
</span><span class="boring">        n = Number(ord(x)) + ((n &lt;&lt; five) - n)
</span><span class="boring">    return n
</span><span class="boring">
</span><span class="boring">assert hash_djb2('l50_50') == Number(-1152549421)
</span><span class="boring">assert hash_djb2('logo') == Number(3327403)
</span><span class="boring">assert hash_djb2('horizon') == Number(1097468315)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">assert Number(2) + Number(2) == Number(4)
</span><span class="boring">assert Number(2) + Number(2) != Number(5)
</span><span class="boring">
</span><span class="boring">assert Number(13) - Number(7) == Number(6)
</span><span class="boring">assert Number(13) - Number(-7) == Number(20)
</span><span class="boring">
</span><span class="boring">assert Number(13) / Number(7) == Number(1)
</span><span class="boring">assert Number(13) // Number(7) == Number(1)
</span><span class="boring">
</span><span class="boring">assert Number(13) * Number(7) == Number(13*7)
</span><span class="boring">
</span><span class="boring">assert Number(13) &gt; Number(7)
</span><span class="boring">assert Number(13) &lt; Number(20)
</span><span class="boring">assert Number(13) == Number(13)
</span><span class="boring">assert Number(13) &gt;= Number(7)
</span><span class="boring">assert Number(13) &lt;= Number(20)
</span><span class="boring">assert Number(13) == Number(13)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">assert (True if Number(1) else False)
</span><span class="boring">assert (False if Number(0) else True)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">assert int(Number(13)) == 13
</span><span class="boring">assert float(Number(13)) == 13
</span><span class="boring">assert Number.__doc__ == &quot;Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.\nIt's not a story C would tell you. It's a Rust legend.&quot;
</span><span class="boring">assert Number(12345234523452) == Number(1498514748)
</span><span class="boring">try:
</span><span class="boring">    import inspect
</span><span class="boring">    assert inspect.signature(Number).__str__() == '(int)'
</span><span class="boring">except ValueError:
</span><span class="boring">    # Not supported with `abi3` before Python 3.10
</span><span class="boring">    pass
</span><span class="boring">assert Number(1337).__str__() == '1337'
</span><span class="boring">assert Number(1337).__repr__() == 'Number(1337)'
</span>&quot;#;

<span class="boring">
</span><span class="boring">use pyo3::PyTypeInfo;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let globals = PyModule::import(py, &quot;__main__&quot;)?.dict();
</span><span class="boring">        globals.set_item(&quot;Number&quot;, Number::type_object(py))?;
</span><span class="boring">
</span><span class="boring">        py.run(SCRIPT, Some(globals), None)?;
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span>
</code></pre></pre>
<h2 id="appendix-writing-some-unsafe-code"><a class="header" href="#appendix-writing-some-unsafe-code">Appendix: Writing some unsafe code</a></h2>
<p>At the beginning of this chapter we said that PyO3 doesn't provide a way to wrap Python integers out
of the box but that's a half truth. There's not a PyO3 API for it, but there's a Python C API
function that does:</p>
<pre><code class="language-c">unsigned long PyLong_AsUnsignedLongMask(PyObject *obj)
</code></pre>
<p>We can call this function from Rust by using <a href="https://docs.rs/pyo3/latest/pyo3/ffi/fn.PyLong_AsUnsignedLongMask.html"><code>pyo3::ffi::PyLong_AsUnsignedLongMask</code></a>. This is an <em>unsafe</em>
function, which means we have to use an unsafe block to call it and take responsibility for upholding
the contracts of this function. Let's review those contracts:</p>
<ul>
<li>The GIL must be held. If it's not, calling this function causes a data race.</li>
<li>The pointer must be valid, i.e. it must be properly aligned and point to a valid Python object.</li>
</ul>
<p>Let's create that helper function. The signature has to be <code>fn(&amp;PyAny) -&gt; PyResult&lt;T&gt;</code>.</p>
<ul>
<li><code>&amp;PyAny</code> represents a checked borrowed reference, so the pointer derived from it is valid (and not null).</li>
<li>Whenever we have borrowed references to Python objects in scope, it is guaranteed that the GIL is held. This reference is also where we can get a <a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html"><code>Python</code></a> token to use in our call to <a href="https://docs.rs/pyo3/latest/pyo3/prelude/struct.PyErr.html#method.take"><code>PyErr::take</code></a>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>use std::os::raw::c_ulong;
use pyo3::prelude::*;
use pyo3::ffi;
use pyo3::conversion::AsPyPointer;

fn wrap(obj: &amp;PyAny) -&gt; Result&lt;i32, PyErr&gt; {
    let py: Python&lt;'_&gt; = obj.py();

    unsafe {
        let ptr = obj.as_ptr();

        let ret: c_ulong = ffi::PyLong_AsUnsignedLongMask(ptr);
        if ret == c_ulong::MAX {
            if let Some(err) = PyErr::take(py) {
                return Err(err);
            }
        }

        Ok(ret as i32)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="emulating-callable-objects"><a class="header" href="#emulating-callable-objects">Emulating callable objects</a></h1>
<p>Classes can be callable if they have a <code>#[pymethod]</code> named <code>__call__</code>.
This allows instances of a class to behave similar to functions.</p>
<p>This method's signature must look like <code>__call__(&lt;self&gt;, ...) -&gt; object</code> - here,
any argument list can be defined as for normal pymethods</p>
<h3 id="example-implementing-a-call-counter"><a class="header" href="#example-implementing-a-call-counter">Example: Implementing a call counter</a></h3>
<p>The following pyclass is a basic decorator - its constructor takes a Python object
as argument and calls that object when called. An equivalent Python implementation
is linked at the end.</p>
<p>An example crate containing this pyclass can be found <a href="https://github.com/PyO3/pyo3/tree/main/examples/decorator">here</a></p>
<pre><code class="language-rust ignore">use pyo3::prelude::*;
use pyo3::types::{PyDict, PyTuple};

/// A function decorator that keeps track how often it is called.
///
/// It otherwise doesn't do anything special.
#[pyclass(name = &quot;Counter&quot;)]
pub struct PyCounter {
    // We use `#[pyo3(get)]` so that python can read the count but not mutate it.
    #[pyo3(get)]
    count: u64,

    // This is the actual function being wrapped.
    wraps: Py&lt;PyAny&gt;,
}

#[pymethods]
impl PyCounter {
    // Note that we don't validate whether `wraps` is actually callable.
    //
    // While we could use `PyAny::is_callable` for that, it has some flaws:
    //    1. It doesn't guarantee the object can actually be called successfully
    //    2. We still need to handle any exceptions that the function might raise
    #[new]
    fn __new__(wraps: Py&lt;PyAny&gt;) -&gt; Self {
        PyCounter { count: 0, wraps }
    }

    #[args(args = &quot;*&quot;, kwargs = &quot;**&quot;)]
    fn __call__(
        &amp;mut self,
        py: Python&lt;'_&gt;,
        args: &amp;PyTuple,
        kwargs: Option&lt;&amp;PyDict&gt;,
    ) -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
        self.count += 1;
        let name = self.wraps.getattr(py, &quot;__name__&quot;)?;

        println!(&quot;{} has been called {} time(s).&quot;, name, self.count);

        // After doing something, we finally forward the call to the wrapped function
        let ret = self.wraps.call(py, args, kwargs)?;

        // We could do something with the return value of
        // the function before returning it
        Ok(ret)
    }
}

#[pymodule]
pub fn decorator(_py: Python&lt;'_&gt;, module: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    module.add_class::&lt;PyCounter&gt;()?;
    Ok(())
}
</code></pre>
<p>Python code:</p>
<pre><code class="language-python">@Counter
def say_hello():
    print(&quot;hello&quot;)


say_hello()
say_hello()
say_hello()
say_hello()

assert say_hello.count == 4
</code></pre>
<p>Output:</p>
<pre><code class="language-text">say_hello has been called 1 time(s).
hello
say_hello has been called 2 time(s).
hello
say_hello has been called 3 time(s).
hello
say_hello has been called 4 time(s).
hello
</code></pre>
<h4 id="pure-python-implementation"><a class="header" href="#pure-python-implementation">Pure Python implementation</a></h4>
<p>A Python implementation of this looks similar to the Rust version:</p>
<pre><code class="language-python">class Counter:
    def __init__(self, wraps):
        self.count = 0
        self.wraps = wraps

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f&quot;{self.wraps.__name__} has been called {self.count} time(s)&quot;)
        self.wraps(*args, **kwargs)
</code></pre>
<p>Note that it can also be implemented as a higher order function:</p>
<pre><code class="language-python">def Counter(wraps):
    count = 0
    def call(*args, **kwargs):
        nonlocal count
        count += 1
        print(f&quot;{wraps.__name__} has been called {count} time(s)&quot;)
        return wraps(*args, **kwargs)
    return call
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h1>
<p>In this portion of the guide we'll talk about the mapping of Python types to Rust types offered by PyO3, as well as the traits available to perform conversions between them.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mapping-of-rust-types-to-python-types"><a class="header" href="#mapping-of-rust-types-to-python-types">Mapping of Rust types to Python types</a></h2>
<p>When writing functions callable from Python (such as a <code>#[pyfunction]</code> or in a <code>#[pymethods]</code> block), the trait <code>FromPyObject</code> is required for function arguments, and <code>IntoPy&lt;PyObject&gt;</code> is required for function return values.</p>
<p>Consult the tables in the following section to find the Rust types provided by PyO3 which implement these traits.</p>
<h3 id="argument-types"><a class="header" href="#argument-types">Argument Types</a></h3>
<p>When accepting a function argument, it is possible to either use Rust library types or PyO3's Python-native types. (See the next section for discussion on when to use each.)</p>
<p>The table below contains the Python type and the corresponding function argument types that will accept them:</p>
<table><thead><tr><th>Python</th><th align="center">Rust</th><th align="center">Rust (Python-native)</th></tr></thead><tbody>
<tr><td><code>object</code></td><td align="center">-</td><td align="center"><code>&amp;PyAny</code></td></tr>
<tr><td><code>str</code></td><td align="center"><code>String</code>, <code>Cow&lt;str&gt;</code>, <code>&amp;str</code>, <code>OsString</code>, <code>PathBuf</code></td><td align="center"><code>&amp;PyUnicode</code></td></tr>
<tr><td><code>bytes</code></td><td align="center"><code>Vec&lt;u8&gt;</code>, <code>&amp;[u8]</code></td><td align="center"><code>&amp;PyBytes</code></td></tr>
<tr><td><code>bool</code></td><td align="center"><code>bool</code></td><td align="center"><code>&amp;PyBool</code></td></tr>
<tr><td><code>int</code></td><td align="center">Any integer type (<code>i32</code>, <code>u32</code>, <code>usize</code>, etc)</td><td align="center"><code>&amp;PyLong</code></td></tr>
<tr><td><code>float</code></td><td align="center"><code>f32</code>, <code>f64</code></td><td align="center"><code>&amp;PyFloat</code></td></tr>
<tr><td><code>complex</code></td><td align="center"><code>num_complex::Complex</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td align="center"><code>&amp;PyComplex</code></td></tr>
<tr><td><code>list[T]</code></td><td align="center"><code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PyList</code></td></tr>
<tr><td><code>dict[K, V]</code></td><td align="center"><code>HashMap&lt;K, V&gt;</code>, <code>BTreeMap&lt;K, V&gt;</code>, <code>hashbrown::HashMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#2">2</a></sup>, <code>indexmap::IndexMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#3">3</a></sup></td><td align="center"><code>&amp;PyDict</code></td></tr>
<tr><td><code>tuple[T, U]</code></td><td align="center"><code>(T, U)</code>, <code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PyTuple</code></td></tr>
<tr><td><code>set[T]</code></td><td align="center"><code>HashSet&lt;T&gt;</code>, <code>BTreeSet&lt;T&gt;</code>, <code>hashbrown::HashSet&lt;T&gt;</code><sup class="footnote-reference"><a href="#2">2</a></sup></td><td align="center"><code>&amp;PySet</code></td></tr>
<tr><td><code>frozenset[T]</code></td><td align="center"><code>HashSet&lt;T&gt;</code>, <code>BTreeSet&lt;T&gt;</code>, <code>hashbrown::HashSet&lt;T&gt;</code><sup class="footnote-reference"><a href="#2">2</a></sup></td><td align="center"><code>&amp;PyFrozenSet</code></td></tr>
<tr><td><code>bytearray</code></td><td align="center"><code>Vec&lt;u8&gt;</code></td><td align="center"><code>&amp;PyByteArray</code></td></tr>
<tr><td><code>slice</code></td><td align="center">-</td><td align="center"><code>&amp;PySlice</code></td></tr>
<tr><td><code>type</code></td><td align="center">-</td><td align="center"><code>&amp;PyType</code></td></tr>
<tr><td><code>module</code></td><td align="center">-</td><td align="center"><code>&amp;PyModule</code></td></tr>
<tr><td><code>datetime.datetime</code></td><td align="center">-</td><td align="center"><code>&amp;PyDateTime</code></td></tr>
<tr><td><code>datetime.date</code></td><td align="center">-</td><td align="center"><code>&amp;PyDate</code></td></tr>
<tr><td><code>datetime.time</code></td><td align="center">-</td><td align="center"><code>&amp;PyTime</code></td></tr>
<tr><td><code>datetime.tzinfo</code></td><td align="center">-</td><td align="center"><code>&amp;PyTzInfo</code></td></tr>
<tr><td><code>datetime.timedelta</code></td><td align="center">-</td><td align="center"><code>&amp;PyDelta</code></td></tr>
<tr><td><code>typing.Optional[T]</code></td><td align="center"><code>Option&lt;T&gt;</code></td><td align="center">-</td></tr>
<tr><td><code>typing.Sequence[T]</code></td><td align="center"><code>Vec&lt;T&gt;</code></td><td align="center"><code>&amp;PySequence</code></td></tr>
<tr><td><code>typing.Mapping[K, V]</code></td><td align="center"><code>HashMap&lt;K, V&gt;</code>, <code>BTreeMap&lt;K, V&gt;</code>, <code>hashbrown::HashMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#2">2</a></sup>, <code>indexmap::IndexMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#3">3</a></sup></td><td align="center"><code>&amp;PyMapping</code></td></tr>
<tr><td><code>typing.Iterator[Any]</code></td><td align="center">-</td><td align="center"><code>&amp;PyIterator</code></td></tr>
<tr><td><code>typing.Union[...]</code></td><td align="center">See <a href="conversions/traits.html#deriving-a-hrefhttpsdocsrspyo3latestpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-enums"><code>#[derive(FromPyObject)]</code></a></td><td align="center">-</td></tr>
</tbody></table>
<p>There are also a few special types related to the GIL and Rust-defined <code>#[pyclass]</code>es which may come in useful:</p>
<table><thead><tr><th>What</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Python</code></td><td>A GIL token, used to pass to PyO3 constructors to prove ownership of the GIL</td></tr>
<tr><td><code>Py&lt;T&gt;</code></td><td>A Python object isolated from the GIL lifetime. This can be sent to other threads.</td></tr>
<tr><td><code>PyObject</code></td><td>An alias for <code>Py&lt;PyAny&gt;</code></td></tr>
<tr><td><code>&amp;PyCell&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> value owned by Python.</td></tr>
<tr><td><code>PyRef&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> borrowed immutably.</td></tr>
<tr><td><code>PyRefMut&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> borrowed mutably.</td></tr>
</tbody></table>
<p>For more detail on accepting <code>#[pyclass]</code> values as function arguments, see <a href="conversions/../class.html">the section of this guide on Python Classes</a>.</p>
<h4 id="using-rust-library-types-vs-python-native-types"><a class="header" href="#using-rust-library-types-vs-python-native-types">Using Rust library types vs Python-native types</a></h4>
<p>Using Rust library types as function arguments will incur a conversion cost compared to using the Python-native types. Using the Python-native types is almost zero-cost (they just require a type check similar to the Python builtin function <code>isinstance()</code>).</p>
<p>However, once that conversion cost has been paid, the Rust standard library types offer a number of benefits:</p>
<ul>
<li>You can write functionality in native-speed Rust code (free of Python's runtime costs).</li>
<li>You get better interoperability with the rest of the Rust ecosystem.</li>
<li>You can use <code>Python::allow_threads</code> to release the Python GIL and let other Python threads make progress while your Rust code is executing.</li>
<li>You also benefit from stricter type checking. For example you can specify <code>Vec&lt;i32&gt;</code>, which will only accept a Python <code>list</code> containing integers. The Python-native equivalent, <code>&amp;PyList</code>, would accept a Python <code>list</code> containing Python objects of any type.</li>
</ul>
<p>For most PyO3 usage the conversion cost is worth paying to get these benefits. As always, if you're not sure it's worth it in your case, benchmark it!</p>
<h3 id="returning-rust-values-to-python"><a class="header" href="#returning-rust-values-to-python">Returning Rust values to Python</a></h3>
<p>When returning values from functions callable from Python, Python-native types (<code>&amp;PyAny</code>, <code>&amp;PyDict</code> etc.) can be used with zero cost.</p>
<p>Because these types are references, in some situations the Rust compiler may ask for lifetime annotations. If this is the case, you should use <code>Py&lt;PyAny&gt;</code>, <code>Py&lt;PyDict&gt;</code> etc. instead - which are also zero-cost. For all of these Python-native types <code>T</code>, <code>Py&lt;T&gt;</code> can be created from <code>T</code> with an <code>.into()</code> conversion.</p>
<p>If your function is fallible, it should return <code>PyResult&lt;T&gt;</code> or <code>Result&lt;T, E&gt;</code> where <code>E</code> implements <code>From&lt;E&gt; for PyErr</code>. This will raise a <code>Python</code> exception if the <code>Err</code> variant is returned.</p>
<p>Finally, the following Rust types are also able to convert to Python as return values:</p>
<table><thead><tr><th>Rust type</th><th align="center">Resulting Python Type</th></tr></thead><tbody>
<tr><td><code>String</code></td><td align="center"><code>str</code></td></tr>
<tr><td><code>&amp;str</code></td><td align="center"><code>str</code></td></tr>
<tr><td><code>bool</code></td><td align="center"><code>bool</code></td></tr>
<tr><td>Any integer type (<code>i32</code>, <code>u32</code>, <code>usize</code>, etc)</td><td align="center"><code>int</code></td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td align="center"><code>float</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td align="center"><code>Optional[T]</code></td></tr>
<tr><td><code>(T, U)</code></td><td align="center"><code>Tuple[T, U]</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td align="center"><code>List[T]</code></td></tr>
<tr><td><code>HashMap&lt;K, V&gt;</code></td><td align="center"><code>Dict[K, V]</code></td></tr>
<tr><td><code>BTreeMap&lt;K, V&gt;</code></td><td align="center"><code>Dict[K, V]</code></td></tr>
<tr><td><code>HashSet&lt;T&gt;</code></td><td align="center"><code>Set[T]</code></td></tr>
<tr><td><code>BTreeSet&lt;T&gt;</code></td><td align="center"><code>Set[T]</code></td></tr>
<tr><td><code>&amp;PyCell&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
<tr><td><code>PyRef&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
<tr><td><code>PyRefMut&lt;T: PyClass&gt;</code></td><td align="center"><code>T</code></td></tr>
</tbody></table>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Requires the <code>num-complex</code> optional feature.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Requires the <code>hashbrown</code> optional feature.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Requires the <code>indexmap</code> optional feature.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conversion-traits"><a class="header" href="#conversion-traits">Conversion traits</a></h2>
<p>PyO3 provides some handy traits to convert between Python types and Rust types.</p>
<h3 id="extract-and-the-frompyobject-trait"><a class="header" href="#extract-and-the-frompyobject-trait"><code>.extract()</code> and the <code>FromPyObject</code> trait</a></h3>
<p>The easiest way to convert a Python object to a Rust value is using
<code>.extract()</code>.  It returns a <code>PyResult</code> with a type error if the conversion
fails, so usually you will use something like</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let list = PyList::new(py, b&quot;foo&quot;);
</span>let v: Vec&lt;i32&gt; = list.extract()?;
<span class="boring">        assert_eq!(&amp;v, &amp;[102, 111, 111]);
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>This method is available for many Python object types, and can produce a wide
variety of Rust types, which you can check out in the implementor list of
<a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a>.</p>
<p><a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> is also implemented for your own Rust types wrapped as Python
objects (see <a href="conversions/../class.html">the chapter about classes</a>).  There, in order to both be
able to operate on mutable references <em>and</em> satisfy Rust's rules of non-aliasing
mutable references, you have to extract the PyO3 reference wrappers <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a>
and <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a>.  They work like the reference wrappers of
<code>std::cell::RefCell</code> and ensure (at runtime) that Rust borrows are allowed.</p>
<h4 id="deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta"><a class="header" href="#deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta">Deriving <a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a></a></h4>
<p><a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> can be automatically derived for many kinds of structs and enums
if the member types themselves implement <code>FromPyObject</code>. This even includes members
with a generic type <code>T: FromPyObject</code>. Derivation for empty enums, enum variants and
structs is not supported.</p>
<h4 id="deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-structs"><a class="header" href="#deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-structs">Deriving <a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for structs</a></h4>
<p>The derivation generates code that will attempt to access the attribute  <code>my_string</code> on
the Python object, i.e. <code>obj.getattr(&quot;my_string&quot;)</code>, and call <code>extract()</code> on the attribute.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    my_string: String,
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let module = PyModule::from_code(
</span><span class="boring">            py,
</span><span class="boring">            &quot;class Foo:
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.my_string = 'test'&quot;,
</span><span class="boring">            &quot;&quot;,
</span><span class="boring">            &quot;&quot;,
</span><span class="boring">        )?;
</span><span class="boring">
</span><span class="boring">        let class = module.getattr(&quot;Foo&quot;)?;
</span><span class="boring">        let instance = class.call0()?;
</span><span class="boring">        let rustystruct: RustyStruct = instance.extract()?;
</span><span class="boring">        assert_eq!(rustystruct.my_string, &quot;test&quot;);
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>By setting the <code>#[pyo3(item)]</code> attribute on the field, PyO3 will attempt to extract the value by calling the <code>get_item</code> method on the Python object.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;


#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item)]
    my_string: String,
}
<span class="boring">
</span><span class="boring">use pyo3::types::PyDict;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let dict = PyDict::new(py);
</span><span class="boring">        dict.set_item(&quot;my_string&quot;, &quot;test&quot;)?;
</span><span class="boring">
</span><span class="boring">        let rustystruct: RustyStruct = dict.extract()?;
</span><span class="boring">        assert_eq!(rustystruct.my_string, &quot;test&quot;);
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>The argument passed to <code>getattr</code> and <code>get_item</code> can also be configured:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item(&quot;key&quot;))]
    string_in_mapping: String,
    #[pyo3(attribute(&quot;name&quot;))]
    string_attr: String,
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let module = PyModule::from_code(
</span><span class="boring">            py,
</span><span class="boring">            &quot;class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.name = 'test'
</span><span class="boring">                self['key'] = 'test2'&quot;,
</span><span class="boring">            &quot;&quot;,
</span><span class="boring">            &quot;&quot;,
</span><span class="boring">        )?;
</span><span class="boring">
</span><span class="boring">        let class = module.getattr(&quot;Foo&quot;)?;
</span><span class="boring">        let instance = class.call0()?;
</span><span class="boring">        let rustystruct: RustyStruct = instance.extract()?;
</span><span class="boring">		assert_eq!(rustystruct.string_attr, &quot;test&quot;);
</span><span class="boring">        assert_eq!(rustystruct.string_in_mapping, &quot;test2&quot;);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>This tries to extract <code>string_attr</code> from the attribute <code>name</code> and <code>string_in_mapping</code>
from a mapping with the key <code>&quot;key&quot;</code>. The arguments for <code>attribute</code> are restricted to
non-empty string literals while <code>item</code> can take any valid literal that implements
<code>ToBorrowedObject</code>.</p>
<h4 id="deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-tuple-structs"><a class="header" href="#deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-tuple-structs">Deriving <a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for tuple structs</a></h4>
<p>Tuple structs are also supported but do not allow customizing the extraction. The input is
always assumed to be a Python tuple with the same length as the Rust type, the <code>n</code>th field
is extracted from the <code>n</code>th item in the Python tuple.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTuple(String, String);

<span class="boring">use pyo3::types::PyTuple;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let tuple = PyTuple::new(py, vec![&quot;test&quot;, &quot;test2&quot;]);
</span><span class="boring">
</span><span class="boring">        let rustytuple: RustyTuple = tuple.extract()?;
</span><span class="boring">        assert_eq!(rustytuple.0, &quot;test&quot;);
</span><span class="boring">        assert_eq!(rustytuple.1, &quot;test2&quot;);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>Tuple structs with a single field are treated as wrapper types which are described in the
following section. To override this behaviour and ensure that the input is in fact a tuple,
specify the struct as</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTuple((String,));

<span class="boring">use pyo3::types::PyTuple;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let tuple = PyTuple::new(py, vec![&quot;test&quot;]);
</span><span class="boring">
</span><span class="boring">        let rustytuple: RustyTuple = tuple.extract()?;
</span><span class="boring">        assert_eq!((rustytuple.0).0, &quot;test&quot;);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<h4 id="deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-wrapper-types"><a class="header" href="#deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-wrapper-types">Deriving <a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for wrapper types</a></h4>
<p>The <code>pyo3(transparent)</code> attribute can be used on structs with exactly one field. This results
in extracting directly from the input object, i.e. <code>obj.extract()</code>, rather than trying to access
an item or attribute. This behaviour is enabled per default for newtype structs and tuple-variants
with a single field.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTransparentTupleStruct(String);

#[derive(FromPyObject)]
#[pyo3(transparent)]
struct RustyTransparentStruct {
    inner: String,
}

<span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let s = PyString::new(py, &quot;test&quot;);
</span><span class="boring">
</span><span class="boring">        let tup: RustyTransparentTupleStruct = s.extract()?;
</span><span class="boring">        assert_eq!(tup.0, &quot;test&quot;);
</span><span class="boring">
</span><span class="boring">        let stru: RustyTransparentStruct = s.extract()?;
</span><span class="boring">        assert_eq!(stru.inner, &quot;test&quot;);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<h4 id="deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-enums"><a class="header" href="#deriving-a-hrefhttpspyo3rsmaindocpyo3conversiontraitfrompyobjecthtmlfrompyobjecta-for-enums">Deriving <a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for enums</a></h4>
<p>The <code>FromPyObject</code> derivation for enums generates code that tries to extract the variants in the
order of the fields. As soon as a variant can be extracted successfully, that variant is returned.
This makes it possible to extract Python union types like <code>str | int</code>.</p>
<p>The same customizations and restrictions described for struct derivations apply to enum variants,
i.e. a tuple variant assumes that the input is a Python tuple, and a struct variant defaults to
extracting fields as attributes but can be configured in the same manner. The <code>transparent</code>
attribute can be applied to single-field-variants.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
<span class="boring">#[derive(Debug)]
</span>enum RustyEnum&lt;'a&gt; {
    Int(usize), // input is a positive int
    String(String), // input is a string
    IntTuple(usize, usize), // input is a 2-tuple with positive ints
    StringIntTuple(String, usize), // input is a 2-tuple with String and int
    Coordinates3d { // needs to be in front of 2d
        x: usize,
        y: usize,
        z: usize,
    },
    Coordinates2d { // only gets checked if the input did not have `z`
        #[pyo3(attribute(&quot;x&quot;))]
        a: usize,
        #[pyo3(attribute(&quot;y&quot;))]
        b: usize,
    },
    #[pyo3(transparent)]
    CatchAll(&amp;'a PyAny), // This extraction never fails
}
<span class="boring">
</span><span class="boring">use pyo3::types::{PyBytes, PyString};
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        {
</span><span class="boring">            let thing = 42_u8.to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                42,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Int(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = PyString::new(py, &quot;text&quot;);
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                &quot;text&quot;,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::String(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = (32_u8, 73_u8).to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (32, 73),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::IntTuple(i, j) =&gt; (i, j),
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = (&quot;foo&quot;, 73_u8).to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (String::from(&quot;foo&quot;), 73),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::StringIntTuple(i, j) =&gt; (i, j),
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let module = PyModule::from_code(
</span><span class="boring">                py,
</span><span class="boring">                &quot;class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.x = 0
</span><span class="boring">                self.y = 1
</span><span class="boring">                self.z = 2&quot;,
</span><span class="boring">                &quot;&quot;,
</span><span class="boring">                &quot;&quot;,
</span><span class="boring">            )?;
</span><span class="boring">
</span><span class="boring">            let class = module.getattr(&quot;Foo&quot;)?;
</span><span class="boring">            let instance = class.call0()?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = instance.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (0, 1, 2),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Coordinates3d { x, y, z } =&gt; (x, y, z),
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let module = PyModule::from_code(
</span><span class="boring">                py,
</span><span class="boring">                &quot;class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.x = 3
</span><span class="boring">                self.y = 4&quot;,
</span><span class="boring">                &quot;&quot;,
</span><span class="boring">                &quot;&quot;,
</span><span class="boring">            )?;
</span><span class="boring">
</span><span class="boring">            let class = module.getattr(&quot;Foo&quot;)?;
</span><span class="boring">            let instance = class.call0()?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = instance.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (3, 4),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Coordinates2d { a, b } =&gt; (a, b),
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = PyBytes::new(py, b&quot;text&quot;);
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                b&quot;text&quot;,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::CatchAll(i) =&gt; i.downcast::&lt;PyBytes&gt;()?.as_bytes(),
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>If none of the enum variants match, a <code>PyTypeError</code> containing the names of the
tested variants is returned. The names reported in the error message can be customized
through the <code>#[pyo3(annotation = &quot;name&quot;)]</code> attribute, e.g. to use conventional Python type
names:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
<span class="boring">#[derive(Debug)]
</span>enum RustyEnum {
    #[pyo3(transparent, annotation = &quot;str&quot;)]
    String(String),
    #[pyo3(transparent, annotation = &quot;int&quot;)]
    Int(isize),
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        {
</span><span class="boring">            let thing = 42_u8.to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                42,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Int(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = &quot;foo&quot;.to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                &quot;foo&quot;,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::String(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!(&quot;Error extracting: {:?}&quot;, other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = b&quot;foo&quot;.to_object(py);
</span><span class="boring">            let error = thing.extract::&lt;RustyEnum&gt;(py).unwrap_err();
</span><span class="boring">            assert!(error.is_instance_of::&lt;pyo3::exceptions::PyTypeError&gt;(py));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>If the input is neither a string nor an integer, the error message will be:
<code>&quot;'&lt;INPUT_TYPE&gt;' cannot be converted to 'str | int'&quot;</code>.</p>
<h4 id="derivefrompyobject-container-attributes"><a class="header" href="#derivefrompyobject-container-attributes"><code>#[derive(FromPyObject)]</code> Container Attributes</a></h4>
<ul>
<li><code>pyo3(transparent)</code>
<ul>
<li>extract the field directly from the object as <code>obj.extract()</code> instead of <code>get_item()</code> or
<code>getattr()</code></li>
<li>Newtype structs and tuple-variants are treated as transparent per default.</li>
<li>only supported for single-field structs and enum variants</li>
</ul>
</li>
<li><code>pyo3(annotation = &quot;name&quot;)</code>
<ul>
<li>changes the name of the failed variant in the generated error message in case of failure.</li>
<li>e.g. <code>pyo3(&quot;int&quot;)</code> reports the variant's type as <code>int</code>.</li>
<li>only supported for enum variants</li>
</ul>
</li>
</ul>
<h4 id="derivefrompyobject-field-attributes"><a class="header" href="#derivefrompyobject-field-attributes"><code>#[derive(FromPyObject)]</code> Field Attributes</a></h4>
<ul>
<li><code>pyo3(attribute)</code>, <code>pyo3(attribute(&quot;name&quot;))</code>
<ul>
<li>retrieve the field from an attribute, possibly with a custom name specified as an argument</li>
<li>argument must be a string-literal.</li>
</ul>
</li>
<li><code>pyo3(item)</code>, <code>pyo3(item(&quot;key&quot;))</code>
<ul>
<li>retrieve the field from a mapping, possibly with the custom key specified as an argument.</li>
<li>can be any literal that implements <code>ToBorrowedObject</code></li>
</ul>
</li>
<li><code>pyo3(from_py_with = &quot;...&quot;)</code>
<ul>
<li>apply a custom function to convert the field from Python the desired Rust type. </li>
<li>the argument must be the name of the function as a string.</li>
<li>the function signature must be <code>fn(&amp;PyAny) -&gt; PyResult&lt;T&gt;</code> where <code>T</code> is the Rust type of the argument.</li>
</ul>
</li>
</ul>
<h3 id="intopyt"><a class="header" href="#intopyt"><code>IntoPy&lt;T&gt;</code></a></h3>
<p>This trait defines the to-python conversion for a Rust type. It is usually implemented as
<code>IntoPy&lt;PyObject&gt;</code>, which is the trait needed for returning a value from <code>#[pyfunction]</code> and
<code>#[pymethods]</code>.</p>
<p>All types in PyO3 implement this trait, as does a <code>#[pyclass]</code> which doesn't use <code>extends</code>.</p>
<p>Occasionally you may choose to implement this for custom types which are mapped to Python types
<em>without</em> having a unique python type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

struct MyPyObjectWrapper(PyObject);

impl IntoPy&lt;PyObject&gt; for MyPyObjectWrapper {
    fn into_py(self, py: Python&lt;'_&gt;) -&gt; PyObject {
        self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="the-topyobject-trait"><a class="header" href="#the-topyobject-trait">The <code>ToPyObject</code> trait</a></h3>
<p><a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.ToPyObject.html"><code>ToPyObject</code></a> is a conversion trait that allows various objects to be
converted into <a href="https://pyo3.rs/main/doc/pyo3/type.PyObject.html"><code>PyObject</code></a>. <code>IntoPy&lt;PyObject&gt;</code> serves the
same purpose, except that it consumes <code>self</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-exceptions"><a class="header" href="#python-exceptions">Python Exceptions</a></h1>
<h2 id="defining-a-new-exception"><a class="header" href="#defining-a-new-exception">Defining a new exception</a></h2>
<p>You can use the <a href="https://pyo3.rs/main/doc/pyo3/macro.create_exception.html"><code>create_exception!</code></a> macro to define a new exception type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::create_exception;

create_exception!(module, MyError, pyo3::exceptions::PyException);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>module</code> is the name of the containing module.</li>
<li><code>MyError</code> is the name of the new exception type.</li>
</ul>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::create_exception;
use pyo3::types::IntoPyDict;
use pyo3::exceptions::PyException;

create_exception!(mymodule, CustomError, PyException);

Python::with_gil(|py| {
    let ctx = [(&quot;CustomError&quot;, py.get_type::&lt;CustomError&gt;())].into_py_dict(py);
    pyo3::py_run!(py, *ctx, &quot;assert str(CustomError) == \&quot;&lt;class 'mymodule.CustomError'&gt;\&quot;&quot;);
    pyo3::py_run!(py, *ctx, &quot;assert CustomError('oops').args == ('oops',)&quot;);
});
<span class="boring">}
</span></code></pre></pre>
<p>When using PyO3 to create an extension module, you can add the new exception to
the module like this, so that it is importable from Python:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyModule;
use pyo3::exceptions::PyException;

pyo3::create_exception!(mymodule, CustomError, PyException);

#[pymodule]
fn mymodule(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    // ... other elements added to module ...
    m.add(&quot;CustomError&quot;, py.get_type::&lt;CustomError&gt;())?;

    Ok(())
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="raising-an-exception"><a class="header" href="#raising-an-exception">Raising an exception</a></h2>
<p>To raise an exception from <code>pyfunction</code>s and <code>pymethods</code>, you should return an <code>Err(PyErr)</code>.
If returned to Python code, this <a href="https://pyo3.rs/main/doc/pyo3/struct.PyErr.html"><code>PyErr</code></a> will then be raised as a Python exception. Many PyO3 APIs also return <a href="https://pyo3.rs/main/doc/pyo3/type.PyResult.html"><code>PyResult</code></a>.</p>
<p>If a Rust type exists for the exception, then it is possible to use the <code>new_err</code> method.
For example, each standard exception defined in the <code>pyo3::exceptions</code> module
has a corresponding Rust type and exceptions defined by <a href="https://pyo3.rs/main/doc/pyo3/macro.create_exception.html"><code>create_exception!</code></a> and <a href="https://pyo3.rs/main/doc/pyo3/macro.import_exception.html"><code>import_exception!</code></a> macro have Rust types as well.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::exceptions::PyZeroDivisionError;
use pyo3::prelude::*;

#[pyfunction]
fn divide(a: i32, b: i32) -&gt; PyResult&lt;i32&gt; {
    match a.checked_div(b) {
        Some(q) =&gt; Ok(q),
        None =&gt; Err(PyZeroDivisionError::new_err(&quot;division by zero&quot;)),
    }
}
<span class="boring">
</span><span class="boring">fn main(){
</span><span class="boring">	Python::with_gil(|py|{
</span><span class="boring">		let fun = pyo3::wrap_pyfunction!(divide, py).unwrap();
</span><span class="boring">		fun.call1((1,0)).unwrap_err();
</span><span class="boring">		fun.call1((1,1)).unwrap();
</span><span class="boring">	});
</span><span class="boring">}
</span></code></pre></pre>
<p>You can manually write and fetch errors in the Python interpreter's global state:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::{Python, PyErr};
use pyo3::exceptions::PyTypeError;

Python::with_gil(|py| {
    PyTypeError::new_err(&quot;Error&quot;).restore(py);
    assert!(PyErr::occurred(py));
    drop(PyErr::fetch(py));
});
<span class="boring">}
</span></code></pre></pre>
<p>If you already have a Python exception object, you can use <a href="https://pyo3.rs/main/doc/pyo3/struct.PyErr.html#method.from_value"><code>PyErr::from_value</code></a> to create a <code>PyErr</code> from it.</p>
<h2 id="checking-exception-types"><a class="header" href="#checking-exception-types">Checking exception types</a></h2>
<p>Python has an <a href="https://docs.python.org/3/library/functions.html#isinstance"><code>isinstance</code></a> method to check an object's type.
In PyO3 every object has the <a href="https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#method.is_instance"><code>PyAny::is_instance</code></a> and <a href="https://pyo3.rs/main/doc/pyo3/struct.PyAny.html#method.is_instance_of"><code>PyAny::is_instance_of</code></a> methods which do the same thing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::Python;
use pyo3::types::{PyBool, PyList};

Python::with_gil(|py| {
    assert!(PyBool::new(py, true).is_instance_of::&lt;PyBool&gt;().unwrap());
    let list = PyList::new(py, &amp;[1, 2, 3, 4]);
    assert!(!list.is_instance_of::&lt;PyBool&gt;().unwrap());
    assert!(list.is_instance_of::&lt;PyList&gt;().unwrap());
});
<span class="boring">}
</span></code></pre></pre>
<p>To check the type of an exception, you can similarly do:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::exceptions::PyTypeError;
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span><span class="boring">let err = PyTypeError::new_err(());
</span>err.is_instance_of::&lt;PyTypeError&gt;(py);
<span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="handling-rust-errors"><a class="header" href="#handling-rust-errors">Handling Rust errors</a></h2>
<p>The vast majority of operations in this library will return
<a href="https://pyo3.rs/main/doc/pyo3/prelude/type.PyResult.html"><code>PyResult&lt;T&gt;</code></a>,
which is an alias for the type <code>Result&lt;T, PyErr&gt;</code>.</p>
<p>A <a href="https://pyo3.rs/main/doc/pyo3/struct.PyErr.html"><code>PyErr</code></a> represents a Python exception. Errors within the PyO3 library are also exposed as
Python exceptions.</p>
<p>If your code has a custom error type, adding an implementation of <code>std::convert::From&lt;MyError&gt; for PyErr</code>
is usually enough. PyO3 will then automatically convert your error to a Python exception when needed.</p>
<p>The following code snippet defines a Rust error named <code>CustomIOError</code>. In its <code>From&lt;CustomIOError&gt; for PyErr</code>
implementation it returns a <code>PyErr</code> representing Python's <code>OSError</code>.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::exceptions::PyOSError;
use pyo3::prelude::*;
use std::fmt;

#[derive(Debug)]
struct CustomIOError;

impl std::error::Error for CustomIOError {}

impl fmt::Display for CustomIOError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;Oh no!&quot;)
    }
}

impl std::convert::From&lt;CustomIOError&gt; for PyErr {
    fn from(err: CustomIOError) -&gt; PyErr {
        PyOSError::new_err(err.to_string())
    }
}

pub struct Connection { /* ... */}

fn bind(addr: String) -&gt; Result&lt;Connection, CustomIOError&gt; {
    if &amp;addr == &quot;0.0.0.0&quot;{
        Err(CustomIOError)
    } else {
        Ok(Connection{ /* ... */})
    }
}

#[pyfunction]
fn connect(s: String) -&gt; Result&lt;(), CustomIOError&gt; {
    bind(s)?;
    Ok(())
}

fn main() {
    Python::with_gil(|py| {
        let fun = pyo3::wrap_pyfunction!(connect, py).unwrap();
        let err = fun.call1((&quot;0.0.0.0&quot;,)).unwrap_err();
        assert!(err.is_instance_of::&lt;PyOSError&gt;(py));
    });
}
</code></pre></pre>
<p>This has been implemented for most of Rust's standard library errors, so that you can use the <code>?</code>
(&quot;try&quot;) operator with them. The following code snippet will raise a <code>ValueError</code> in Python if
<code>String::parse()</code> returns an error.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

fn parse_int(s: String) -&gt; PyResult&lt;usize&gt; {
    Ok(s.parse::&lt;usize&gt;()?)
}
<span class="boring">
</span><span class="boring">use pyo3::exceptions::PyValueError;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        assert_eq!(parse_int(String::from(&quot;1&quot;)).unwrap(), 1);
</span><span class="boring">        assert_eq!(parse_int(String::from(&quot;1337&quot;)).unwrap(), 1337);
</span><span class="boring">
</span><span class="boring">        assert!(parse_int(String::from(&quot;-1&quot;))
</span><span class="boring">            .unwrap_err()
</span><span class="boring">            .is_instance_of::&lt;PyValueError&gt;(py));
</span><span class="boring">        assert!(parse_int(String::from(&quot;foo&quot;))
</span><span class="boring">            .unwrap_err()
</span><span class="boring">            .is_instance_of::&lt;PyValueError&gt;(py));
</span><span class="boring">        assert!(parse_int(String::from(&quot;13.37&quot;))
</span><span class="boring">            .unwrap_err()
</span><span class="boring">            .is_instance_of::&lt;PyValueError&gt;(py));
</span><span class="boring">    })
</span><span class="boring">}
</span></code></pre></pre>
<p>If lazy construction of the Python exception instance is desired, the
<a href="https://pyo3.rs/main/doc/pyo3/trait.PyErrArguments.html"><code>PyErrArguments</code></a>
trait can be implemented. In that case, actual exception argument creation is delayed
until the <code>PyErr</code> is needed.</p>
<h2 id="using-exceptions-defined-in-python-code"><a class="header" href="#using-exceptions-defined-in-python-code">Using exceptions defined in Python code</a></h2>
<p>It is possible to use an exception defined in Python code as a native Rust type.
The <code>import_exception!</code> macro allows importing a specific exception class and defines a Rust type
for that exception.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(dead_code)]
<span class="boring">fn main() {
</span>use pyo3::prelude::*;

mod io {
    pyo3::import_exception!(io, UnsupportedOperation);
}

fn tell(file: &amp;PyAny) -&gt; PyResult&lt;u64&gt; {
    match file.call_method0(&quot;tell&quot;) {
        Err(_) =&gt; Err(io::UnsupportedOperation::new_err(&quot;not supported: tell&quot;)),
        Ok(x) =&gt; x.extract::&lt;u64&gt;(),
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><a href="https://pyo3.rs/main/doc/pyo3/exceptions/index.html"><code>pyo3::exceptions</code></a>
defines exceptions for several standard library modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-python-in-rust-code"><a class="header" href="#calling-python-in-rust-code">Calling Python in Rust code</a></h1>
<p>This chapter of the guide documents some ways to interact with Python code from Rust:</p>
<ul>
<li>How to call Python functions</li>
<li>How to execute existing Python code</li>
</ul>
<h2 id="calling-python-functions"><a class="header" href="#calling-python-functions">Calling Python functions</a></h2>
<p>Any Python-native object reference (such as <code>&amp;PyAny</code>, <code>&amp;PyList</code>, or <code>&amp;PyCell&lt;MyClass&gt;</code>) can be used to call Python functions.</p>
<p>PyO3 offers two APIs to make function calls:</p>
<ul>
<li><a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call"><code>call</code></a> - call any callable Python object.</li>
<li><a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call_method"><code>call_method</code></a> - call a method on the Python object.</li>
</ul>
<p>Both of these APIs take <code>args</code> and <code>kwargs</code> arguments (for positional and keyword arguments respectively). There are variants for less complex calls:</p>
<ul>
<li><a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call1"><code>call1</code></a> and <a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call_method1"><code>call_method1</code></a> to call only with positional <code>args</code>.</li>
<li><a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call0"><code>call0</code></a> and <a href="https://docs.rs/pyo3/0.12.3/pyo3/struct.PyAny.html#method.call_method0"><code>call_method0</code></a> to call with no arguments.</li>
</ul>
<p>For convenience the <a href="types.html#pyt-and-pyobject"><code>Py&lt;T&gt;</code></a> smart pointer also exposes these same six API methods, but needs a <code>Python</code> token as an additional first argument to prove the GIL is held.</p>
<p>The example below calls a Python function behind a <code>PyObject</code> (aka <code>Py&lt;PyAny&gt;</code>) reference:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyTuple;

fn main() -&gt; PyResult&lt;()&gt; {
    let arg1 = &quot;arg1&quot;;
    let arg2 = &quot;arg2&quot;;
    let arg3 = &quot;arg3&quot;;

    Python::with_gil(|py| {
        let fun: Py&lt;PyAny&gt; = PyModule::from_code(
            py,
            &quot;def example(*args, **kwargs):
                if args != ():
                    print('called with args', args)
                if kwargs != {}:
                    print('called with kwargs', kwargs)
                if args == () and kwargs == {}:
                    print('called with no arguments')&quot;,
            &quot;&quot;,
            &quot;&quot;,
        )?.getattr(&quot;example&quot;)?.into();

        // call object without empty arguments
        fun.call0(py)?;

        // call object with PyTuple
        let args = PyTuple::new(py, &amp;[arg1, arg2, arg3]);
        fun.call1(py, args)?;

        // pass arguments as rust tuple
        let args = (arg1, arg2, arg3);
        fun.call1(py, args)?;
        Ok(())
    })
}
</code></pre></pre>
<h3 id="creating-keyword-arguments"><a class="header" href="#creating-keyword-arguments">Creating keyword arguments</a></h3>
<p>For the <code>call</code> and <code>call_method</code> APIs, <code>kwargs</code> can be <code>None</code> or <code>Some(&amp;PyDict)</code>. You can use the <a href="https://pyo3.rs/main/doc/pyo3/types/trait.IntoPyDict.html"><code>IntoPyDict</code></a> trait to convert other dict-like containers, e.g. <code>HashMap</code> or <code>BTreeMap</code>, as well as tuples with up to 10 elements and <code>Vec</code>s where each element is a two-element tuple.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;
use std::collections::HashMap;

fn main() -&gt; PyResult&lt;()&gt; {
    let key1 = &quot;key1&quot;;
    let val1 = 1;
    let key2 = &quot;key2&quot;;
    let val2 = 2;

    Python::with_gil(|py| {
        let fun: Py&lt;PyAny&gt; = PyModule::from_code(
            py,
            &quot;def example(*args, **kwargs):
                if args != ():
                    print('called with args', args)
                if kwargs != {}:
                    print('called with kwargs', kwargs)
                if args == () and kwargs == {}:
                    print('called with no arguments')&quot;,
            &quot;&quot;,
            &quot;&quot;,
        )?.getattr(&quot;example&quot;)?.into();


        // call object with PyDict
        let kwargs = [(key1, val1)].into_py_dict(py);
        fun.call(py, (), Some(kwargs))?;

        // pass arguments as Vec
        let kwargs = vec![(key1, val1), (key2, val2)];
        fun.call(py, (), Some(kwargs.into_py_dict(py)))?;

        // pass arguments as HashMap
        let mut kwargs = HashMap::&lt;&amp;str, i32&gt;::new();
        kwargs.insert(key1, 1);
        fun.call(py, (), Some(kwargs.into_py_dict(py)))?;

        Ok(())
   })
}
</code></pre></pre>
<h2 id="executing-existing-python-code"><a class="header" href="#executing-existing-python-code">Executing existing Python code</a></h2>
<p>If you already have some existing Python code that you need to execute from Rust, the following FAQs can help you select the right PyO3 functionality for your situation:</p>
<h3 id="want-to-access-python-apis-then-use-pymoduleimport"><a class="header" href="#want-to-access-python-apis-then-use-pymoduleimport">Want to access Python APIs? Then use <code>PyModule::import</code>.</a></h3>
<p><a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyModule.html#method.import"><code>Pymodule::import</code></a> can
be used to get handle to a Python module from Rust. You can use this to import and use any Python
module available in your environment.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

fn main() -&gt; PyResult&lt;()&gt; {
    Python::with_gil(|py| {
        let builtins = PyModule::import(py, &quot;builtins&quot;)?;
        let total: i32 = builtins.getattr(&quot;sum&quot;)?.call1((vec![1, 2, 3],))?.extract()?;
        assert_eq!(total, 6);
        Ok(())
    })
}
</code></pre></pre>
<h3 id="want-to-run-just-an-expression-then-use-eval"><a class="header" href="#want-to-run-just-an-expression-then-use-eval">Want to run just an expression? Then use <code>eval</code>.</a></h3>
<p><a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.eval"><code>Python::eval</code></a> is
a method to execute a <a href="https://docs.python.org/3.7/reference/expressions.html">Python expression</a>
and return the evaluated value as a <code>&amp;PyAny</code> object.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

<span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span>Python::with_gil(|py| {
    let result = py.eval(&quot;[i * 10 for i in range(5)]&quot;, None, None).map_err(|e| {
        e.print_and_set_sys_last_vars(py);
    })?;
    let res: Vec&lt;i64&gt; = result.extract().unwrap();
    assert_eq!(res, vec![0, 10, 20, 30, 40]);
    Ok(())
})
<span class="boring">}
</span></code></pre></pre>
<h3 id="want-to-run-statements-then-use-run"><a class="header" href="#want-to-run-statements-then-use-run">Want to run statements? Then use <code>run</code>.</a></h3>
<p><a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.run"><code>Python::run</code></a> is a method to execute one or more
<a href="https://docs.python.org/3.7/reference/simple_stmts.html">Python statements</a>.
This method returns nothing (like any Python statement), but you can get
access to manipulated objects via the <code>locals</code> dict.</p>
<p>You can also use the <a href="https://pyo3.rs/main/doc/pyo3/macro.py_run.html"><code>py_run!</code></a> macro, which is a shorthand for <a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.run"><code>Python::run</code></a>.
Since <a href="https://pyo3.rs/main/doc/pyo3/macro.py_run.html"><code>py_run!</code></a> panics on exceptions, we recommend you use this macro only for
quickly testing your Python extensions.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::{PyCell, py_run};

<span class="boring">fn main() {
</span>#[pyclass]
struct UserData {
    id: u32,
    name: String,
}

#[pymethods]
impl UserData {
    fn as_tuple(&amp;self) -&gt; (u32, String) {
        (self.id, self.name.clone())
    }

    fn __repr__(&amp;self) -&gt; PyResult&lt;String&gt; {
        Ok(format!(&quot;User {}(id: {})&quot;, self.name, self.id))
    }
}

Python::with_gil(|py| {
    let userdata = UserData {
        id: 34,
        name: &quot;Yu&quot;.to_string(),
    };
    let userdata = PyCell::new(py, userdata).unwrap();
    let userdata_as_tuple = (34, &quot;Yu&quot;);
    py_run!(py, userdata userdata_as_tuple, r#&quot;
assert repr(userdata) == &quot;User Yu(id: 34)&quot;
assert userdata.as_tuple() == userdata_as_tuple
    &quot;#);
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="you-have-a-python-file-or-code-snippet-then-use-pymodulefrom_code"><a class="header" href="#you-have-a-python-file-or-code-snippet-then-use-pymodulefrom_code">You have a Python file or code snippet? Then use <code>PyModule::from_code</code>.</a></h2>
<p><a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyModule.html#method.from_code">PyModule::from_code</a>
can be used to generate a Python module which can then be used just as if it was imported with
<code>PyModule::import</code>.</p>
<p><strong>Warning</strong>: This will compile and execute code. <strong>Never</strong> pass untrusted code
to this function!</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::{prelude::*, types::{IntoPyDict, PyModule}};

<span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| {
    let activators = PyModule::from_code(py, r#&quot;
def relu(x):
    &quot;&quot;&quot;see https://en.wikipedia.org/wiki/Rectifier_(neural_networks)&quot;&quot;&quot;
    return max(0.0, x)

def leaky_relu(x, slope=0.01):
    return x if x &gt;= 0 else x * slope
    &quot;#, &quot;activators.py&quot;, &quot;activators&quot;)?;

    let relu_result: f64 = activators.getattr(&quot;relu&quot;)?.call1((-1.0,))?.extract()?;
    assert_eq!(relu_result, 0.0);

    let kwargs = [(&quot;slope&quot;, 0.2)].into_py_dict(py);
    let lrelu_result: f64 = activators
        .getattr(&quot;leaky_relu&quot;)?.call((-1.0,), Some(kwargs))?
        .extract()?;
    assert_eq!(lrelu_result, -0.2);
<span class="boring">   Ok(())
</span>})
<span class="boring">}
</span></code></pre></pre>
<h3 id="include-multiple-python-files"><a class="header" href="#include-multiple-python-files">Include multiple Python files</a></h3>
<p>You can include a file at compile time by using
<a href="https://doc.rust-lang.org/std/macro.include_str.html"><code>std::include_str</code></a> macro.</p>
<p>Or you can load a file at runtime by using
<a href="https://doc.rust-lang.org/std/fs/fn.read_to_string.html"><code>std::fs::read_to_string</code></a> function.</p>
<p>Many Python files can be included and loaded as modules. If one file depends on
another you must preserve correct order while declaring <code>PyModule</code>.</p>
<p>Example directory structure:</p>
<pre><code class="language-text">.
├── Cargo.lock
├── Cargo.toml
├── python_app
│   ├── app.py
│   └── utils
│       └── foo.py
└── src
    └── main.rs
</code></pre>
<p><code>python_app/app.py</code>:</p>
<pre><code class="language-python">from utils.foo import bar


def run():
    return bar()
</code></pre>
<p><code>python_app/utils/foo.py</code>:</p>
<pre><code class="language-python">def bar():
    return &quot;baz&quot;
</code></pre>
<p>The example below shows:</p>
<ul>
<li>how to include content of <code>app.py</code> and <code>utils/foo.py</code> into your rust binary</li>
<li>how to call function <code>run()</code> (declared in <code>app.py</code>) that needs function
imported from <code>utils/foo.py</code></li>
</ul>
<p><code>src/main.rs</code>:</p>
<pre><code class="language-ignore">use pyo3::prelude::*;

fn main() -&gt; PyResult&lt;()&gt; {
    let py_foo = include_str!(concat!(env!(&quot;CARGO_MANIFEST_DIR&quot;), &quot;/python_app/utils/foo.py&quot;));
    let py_app = include_str!(concat!(env!(&quot;CARGO_MANIFEST_DIR&quot;), &quot;/python_app/app.py&quot;));
    let from_python = Python::with_gil(|py| -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
        PyModule::from_code(py, py_foo, &quot;utils.foo&quot;, &quot;utils.foo&quot;)?;
        let app: Py&lt;PyAny&gt; = PyModule::from_code(py, py_app, &quot;&quot;, &quot;&quot;)?
            .getattr(&quot;run&quot;)?
            .into();
        app.call0(py)
    });

    println!(&quot;py: {}&quot;, from_python?);
    Ok(())
}
</code></pre>
<p>The example below shows:</p>
<ul>
<li>how to load content of <code>app.py</code> at runtime so that it sees its dependencies
automatically</li>
<li>how to call function <code>run()</code> (declared in <code>app.py</code>) that needs function
imported from <code>utils/foo.py</code></li>
</ul>
<p>It is recommended to use absolute paths because then your binary can be run
from anywhere as long as your <code>app.py</code> is in the expected directory (in this example
that directory is <code>/usr/share/python_app</code>).</p>
<p><code>src/main.rs</code>:</p>
<pre><code class="language-no_run">use pyo3::prelude::*;
use pyo3::types::PyList;
use std::fs;
use std::path::Path;

fn main() -&gt; PyResult&lt;()&gt; {
    let path = Path::new(&quot;/usr/share/python_app&quot;);
    let py_app = fs::read_to_string(path.join(&quot;app.py&quot;))?;
    let from_python = Python::with_gil(|py| -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
        let syspath: &amp;PyList = py.import(&quot;sys&quot;)?.getattr(&quot;path&quot;)?.downcast::&lt;PyList&gt;()?;
        syspath.insert(0, &amp;path)?;
        let app: Py&lt;PyAny&gt; = PyModule::from_code(py, &amp;py_app, &quot;&quot;, &quot;&quot;)?
            .getattr(&quot;run&quot;)?
            .into();
        app.call0(py)
    });

    println!(&quot;py: {}&quot;, from_python?);
    Ok(())
}
</code></pre>
<h2 id="need-to-use-a-context-manager-from-rust"><a class="header" href="#need-to-use-a-context-manager-from-rust">Need to use a context manager from Rust?</a></h2>
<p>Use context managers by directly invoking <code>__enter__</code> and <code>__exit__</code>.</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyModule;

fn main() {
    Python::with_gil(|py| {
        let custom_manager = PyModule::from_code(py, r#&quot;
class House(object):
    def __init__(self, address):
        self.address = address
    def __enter__(self):
        print(f&quot;Welcome to {self.address}!&quot;)
    def __exit__(self, type, value, traceback):
        if type:
            print(f&quot;Sorry you had {type} trouble at {self.address}&quot;)
        else:
            print(f&quot;Thank you for visiting {self.address}, come again soon!&quot;)

        &quot;#, &quot;house.py&quot;, &quot;house&quot;).unwrap();

        let house_class = custom_manager.getattr(&quot;House&quot;).unwrap();
        let house = house_class.call1((&quot;123 Main Street&quot;,)).unwrap();

        house.call_method0(&quot;__enter__&quot;).unwrap();

        let result = py.eval(&quot;undefined_variable + 1&quot;, None, None);

        // If the eval threw an exception we'll pass it through to the context manager.
        // Otherwise, __exit__  is called with empty arguments (Python &quot;None&quot;).
        match result {
            Ok(_) =&gt; {
                let none = py.None();
                house.call_method1(&quot;__exit__&quot;, (&amp;none, &amp;none, &amp;none)).unwrap();
            },
            Err(e) =&gt; {
                house.call_method1(
                    &quot;__exit__&quot;,
                    (e.get_type(py), e.value(py), e.traceback(py))
                ).unwrap();
            }
        }
    })
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gil-lifetimes-mutability-and-python-object-types"><a class="header" href="#gil-lifetimes-mutability-and-python-object-types">GIL lifetimes, mutability and Python object types</a></h1>
<p>On first glance, PyO3 provides a huge number of different types that can be used
to wrap or refer to Python objects.  This page delves into the details and gives
an overview of their intended meaning, with examples when each type is best
used.</p>
<h2 id="mutability-and-rust-types"><a class="header" href="#mutability-and-rust-types">Mutability and Rust types</a></h2>
<p>Since Python has no concept of ownership, and works solely with boxed objects,
any Python object can be referenced any number of times, and mutation is allowed
from any reference.</p>
<p>The situation is helped a little by the Global Interpreter Lock (GIL), which
ensures that only one thread can use the Python interpreter and its API at the
same time, while non-Python operations (system calls and extension code) can
unlock the GIL.  (See <a href="parallelism.html">the section on parallelism</a> for how to do
that in PyO3.)</p>
<p>In PyO3, holding the GIL is modeled by acquiring a token of the type
<code>Python&lt;'py&gt;</code>, which serves three purposes:</p>
<ul>
<li>It provides some global API for the Python interpreter, such as
<a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.eval"><code>eval</code></a>.</li>
<li>It can be passed to functions that require a proof of holding the GIL,
such as <a href="https://pyo3.rs/main/doc/pyo3/struct.Py.html#method.clone_ref"><code>Py::clone_ref</code></a>.</li>
<li>Its lifetime can be used to create Rust references that implicitly guarantee
holding the GIL, such as <a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html"><code>&amp;'py PyAny</code></a>.</li>
</ul>
<p>The latter two points are the reason why some APIs in PyO3 require the <code>py: Python</code> argument, while others don't.</p>
<p>The PyO3 API for Python objects is written such that instead of requiring a
mutable Rust reference for mutating operations such as
<a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyList.html#method.append"><code>PyList::append</code></a>, a shared reference (which, in turn, can only
be created through <code>Python&lt;'_&gt;</code> with a GIL lifetime) is sufficient.</p>
<p>However, Rust structs wrapped as Python objects (called <code>pyclass</code> types) usually
<em>do</em> need <code>&amp;mut</code> access.  Due to the GIL, PyO3 <em>can</em> guarantee thread-safe acces
to them, but it cannot statically guarantee uniqueness of <code>&amp;mut</code> references once
an object's ownership has been passed to the Python interpreter, ensuring
references is done at runtime using <code>PyCell</code>, a scheme very similar to
<code>std::cell::RefCell</code>.</p>
<h2 id="object-types"><a class="header" href="#object-types">Object types</a></h2>
<h3 id="a-hrefhttpspyo3rsmaindocpyo3typesstructpyanyhtmlpyanya"><a class="header" href="#a-hrefhttpspyo3rsmaindocpyo3typesstructpyanyhtmlpyanya"><a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html"><code>PyAny</code></a></a></h3>
<p><strong>Represents:</strong> a Python object of unspecified type, restricted to a GIL
lifetime.  Currently, <code>PyAny</code> can only ever occur as a reference, <code>&amp;PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to refer to some Python object and will have the
GIL for the whole duration you need to access that object. For example,
intermediate values and arguments to <code>pyfunction</code>s or <code>pymethod</code>s implemented
in Rust where any type is allowed.</p>
<p>Many general methods for interacting with Python objects are on the <code>PyAny</code> struct,
such as <code>getattr</code>, <code>setattr</code>, and <code>.call</code>.</p>
<p><strong>Conversions:</strong></p>
<p>For a <code>&amp;PyAny</code> object reference <code>any</code> where the underlying object is a Python-native type such as
a list:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let obj: &amp;PyAny = PyList::empty(py);

// To &amp;PyList with PyAny::downcast
let _: &amp;PyList = obj.downcast()?;

// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = obj.into();

// To Py&lt;PyList&gt; with PyAny::extract
let _: Py&lt;PyList&gt; = obj.extract()?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>For a <code>&amp;PyAny</code> object reference <code>any</code> where the underlying object is a <code>#[pyclass]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::{Py, Python, PyAny, PyResult};
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let obj: &amp;PyAny = Py::new(py, MyClass { })?.into_ref(py);

// To &amp;PyCell&lt;MyClass&gt; with PyAny::downcast
let _: &amp;PyCell&lt;MyClass&gt; = obj.downcast()?;

// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = obj.into();

// To Py&lt;MyClass&gt; with PyAny::extract
let _: Py&lt;MyClass&gt; = obj.extract()?;

// To MyClass with PyAny::extract, if MyClass: Clone
let _: MyClass = obj.extract()?;

// To PyRef&lt;'_, MyClass&gt; or PyRefMut&lt;'_, MyClass&gt; with PyAny::extract
let _: PyRef&lt;'_, MyClass&gt; = obj.extract()?;
let _: PyRefMut&lt;'_, MyClass&gt; = obj.extract()?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pytuple-pydict-and-many-more"><a class="header" href="#pytuple-pydict-and-many-more"><code>PyTuple</code>, <code>PyDict</code>, and many more</a></h3>
<p><strong>Represents:</strong> a native Python object of known type, restricted to a GIL
lifetime just like <code>PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to operate with native Python types while holding
the GIL.  Like <code>PyAny</code>, this is the most convenient form to use for function
arguments and intermediate values.</p>
<p>These types all implement <code>Deref&lt;Target = PyAny&gt;</code>, so they all expose the same
methods which can be found on <code>PyAny</code>.</p>
<p>To see all Python types exposed by <code>PyO3</code> you should consult the
<a href="https://pyo3.rs/main/doc/pyo3/types/index.html"><code>pyo3::types</code></a> module.</p>
<p><strong>Conversions:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let list = PyList::empty(py);

// Use methods from PyAny on all Python types with Deref implementation
let _ = list.repr()?;

// To &amp;PyAny automatically with Deref implementation
let _: &amp;PyAny = list;

// To &amp;PyAny explicitly with .as_ref()
let _: &amp;PyAny = list.as_ref();

// To Py&lt;T&gt; with .into() or Py::from()
let _: Py&lt;PyList&gt; = list.into();

// To PyObject with .into() or .to_object(py)
let _: PyObject = list.into();
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pyt-and-pyobject"><a class="header" href="#pyt-and-pyobject"><code>Py&lt;T&gt;</code> and <code>PyObject</code></a></h3>
<p><strong>Represents:</strong> a GIL-independent reference to a Python object. This can be a Python native type
(like <code>PyTuple</code>), or a <code>pyclass</code> type implemented in Rust. The most commonly-used variant,
<code>Py&lt;PyAny&gt;</code>, is also known as <code>PyObject</code>.</p>
<p><strong>Used:</strong> Whenever you want to carry around references to a Python object without caring about a
GIL lifetime.  For example, storing Python object references in a Rust struct that outlives the
Python-Rust FFI boundary, or returning objects from functions implemented in Rust back to Python.</p>
<p>Can be cloned using Python reference counts with <code>.clone()</code>.</p>
<p><strong>Conversions:</strong></p>
<p>For a <code>Py&lt;PyList&gt;</code>, the conversions are as below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">Python::with_gil(|py| {
</span>let list: Py&lt;PyList&gt; = PyList::empty(py).into();

// To &amp;PyList with Py::as_ref() (borrows from the Py)
let _: &amp;PyList = list.as_ref(py);

<span class="boring">let list_clone = list.clone(); // Because `.into_ref()` will consume `list`.
</span>// To &amp;PyList with Py::into_ref() (moves the pointer into PyO3's object storage)
let _: &amp;PyList = list.into_ref(py);

<span class="boring">let list = list_clone;
</span>// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = list.into();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>For a <code>#[pyclass] struct MyClass</code>, the conversions for <code>Py&lt;MyClass&gt;</code> are below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let my_class: Py&lt;MyClass&gt; = Py::new(py, MyClass { })?;

// To &amp;PyCell&lt;MyClass&gt; with Py::as_ref() (borrows from the Py)
let _: &amp;PyCell&lt;MyClass&gt; = my_class.as_ref(py);

<span class="boring">let my_class_clone = my_class.clone(); // Because `.into_ref()` will consume `my_class`.
</span>// To &amp;PyCell&lt;MyClass&gt; with Py::into_ref() (moves the pointer into PyO3's object storage)
let _: &amp;PyCell&lt;MyClass&gt; = my_class.into_ref(py);

<span class="boring">let my_class = my_class_clone.clone();
</span>// To Py&lt;PyAny&gt; (aka PyObject) with .into_py(py)
let _: Py&lt;PyAny&gt; = my_class.into_py(py);

<span class="boring">let my_class = my_class_clone;
</span>// To PyRef&lt;'_, MyClass&gt; with Py::borrow or Py::try_borrow
let _: PyRef&lt;'_, MyClass&gt; = my_class.try_borrow(py)?;

// To PyRefMut&lt;'_, MyClass&gt; with Py::borrow_mut or Py::try_borrow_mut
let _: PyRefMut&lt;'_, MyClass&gt; = my_class.try_borrow_mut(py)?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">});
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pycellsometype"><a class="header" href="#pycellsometype"><code>PyCell&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> a reference to a Rust object (instance of <code>PyClass</code>) which is
wrapped in a Python object.  The cell part is an analog to stdlib's
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> to allow access to <code>&amp;mut</code> references.</p>
<p><strong>Used:</strong> for accessing pure-Rust API of the instance (members and functions
taking <code>&amp;SomeType</code> or <code>&amp;mut SomeType</code>) while maintaining the aliasing rules of
Rust references.</p>
<p>Like pyo3's Python native types, <code>PyCell&lt;T&gt;</code> implements <code>Deref&lt;Target = PyAny&gt;</code>,
so it also exposes all of the methods on <code>PyAny</code>.</p>
<p><strong>Conversions:</strong></p>
<p><code>PyCell&lt;T&gt;</code> can be used to access <code>&amp;T</code> and <code>&amp;mut T</code> via <code>PyRef&lt;T&gt;</code> and <code>PyRefMut&lt;T&gt;</code> respectively.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass { })?;

// To PyRef&lt;T&gt; with .borrow() or .try_borrow()
let py_ref: PyRef&lt;'_, MyClass&gt; = cell.try_borrow()?;
let _: &amp;MyClass = &amp;*py_ref;
<span class="boring">drop(py_ref);
</span>
// To PyRefMut&lt;T&gt; with .borrow_mut() or .try_borrow_mut()
let mut py_ref_mut: PyRefMut&lt;'_, MyClass&gt; = cell.try_borrow_mut()?;
let _: &amp;mut MyClass = &amp;mut *py_ref_mut;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p><code>PyCell&lt;T&gt;</code> can also be accessed like a Python-native type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass { })?;

// Use methods from PyAny on PyCell&lt;T&gt; with Deref implementation
let _ = cell.repr()?;

// To &amp;PyAny automatically with Deref implementation
let _: &amp;PyAny = cell;

// To &amp;PyAny explicitly with .as_ref()
let _: &amp;PyAny = cell.as_ref();
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pyrefsometype-and-pyrefmutsometype"><a class="header" href="#pyrefsometype-and-pyrefmutsometype"><code>PyRef&lt;SomeType&gt;</code> and <code>PyRefMut&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> reference wrapper types employed by <code>PyCell</code> to keep track of
borrows, analog to <code>Ref</code> and <code>RefMut</code> used by <code>RefCell</code>.</p>
<p><strong>Used:</strong> while borrowing a <code>PyCell</code>.  They can also be used with <code>.extract()</code>
on types like <code>Py&lt;T&gt;</code> and <code>PyAny</code> to get a reference quickly.</p>
<h2 id="related-traits-and-types"><a class="header" href="#related-traits-and-types">Related traits and types</a></h2>
<h3 id="pyclass"><a class="header" href="#pyclass"><code>PyClass</code></a></h3>
<p>This trait marks structs defined in Rust that are also usable as Python classes,
usually defined using the <code>#[pyclass]</code> macro.</p>
<h3 id="pynativetype"><a class="header" href="#pynativetype"><code>PyNativeType</code></a></h3>
<p>This trait marks structs that mirror native Python types, such as <code>PyList</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h1>
<p>CPython has the infamous <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock">Global Interpreter Lock</a>, which prevents several threads from executing Python bytecode in parallel. This makes threading in Python a bad fit for <a href="https://stackoverflow.com/questions/868568/">CPU-bound</a> tasks and often forces developers to accept the overhead of multiprocessing.</p>
<p>In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a look at our <a href="https://github.com/PyO3/pyo3/blob/main/examples/word-count/src/lib.rs">word-count</a> example, where we have a <code>search</code> function that utilizes the <a href="https://github.com/rayon-rs/rayon">rayon</a> crate to count words in parallel.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

// These traits let us use `par_lines` and `map`.
use rayon::str::ParallelString;
use rayon::iter::ParallelIterator;

/// Count the occurrences of needle in line, case insensitive
fn count_line(line: &amp;str, needle: &amp;str) -&gt; usize {
    let mut total = 0;
    for word in line.split(' ') {
        if word == needle {
            total += 1;
        }
    }
    total
}

#[pyfunction]
fn search(contents: &amp;str, needle: &amp;str) -&gt; usize {
    contents
        .par_lines()
        .map(|line| count_line(line, needle))
        .sum()
}
<span class="boring">}
</span></code></pre></pre>
<p>But let's assume you have a long running Rust function which you would like to execute several times in parallel. For the sake of example let's take a sequential version of the word count:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn count_line(line: &amp;str, needle: &amp;str) -&gt; usize {
</span><span class="boring">    let mut total = 0;
</span><span class="boring">    for word in line.split(' ') {
</span><span class="boring">        if word == needle {
</span><span class="boring">            total += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    total
</span><span class="boring">}
</span><span class="boring">
</span>fn search_sequential(contents: &amp;str, needle: &amp;str) -&gt; usize {
    contents.lines().map(|line| count_line(line, needle)).sum()
}
<span class="boring">}
</span></code></pre></pre>
<p>To enable parallel execution of this function, the <a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> method can be used to temporarily release the GIL, thus allowing other Python threads to run. We then have a function exposed to the Python runtime which calls <code>search_sequential</code> inside a closure passed to <a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> to enable true parallelism:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">fn count_line(line: &amp;str, needle: &amp;str) -&gt; usize {
</span><span class="boring">    let mut total = 0;
</span><span class="boring">    for word in line.split(' ') {
</span><span class="boring">        if word == needle {
</span><span class="boring">            total += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    total
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn search_sequential(contents: &amp;str, needle: &amp;str) -&gt; usize {
</span><span class="boring">   contents.lines().map(|line| count_line(line, needle)).sum()
</span><span class="boring">}
</span>#[pyfunction]
fn search_sequential_allow_threads(py: Python&lt;'_&gt;, contents: &amp;str, needle: &amp;str) -&gt; usize {
    py.allow_threads(|| search_sequential(contents, needle))
}
<span class="boring">}
</span></code></pre></pre>
<p>Now Python threads can use more than one CPU core, resolving the limitation which usually makes multi-threading in Python only good for IO-bound tasks:</p>
<pre><code class="language-Python">from concurrent.futures import ThreadPoolExecutor
from word_count import search_sequential_allow_threads

executor = ThreadPoolExecutor(max_workers=2)

future_1 = executor.submit(
    word_count.search_sequential_allow_threads, contents, needle
)
future_2 = executor.submit(
    word_count.search_sequential_allow_threads, contents, needle
)
result_1 = future_1.result()
result_2 = future_2.result()
</code></pre>
<h2 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h2>
<p>Let's benchmark the <code>word-count</code> example to verify that we really did unlock parallelism with PyO3.</p>
<p>We are using <code>pytest-benchmark</code> to benchmark four word count functions:</p>
<ol>
<li>Pure Python version</li>
<li>Rust parallel version</li>
<li>Rust sequential version</li>
<li>Rust sequential version executed twice with two Python threads</li>
</ol>
<p>The benchmark script can be found <a href="https://github.com/PyO3/pyo3/blob/main/examples/word-count/tests/test_word_count.py">here</a>, and we can run <code>nox</code> in the <code>word-count</code> folder to benchmark these functions.</p>
<p>While the results of the benchmark of course depend on your machine, the relative results should be similar to this (mid 2020):</p>
<pre><code class="language-text">-------------------------------------------------------------------------------------------------- benchmark: 4 tests -------------------------------------------------------------------------------------------------
Name (time in ms)                                          Min                Max               Mean            StdDev             Median               IQR            Outliers       OPS            Rounds  Iterations
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
test_word_count_rust_parallel                           1.7315 (1.0)       4.6495 (1.0)       1.9972 (1.0)      0.4299 (1.0)       1.8142 (1.0)      0.2049 (1.0)         40;46  500.6943 (1.0)         375           1
test_word_count_rust_sequential                         7.3348 (4.24)     10.3556 (2.23)      8.0035 (4.01)     0.7785 (1.81)      7.5597 (4.17)     0.8641 (4.22)         26;5  124.9457 (0.25)        121           1
test_word_count_rust_sequential_twice_with_threads      7.9839 (4.61)     10.3065 (2.22)      8.4511 (4.23)     0.4709 (1.10)      8.2457 (4.55)     0.3927 (1.92)        17;17  118.3274 (0.24)        114           1
test_word_count_python_sequential                      27.3985 (15.82)    45.4527 (9.78)     28.9604 (14.50)    4.1449 (9.64)     27.5781 (15.20)    0.4638 (2.26)          3;5   34.5299 (0.07)         35           1
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre>
<p>You can see that the Python threaded version is not much slower than the Rust sequential version, which means compared to an execution on a single CPU core the speed has doubled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>PyO3's attributes (<code>#[pyclass]</code>, <code>#[pymodule]</code>, etc.) are <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a>, which means that they rewrite the source of the annotated item. You can view the generated source with the following command, which also expands a few other things:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>(You might need to install <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> if you don't already have it.)</p>
<p>You can also debug classic <code>!</code>-macros by adding <code>-Z trace-macros</code>:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded -Z trace-macros &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>See <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> for a more elaborate version of those commands.</p>
<h2 id="running-with-valgrind"><a class="header" href="#running-with-valgrind">Running with Valgrind</a></h2>
<p>Valgrind is a tool to detect memory management bugs such as memory leaks.</p>
<p>You first need to install a debug build of Python, otherwise Valgrind won't produce usable results. In Ubuntu there's e.g. a <code>python3-dbg</code> package.</p>
<p>Activate an environment with the debug interpreter and recompile. If you're on Linux, use <code>ldd</code> with the name of your binary and check that you're linking e.g. <code>libpython3.7d.so.1.0</code> instead of <code>libpython3.7.so.1.0</code>.</p>
<p><a href="https://raw.githubusercontent.com/python/cpython/master/Misc/valgrind-python.supp">Download the suppressions file for cpython</a>.</p>
<p>Run Valgrind with <code>valgrind --suppressions=valgrind-python.supp ./my-command --with-options</code></p>
<h2 id="getting-a-stacktrace"><a class="header" href="#getting-a-stacktrace">Getting a stacktrace</a></h2>
<p>The best start to investigate a crash such as an segmentation fault is a backtrace. You can set <code>RUST_BACKTRACE=1</code> as an environment variable to get the stack trace on a <code>panic!</code>. Alternatively you can use a debugger such as <code>gdb</code> to explore the issue. Rust provides a wrapper, <code>rust-gdb</code>, which has pretty-printers for inspecting Rust variables. Since PyO3 uses <code>cdylib</code> for Python shared objects, it does not receive the pretty-print debug hooks in <code>rust-gdb</code> (<a href="https://github.com/rust-lang/rust/issues/96365">rust-lang/rust#96365</a>). The mentioned issue contains a workaround for enabling pretty-printers in this case.</p>
<ul>
<li>Link against a debug build of python as described in the previous chapter</li>
<li>Run <code>rust-gdb &lt;my-binary&gt;</code></li>
<li>Set a breakpoint (<code>b</code>) on <code>rust_panic</code> if you are investigating a <code>panic!</code></li>
<li>Enter <code>r</code> to run</li>
<li>After the crash occurred, enter <code>bt</code> or <code>bt full</code> to print the stacktrace</li>
</ul>
<p>Often it is helpful to run a small piece of Python code to exercise a section of Rust.</p>
<pre><code class="language-console">rust-gdb --args python -c &quot;import my_package; my_package.sum_to_string(1, 2)&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-reference"><a class="header" href="#features-reference">Features Reference</a></h1>
<p>PyO3 provides a number of Cargo features to customise functionality. This chapter of the guide provides detail on each of them.</p>
<p>By default, only the <code>macros</code> feature is enabled.</p>
<h2 id="features-for-extension-module-authors"><a class="header" href="#features-for-extension-module-authors">Features for extension module authors</a></h2>
<h3 id="extension-module"><a class="header" href="#extension-module"><code>extension-module</code></a></h3>
<p>This feature is required when building a Python extension module using PyO3.</p>
<p>It tells PyO3's build script to skip linking against <code>libpython.so</code> on Unix platforms, where this must not be done.</p>
<p>See the <a href="building_and_distribution.html#linking">building and distribution</a> section for further detail.</p>
<h3 id="abi3"><a class="header" href="#abi3"><code>abi3</code></a></h3>
<p>This feature is used when building Python extension modules to create wheels which are compatible with multiple Python versions.</p>
<p>It restricts PyO3's API to a subset of the full Python API which is guaranteed by <a href="https://www.python.org/dev/peps/pep-0384/">PEP 384</a> to be forwards-compatible with future Python versions.</p>
<p>See the <a href="building_and_distribution.html#py_limited_apiabi3">building and distribution</a> section for further detail.</p>
<h3 id="the-abi3-pyxy-features"><a class="header" href="#the-abi3-pyxy-features">The <code>abi3-pyXY</code> features</a></h3>
<p>(<code>abi3-py37</code>, <code>abi3-py38</code>, <code>abi3-py39</code>, and <code>abi3-py310</code>)</p>
<p>These features are extensions of the <code>abi3</code> feature to specify the exact minimum Python version which the multiple-version-wheel will support.</p>
<p>See the <a href="building_and_distribution.html#minimum-python-version-for-abi3">building and distribution</a> section for further detail.</p>
<h3 id="generate-import-lib"><a class="header" href="#generate-import-lib"><code>generate-import-lib</code></a></h3>
<p>This experimental feature is used to generate import libraries for Python DLL
for MinGW-w64 and MSVC (cross-)compile targets.</p>
<p>Enabling it allows to (cross-)compile extension modules to any Windows targets
without having to install the Windows Python distribution files for the target.</p>
<p>See the <a href="building_and_distribution.html#building-abi3-extensions-without-a-python-interpreter">building and distribution</a>
section for further detail.</p>
<h2 id="features-for-embedding-python-in-rust"><a class="header" href="#features-for-embedding-python-in-rust">Features for embedding Python in Rust</a></h2>
<h3 id="auto-initialize"><a class="header" href="#auto-initialize"><code>auto-initialize</code></a></h3>
<p>This feature changes <a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.with_gil"><code>Python::with_gil</code></a> and <a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.acquire_gil"><code>Python::acquire_gil</code></a> to automatically initialize a Python interpreter (by calling <a href="https://pyo3.rs/main/doc/pyo3/fn.prepare_freethreaded_python.html"><code>prepare_freethreaded_python</code></a>) if needed.</p>
<p>If you do not enable this feature, you should call <code>pyo3::prepare_freethreaded_python()</code> before attempting to call any other Python APIs.</p>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="macros-1"><a class="header" href="#macros-1"><code>macros</code></a></h3>
<p>This feature enables a dependency on the <code>pyo3-macros</code> crate, which provides the procedural macros portion of PyO3's API:</p>
<ul>
<li><code>#[pymodule]</code></li>
<li><code>#[pyfunction]</code></li>
<li><code>#[pyclass]</code></li>
<li><code>#[pymethods]</code></li>
<li><code>#[derive(FromPyObject)]</code></li>
</ul>
<p>It also provides the <code>py_run!</code> macro.</p>
<p>These macros require a number of dependencies which may not be needed by users who just need PyO3 for Python FFI. Disabling this feature enables faster builds for those users, as these dependencies will not be built if this feature is disabled.</p>
<blockquote>
<p>This feature is enabled by default. To disable it, set <code>default-features = false</code> for the <code>pyo3</code> entry in your Cargo.toml.</p>
</blockquote>
<h3 id="multiple-pymethods"><a class="header" href="#multiple-pymethods"><code>multiple-pymethods</code></a></h3>
<p>This feature enables a dependency on <code>inventory</code>, which enables each <code>#[pyclass]</code> to have more than one <code>#[pymethods]</code> block.</p>
<p>Most users should only need a single <code>#[pymethods]</code> per <code>#[pyclass]</code>. In addition, not all platforms (e.g. Wasm) are supported by <code>inventory</code>. For this reason this feature is not enabled by default, meaning fewer dependencies and faster compilation for the majority of users.</p>
<p>See <a href="class.html#implementation-details">the <code>#[pyclass]</code> implementation details</a> for more information.</p>
<h3 id="pyproto"><a class="header" href="#pyproto"><code>pyproto</code></a></h3>
<p>This feature enables the <code>#[pyproto]</code> macro, which is a deprecated alternative to <code>#[pymethods]</code> for defining magic methods such as <code>__eq__</code>.</p>
<h3 id="nightly"><a class="header" href="#nightly"><code>nightly</code></a></h3>
<p>The <code>nightly</code> feature needs the nightly Rust compiler. This allows PyO3 to use the auto_traits and negative_impls features to fix the <code>Python::allow_threads</code> function.</p>
<h3 id="resolve-config"><a class="header" href="#resolve-config"><code>resolve-config</code></a></h3>
<p>The <code>resolve-config</code> feature of the <code>pyo3-build-config</code> crate controls whether that crate's
build script automatically resolves a Python interpreter / build configuration. This feature is primarily useful when building PyO3
itself. By default this feature is not enabled, meaning you can freely use <code>pyo3-build-config</code> as a standalone library to read or write PyO3 build configuration files or resolve metadata about a Python interpreter.</p>
<h2 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional Dependencies</a></h2>
<p>These features enable conversions between Python types and types from other Rust crates, enabling easy access to the rest of the Rust ecosystem.</p>
<h3 id="anyhow"><a class="header" href="#anyhow"><code>anyhow</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/anyhow">anyhow</a>. Enables a conversion from <a href="https://docs.rs/anyhow">anyhow</a>’s <a href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html"><code>Error</code></a> type to <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html"><code>PyErr</code></a>, for easy error handling.</p>
<h3 id="eyre"><a class="header" href="#eyre"><code>eyre</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/eyre">eyre</a>. Enables a conversion from <a href="https://docs.rs/eyre">eyre</a>’s <a href="https://docs.rs/eyre/latest/eyre/struct.Report.html"><code>Report</code></a> type to <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html"><code>PyErr</code></a>, for easy error handling.</p>
<h3 id="hashbrown"><a class="header" href="#hashbrown"><code>hashbrown</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/hashbrown">hashbrown</a> and enables conversions into its <a href="https://docs.rs/hashbrown/latest/hashbrown/struct.HashMap.html"><code>HashMap</code></a> and <a href="https://docs.rs/hashbrown/latest/hashbrown/struct.HashSet.html"><code>HashSet</code></a> types.</p>
<h3 id="indexmap"><a class="header" href="#indexmap"><code>indexmap</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/indexmap">indexmap</a> and enables conversions into its <a href="https://docs.rs/indexmap/latest/indexmap/map/struct.IndexMap.html"><code>IndexMap</code></a> type.</p>
<h3 id="num-bigint"><a class="header" href="#num-bigint"><code>num-bigint</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/num-bigint">num-bigint</a> and enables conversions into its <a href="https://docs.rs/num-bigint/latest/num_bigint/struct.BigInt.html"><code>BigInt</code></a> and <a href="https://docs.rs/num-bigint/latest/num_bigint/struct.BigUInt.html"><code>BigUint</code></a> types.</p>
<h3 id="num-complex"><a class="header" href="#num-complex"><code>num-complex</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/num-complex">num-complex</a> and enables conversions into its <a href="https://docs.rs/num-complex/latest/num_complex/struct.Complex.html"><code>Complex</code></a> type.</p>
<h3 id="serde"><a class="header" href="#serde"><code>serde</code></a></h3>
<p>Enables (de)serialization of Py<T> objects via <a href="https://serde.rs/">serde</a>.
This allows to use <a href="https://serde.rs/derive.html"><code>#[derive(Serialize, Deserialize)</code></a> on structs that hold references to <code>#[pyclass]</code> instances</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(feature = &quot;serde&quot;)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">mod serde_only {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span>
#[pyclass]
#[derive(Serialize, Deserialize)]
struct Permission {
    name: String
}

#[pyclass]
#[derive(Serialize, Deserialize)]
struct User {
    username: String,
    permissions: Vec&lt;Py&lt;Permission&gt;&gt;
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Rust and Python have very different notions of memory management.  Rust has
a strict memory model with concepts of ownership, borrowing, and lifetimes,
where memory is freed at predictable points in program execution.  Python has
a looser memory model in which variables are reference-counted with shared,
mutable state by default. A global interpreter lock (GIL) is needed to prevent
race conditions, and a garbage collector is needed to break reference cycles.
Memory in Python is freed eventually by the garbage collector, but not usually
in a predictable way.</p>
<p>PyO3 bridges the Rust and Python memory models with two different strategies for
accessing memory allocated on Python's heap from inside Rust.  These are
GIL-bound, or &quot;owned&quot; references, and GIL-independent <code>Py&lt;Any&gt;</code> smart pointers.</p>
<h2 id="gil-bound-memory"><a class="header" href="#gil-bound-memory">GIL-bound Memory</a></h2>
<p>PyO3's GIL-bound, &quot;owned references&quot; (<code>&amp;PyAny</code> etc.) make PyO3 more ergonomic to
use by ensuring that their lifetime can never be longer than the duration the
Python GIL is held.  This means that most of PyO3's API can assume the GIL is
held. (If PyO3 could not assume this, every PyO3 API would need to take a
<code>Python</code> GIL token to prove that the GIL is held.)  This allows us to write
very simple and easy-to-understand programs like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    let hello: &amp;PyString = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
    println!(&quot;Python says: {}&quot;, hello);
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>Internally, calling <code>Python::with_gil()</code> or <code>Python::acquire_gil()</code> creates a
<code>GILPool</code> which owns the memory pointed to by the reference.  In the example
above, the lifetime of the reference <code>hello</code> is bound to the <code>GILPool</code>.  When
the <code>with_gil()</code> closure ends or the <code>GILGuard</code> from <code>acquire_gil()</code> is dropped,
the <code>GILPool</code> is also dropped and the Python reference counts of the variables
it owns are decreased, releasing them to the Python garbage collector.  Most
of the time we don't have to think about this, but consider the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    for _ in 0..10 {
        let hello: &amp;PyString = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
        println!(&quot;Python says: {}&quot;, hello);
    }
    // There are 10 copies of `hello` on Python's heap here.
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>We might assume that the <code>hello</code> variable's memory is freed at the end of each
loop iteration, but in fact we create 10 copies of <code>hello</code> on Python's heap.
This may seem surprising at first, but it is completely consistent with Rust's
memory model.  The <code>hello</code> variable is dropped at the end of each loop, but it
is only a reference to the memory owned by the <code>GILPool</code>, and its lifetime is
bound to the <code>GILPool</code>, not the for loop.  The <code>GILPool</code> isn't dropped until
the end of the <code>with_gil()</code> closure, at which point the 10 copies of <code>hello</code>
are finally released to the Python garbage collector.</p>
<p>In general we don't want unbounded memory growth during loops!  One workaround
is to acquire and release the GIL with each iteration of the loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>for _ in 0..10 {
    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
        let hello: &amp;PyString = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
        println!(&quot;Python says: {}&quot;, hello);
        Ok(())
    })?; // only one copy of `hello` at a time
}
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>It might not be practical or performant to acquire and release the GIL so many
times.  Another workaround is to work with the <code>GILPool</code> object directly, but
this is unsafe.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    for _ in 0..10 {
        let pool = unsafe { py.new_pool() };
        let py = pool.python();
        let hello: &amp;PyString = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
        println!(&quot;Python says: {}&quot;, hello);
    }
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>The unsafe method <code>Python::new_pool</code> allows you to create a nested <code>GILPool</code>
from which you can retrieve a new <code>py: Python</code> GIL token.  Variables created
with this new GIL token are bound to the nested <code>GILPool</code> and will be released
when the nested <code>GILPool</code> is dropped.  Here, the nested <code>GILPool</code> is dropped
at the end of each loop iteration, before the <code>with_gil()</code> closure ends.</p>
<p>When doing this, you must be very careful to ensure that once the <code>GILPool</code> is
dropped you do not retain access to any owned references created after the
<code>GILPool</code> was created.  Read the
<a href="https://pyo3.rs/main/doc/pyo3/prelude/struct.Python.html#method.new_pool">documentation for <code>Python::new_pool()</code></a>
for more information on safety.</p>
<h2 id="gil-independent-memory"><a class="header" href="#gil-independent-memory">GIL-independent Memory</a></h2>
<p>Sometimes we need a reference to memory on Python's heap that can outlive the
GIL.  Python's <code>Py&lt;PyAny&gt;</code> is analogous to <code>Rc&lt;T&gt;</code>, but for variables whose
memory is allocated on Python's heap.  Cloning a <code>Py&lt;PyAny&gt;</code> increases its
internal reference count just like cloning <code>Rc&lt;T&gt;</code>.  The smart pointer can
outlive the GIL from which it was created.  It isn't magic, though.  We need to
reacquire the GIL to access the memory pointed to by the <code>Py&lt;PyAny&gt;</code>.</p>
<p>What happens to the memory when the last <code>Py&lt;PyAny&gt;</code> is dropped and its
reference count reaches zero?  It depends whether or not we are holding the GIL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    let hello: Py&lt;PyString&gt; = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
    println!(&quot;Python says: {}&quot;, hello.as_ref(py));
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>At the end of the <code>Python::with_gil()</code> closure <code>hello</code> is dropped, and then the
GIL is dropped.  Since <code>hello</code> is dropped while the GIL is still held by the
current thread, its memory is released to the Python garbage collector
immediately.</p>
<p>This example wasn't very interesting.  We could have just used a GIL-bound
<code>&amp;PyString</code> reference.  What happens when the last <code>Py&lt;Any&gt;</code> is dropped while
we are <em>not</em> holding the GIL?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>let hello: Py&lt;PyString&gt; = Python::with_gil(|py| {
    py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()
})?;
// Do some stuff...
// Now sometime later in the program we want to access `hello`.
Python::with_gil(|py| {
    println!(&quot;Python says: {}&quot;, hello.as_ref(py));
});
// Now we're done with `hello`.
drop(hello); // Memory *not* released here.
// Sometime later we need the GIL again for something...
Python::with_gil(|py|
    // Memory for `hello` is released here.
<span class="boring">()
</span>);
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>When <code>hello</code> is dropped <em>nothing</em> happens to the pointed-to memory on Python's
heap because nothing <em>can</em> happen if we're not holding the GIL.  Fortunately,
the memory isn't leaked.  PyO3 keeps track of the memory internally and will
release it the next time we acquire the GIL.</p>
<p>We can avoid the delay in releasing memory if we are careful to drop the
<code>Py&lt;Any&gt;</code> while the GIL is held.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>let hello: Py&lt;PyString&gt; = Python::with_gil(|py| {
    py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()
})?;
// Do some stuff...
// Now sometime later in the program:
Python::with_gil(|py| {
    println!(&quot;Python says: {}&quot;, hello.as_ref(py));
    drop(hello); // Memory released here.
});
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>We could also have used <code>Py::into_ref()</code>, which consumes <code>self</code>, instead of
<code>Py::as_ref()</code>.  But note that in addition to being slower than <code>as_ref()</code>,
<code>into_ref()</code> binds the memory to the lifetime of the <code>GILPool</code>, which means
that rather than being released immediately, the memory will not be released
until the GIL is dropped.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>let hello: Py&lt;PyString&gt; = Python::with_gil(|py| {
    py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()
})?;
// Do some stuff...
// Now sometime later in the program:
Python::with_gil(|py| {
    println!(&quot;Python says: {}&quot;, hello.into_ref(py));
    // Memory not released yet.
    // Do more stuff...
    // Memory released here at end of `with_gil()` closure.
});
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced topics</a></h1>
<h2 id="ffi"><a class="header" href="#ffi">FFI</a></h2>
<p>PyO3 exposes much of Python's C API through the <code>ffi</code> module.</p>
<p>The C API is naturally unsafe and requires you to manage reference counts, errors and specific invariants yourself. Please refer to the <a href="https://docs.python.org/3/c-api/">C API Reference Manual</a> and <a href="https://doc.rust-lang.org/nightly/nomicon/ffi.html">The Rustonomicon</a> before using any function from that API.</p>
<h2 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h2>
<p>PyO3's <code>&amp;PyAny</code> &quot;owned references&quot; and <code>Py&lt;PyAny&gt;</code> smart pointers are used to
access memory stored in Python's heap.  This memory sometimes lives for longer
than expected because of differences in Rust and Python's memory models.  See
the chapter on <a href="./memory.html">memory management</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-distribution"><a class="header" href="#building-and-distribution">Building and Distribution</a></h1>
<p>This chapter of the guide goes into detail on how to build and distribute projects using PyO3. The way to achieve this is very different depending on whether the project is a Python module implemented in Rust, or a Rust binary embedding Python. For both types of project there are also common problems such as the Python version to build for and the <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linker</a> arguments to use.</p>
<p>The material in this chapter is intended for users who have already read the PyO3 <a href="building_and_distribution.html#index.md">README</a>. It covers in turn the choices that can be made for Python modules and for Rust binaries. There is also a section at the end about cross-compiling projects using PyO3.</p>
<p>There is an additional sub-chapter dedicated to <a href="./building_and_distribution/multiple_python_versions.html">supporting multiple Python versions</a>.</p>
<h2 id="configuring-the-python-version"><a class="header" href="#configuring-the-python-version">Configuring the Python version</a></h2>
<p>PyO3 uses a build script (backed by the <a href="https://github.com/PyO3/pyo3/tree/main/pyo3-build-config"><code>pyo3-build-config</code></a> crate) to determine the Python version and set the correct linker arguments. By default it will attempt to use the following in order:</p>
<ul>
<li>Any active Python virtualenv.</li>
<li>The <code>python</code> executable (if it's a Python 3 interpreter).</li>
<li>The <code>python3</code> executable.</li>
</ul>
<p>You can override the Python interpreter by setting the <code>PYO3_PYTHON</code> environment variable, e.g. <code>PYO3_PYTHON=python3.7</code>, <code>PYO3_PYTHON=/usr/bin/python3.9</code>, or even a PyPy interpreter <code>PYO3_PYTHON=pypy3</code>.</p>
<p>Once the Python interpreter is located, <code>pyo3-build-config</code> executes it to query the information in the <code>sysconfig</code> module which is needed to configure the rest of the compilation.</p>
<p>To validate the configuration which PyO3 will use, you can run a compilation with the environment variable <code>PYO3_PRINT_CONFIG=1</code> set. An example output of doing this is shown below:</p>
<pre><code class="language-console">$ PYO3_PRINT_CONFIG=1 cargo build
   Compiling pyo3 v0.14.1 (/home/david/dev/pyo3)
error: failed to run custom build command for `pyo3 v0.14.1 (/home/david/dev/pyo3)`

Caused by:
  process didn't exit successfully: `/home/david/dev/pyo3/target/debug/build/pyo3-7a8cf4fe22e959b7/build-script-build` (exit status: 101)
  --- stdout
  cargo:rerun-if-env-changed=PYO3_CROSS
  cargo:rerun-if-env-changed=PYO3_CROSS_LIB_DIR
  cargo:rerun-if-env-changed=PYO3_CROSS_PYTHON_VERSION
  cargo:rerun-if-env-changed=PYO3_PRINT_CONFIG

  -- PYO3_PRINT_CONFIG=1 is set, printing configuration and halting compile --
  implementation=CPython
  version=3.8
  shared=true
  abi3=false
  lib_name=python3.8
  lib_dir=/usr/lib
  executable=/usr/bin/python
  pointer_width=64
  build_flags=
  suppress_build_script_link_lines=false
</code></pre>
<h3 id="advanced-config-files"><a class="header" href="#advanced-config-files">Advanced: config files</a></h3>
<p>If you save the above output config from <code>PYO3_PRINT_CONFIG</code> to a file, it is possible to manually override the contents and feed it back into PyO3 using the <code>PYO3_CONFIG_FILE</code> env var.</p>
<p>If your build environment is unusual enough that PyO3's regular configuration detection doesn't work, using a config file like this will give you the flexibility to make PyO3 work for you. To see the full set of options supported, see the documentation for the <a href="https://docs.rs/pyo3-build-config/latest/pyo3_build_config/struct.InterpreterConfig.html"><code>InterpreterConfig</code> struct</a>.</p>
<h2 id="building-python-extension-modules"><a class="header" href="#building-python-extension-modules">Building Python extension modules</a></h2>
<p>Python extension modules need to be compiled differently depending on the OS (and architecture) that they are being compiled for. As well as multiple OSes (and architectures), there are also many different Python versions which are actively supported. Packages uploaded to <a href="https://pypi.org/">PyPI</a> usually want to upload prebuilt &quot;wheels&quot; covering many OS/arch/version combinations so that users on all these different platforms don't have to compile the package themselves. Package vendors can opt-in to the &quot;abi3&quot; limited Python API which allows their wheels to be used on multiple Python versions, reducing the number of wheels they need to compile, but restricts the functionality they can use.</p>
<p>There are many ways to go about this: it is possible to use <code>cargo</code> to build the extension module (along with some manual work, which varies with OS). The PyO3 ecosystem has two packaging tools, <a href="https://github.com/PyO3/maturin"><code>maturin</code></a> and <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a>, which abstract over the OS difference and also support building wheels for PyPI upload.</p>
<p>PyO3 has some Cargo features to configure projects for building Python extension modules:</p>
<ul>
<li>The <code>extension-module</code> feature, which must be enabled when building Python extension modules.</li>
<li>The <code>abi3</code> feature and its version-specific <code>abi3-pyXY</code> companions, which are used to opt-in to the limited Python API in order to support multiple Python versions in a single wheel.</li>
</ul>
<p>This section describes each of these packaging tools before describiing how to build manually without them. It then proceeds with an explanation of the <code>extension-module</code> feature. Finally, there is a section describing PyO3's <code>abi3</code> features.</p>
<h3 id="packaging-tools"><a class="header" href="#packaging-tools">Packaging tools</a></h3>
<p>The PyO3 ecosystem has two main choices to abstract the process of developing Python extension modules:</p>
<ul>
<li><a href="https://github.com/PyO3/maturin"><code>maturin</code></a> is a command-line tool to build, package and upload Python modules. It makes opinionated choices about project layout meaning it needs very little configuration. This makes it a great choice for users who are building a Python extension from scratch and don't need flexibility.</li>
<li><a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> is an add-on for <code>setuptools</code> which adds extra keyword arguments to the <code>setup.py</code> configuration file. It requires more configuration than <code>maturin</code>, however this gives additional flexibility for users adding Rust to an existing Python package that can't satisfy <code>maturin</code>'s constraints.</li>
</ul>
<p>Consult each project's documentation for full details on how to get started using them and how to upload wheels to PyPI.</p>
<p>There are also <a href="https://github.com/PyO3/pyo3/tree/main/examples/maturin-starter"><code>maturin-starter</code></a> and <a href="https://github.com/PyO3/pyo3/tree/main/examples/setuptools-rust-starter"><code>setuptools-rust-starter</code></a> examples in the PyO3 repository.</p>
<h3 id="manual-builds"><a class="header" href="#manual-builds">Manual builds</a></h3>
<p>To build a PyO3-based Python extension manually, start by running <code>cargo build</code> as normal in a library project which uses PyO3's <code>extension-module</code> feature and has the <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field"><code>cdylib</code> crate type</a>.</p>
<p>Once built, symlink (or copy) and rename the shared library from Cargo's <code>target/</code> directory to your desired output directory:</p>
<ul>
<li>on macOS, rename <code>libyour_module.dylib</code> to <code>your_module.so</code>.</li>
<li>on Windows, rename  <code>libyour_module.dll</code> to <code>your_module.pyd</code>.</li>
<li>on Linux, rename <code>libyour_module.so</code> to <code>your_module.so</code>.</li>
</ul>
<p>You can then open a Python shell in the output directory and you'll be able to run <code>import your_module</code>.</p>
<p>If you're packaging your library for redistribution, you should indicated the Python interpreter your library is compiled for by including the <a href="building_and_distribution.html#platform-tags">platform tag</a> in its name. This prevents incompatible interpreters from trying to import your library. If you're compiling for PyPy you <em>must</em> include the platform tag, or PyPy will ignore the module.</p>
<p>See, as an example, Bazel rules to build PyO3 on Linux at https://github.com/TheButlah/rules_pyo3.</p>
<h4 id="platform-tags"><a class="header" href="#platform-tags">Platform tags</a></h4>
<p>Rather than using just the <code>.so</code> or <code>.pyd</code> extension suggested above (depending on OS), uou can prefix the shared library extension with a platform tag to indicate the interpreter it is compatible with. You can query your interpreter's platform tag from the <code>sysconfig</code> module. Some example outputs of this are seen below:</p>
<pre><code class="language-bash"># CPython 3.10 on macOS
.cpython-310-darwin.so

# PyPy 7.3 (Python 3.8) on Linux
$ python -c 'import sysconfig; print(sysconfig.get_config_var(&quot;EXT_SUFFIX&quot;))'
.pypy38-pp73-x86_64-linux-gnu.so
</code></pre>
<p>So, for example, a valid module library name on CPython 3.10 for macOS is <code>your_module.cpython-310-darwin.so</code>, and its equivalent when compiled for PyPy 7.3 on Linux would be <code>your_module.pypy38-pp73-x86_64-linux-gnu.so</code>.</p>
<p>See <a href="https://peps.python.org/pep-3149/">PEP 3149</a> for more background on platform tags.</p>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>On macOS, because the <code>extension-module</code> feature disables linking to <code>libpython</code> (<a href="building_and_distribution.html#the-extension-module-feature">see the next section</a>), some additional linker arguments need to be set. <code>maturin</code> and <code>setuptools-rust</code> both pass these arguments for PyO3 automatically, but projects using manual builds will need to set these directly in order to support macOS.</p>
<p>The easiest way to set the correct linker arguments is to add a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> with the following content:</p>
<pre><code class="language-rust ignore">fn main() {
  pyo3_build_config::add_extension_module_link_args();
}
</code></pre>
<p>Remember to also add <code>pyo3-build-config</code> to the <code>build-dependencies</code> section in <code>Cargo.toml</code>.</p>
<p>An alternative to using <code>pyo3-build-config</code> is add the following to a cargo configuration file (e.g. <code>.cargo/config.toml</code>):</p>
<pre><code class="language-toml">[target.x86_64-apple-darwin]
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-undefined&quot;,
  &quot;-C&quot;, &quot;link-arg=dynamic_lookup&quot;,
]

[target.aarch64-apple-darwin]
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-undefined&quot;,
  &quot;-C&quot;, &quot;link-arg=dynamic_lookup&quot;,
]
</code></pre>
<h3 id="the-extension-module-feature"><a class="header" href="#the-extension-module-feature">The <code>extension-module</code> feature</a></h3>
<p>PyO3's <code>extension-module</code> feature is used to disable <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linking</a> to <code>libpython</code> on unix targets.</p>
<p>This is necessary because by default PyO3 links to <code>libpython</code>. This makes binaries, tests, and examples &quot;just work&quot;. However, Python extensions on unix must not link to libpython for <a href="https://www.python.org/dev/peps/pep-0513/">manylinux</a> compliance.</p>
<p>The downside of not linking to <code>libpython</code> is that binaries, tests, and examples (which usually embed Python) will fail to build. If you have an extension module as well as other outputs in a single project, you need to use optional Cargo features to disable the <code>extension-module</code> when you're not building the extension module. See <a href="faq.html#i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">the FAQ</a> for an example workaround.</p>
<h3 id="py_limited_apiabi3"><a class="header" href="#py_limited_apiabi3"><code>Py_LIMITED_API</code>/<code>abi3</code></a></h3>
<p>By default, Python extension modules can only be used with the same Python version they were compiled against. For example, an extension module built for Python 3.5 can't be imported in Python 3.8. <a href="https://www.python.org/dev/peps/pep-0384/">PEP 384</a> introduced the idea of the limited Python API, which would have a stable ABI enabling extension modules built with it to be used against multiple Python versions. This is also known as <code>abi3</code>.</p>
<p>The advantage of building extension modules using the limited Python API is that package vendors only need to build and distribute a single copy (for each OS / architecture), and users can install it on all Python versions from the <a href="building_and_distribution.html#minimum-python-version-for-abi3">minimum version</a> and up. The downside of this is that PyO3 can't use optimizations which rely on being compiled against a known exact Python version. It's up to you to decide whether this matters for your extension module. It's also possible to design your extension module such that you can distribute <code>abi3</code> wheels but allow users compiling from source to benefit from additional optimizations - see the <a href="./building_and_distribution/multiple_python_versions.html">support for multiple python versions</a> section of this guide, in particular the <code>#[cfg(Py_LIMITED_API)]</code> flag.</p>
<p>There are three steps involved in making use of <code>abi3</code> when building Python packages as wheels:</p>
<ol>
<li>Enable the <code>abi3</code> feature in <code>pyo3</code>. This ensures <code>pyo3</code> only calls Python C-API functions which are part of the stable API, and on Windows also ensures that the project links against the correct shared object (no special behavior is required on other platforms):</li>
</ol>
<pre><code class="language-toml">[dependencies]
pyo3 = { git = &quot;https://github.com/pyo3/pyo3&quot;, features = [&quot;abi3&quot;] }
</code></pre>
<ol start="2">
<li>
<p>Ensure that the built shared objects are correctly marked as <code>abi3</code>. This is accomplished by telling your build system that you're using the limited API. <a href="https://github.com/PyO3/maturin"><code>maturin</code></a> &gt;= 0.9.0 and <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> &gt;= 0.11.4 support <code>abi3</code> wheels.
See the <a href="https://github.com/PyO3/maturin/pull/353">corresponding</a> <a href="https://github.com/PyO3/setuptools-rust/pull/82">PRs</a> for more.</p>
</li>
<li>
<p>Ensure that the <code>.whl</code> is correctly marked as <code>abi3</code>. For projects using <code>setuptools</code>, this is accomplished by passing <code>--py-limited-api=cp3x</code> (where <code>x</code> is the minimum Python version supported by the wheel, e.g. <code>--py-limited-api=cp35</code> for Python 3.5) to <code>setup.py bdist_wheel</code>.</p>
</li>
</ol>
<h4 id="minimum-python-version-for-abi3"><a class="header" href="#minimum-python-version-for-abi3">Minimum Python version for <code>abi3</code></a></h4>
<p>Because a single <code>abi3</code> wheel can be used with many different Python versions, PyO3 has feature flags <code>abi3-py37</code>, <code>abi3-py38</code>, <code>abi3-py39</code> etc. to set the minimum required Python version for your <code>abi3</code> wheel.
For example, if you set the <code>abi3-py37</code> feature, your extension wheel can be used on all Python 3 versions from Python 3.7 and up. <code>maturin</code> and <code>setuptools-rust</code> will give the wheel a name like <code>my-extension-1.0-cp37-abi3-manylinux2020_x86_64.whl</code>.</p>
<p>As your extension module may be run with multiple different Python versions you may occasionally find you need to check the Python version at runtime to customize behavior. See <a href="./building_and_distribution/multiple_python_versions.html#checking-the-python-version-at-runtime">the relevant section of this guide</a> on supporting multiple Python versions at runtime.</p>
<p>PyO3 is only able to link your extension module to api3 version up to and including your host Python version. E.g., if you set <code>abi3-py38</code> and try to compile the crate with a host of Python 3.7, the build will fail.</p>
<blockquote>
<p>Note: If you set more that one of these api version feature flags the lowest version always wins. For example, with both <code>abi3-py37</code> and <code>abi3-py38</code> set, PyO3 would build a wheel which supports Python 3.7 and up.</p>
</blockquote>
<h4 id="building-abi3-extensions-without-a-python-interpreter"><a class="header" href="#building-abi3-extensions-without-a-python-interpreter">Building <code>abi3</code> extensions without a Python interpreter</a></h4>
<p>As an advanced feature, you can build PyO3 wheel without calling Python interpreter with the environment variable <code>PYO3_NO_PYTHON</code> set.
Also, if the build host Python interpreter is not found or is too old or otherwise unusable,
PyO3 will still attempt to compile <code>abi3</code> extension modules after displaying a warning message.
On Unix-like systems this works unconditionally; on Windows you must also set the <code>RUSTFLAGS</code> environment variable
to contain <code>-L native=/path/to/python/libs</code> so that the linker can find <code>python3.lib</code>.</p>
<p>If the <code>python3.dll</code> import library is not available, an experimental <code>generate-import-lib</code> crate
feature may be enabled, and the required library will be created and used by PyO3 automatically.</p>
<p><em>Note</em>: MSVC targets require LLVM binutils (<code>llvm-dlltool</code>) to be available in <code>PATH</code> for
the automatic import library generation feature to work.</p>
<h4 id="missing-features"><a class="header" href="#missing-features">Missing features</a></h4>
<p>Due to limitations in the Python API, there are a few <code>pyo3</code> features that do
not work when compiling for <code>abi3</code>. These are:</p>
<ul>
<li><code>#[pyo3(text_signature = &quot;...&quot;)]</code> does not work on classes until Python 3.10 or greater.</li>
<li>The <code>dict</code> and <code>weakref</code> options on classes are not supported until Python 3.9 or greater.</li>
<li>The buffer API is not supported until Python 3.11 or greater.</li>
<li>Optimizations which rely on knowledge of the exact Python version compiled against.</li>
</ul>
<h2 id="embedding-python-in-rust"><a class="header" href="#embedding-python-in-rust">Embedding Python in Rust</a></h2>
<p>If you want to embed the Python interpreter inside a Rust program, there are two modes in which this can be done: dynamically and statically. We'll cover each of these modes in the following sections. Each of them affect how you must distribute your program. Instead of learning how to do this yourself, you might want to consider using a project like <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> to ship your application and all of its dependencies in a single file.</p>
<p>PyO3 automatically switches between the two linking modes depending on whether the Python distribution you have configured PyO3 to use (<a href="building_and_distribution.html#python-version">see above</a>) contains a shared library or a static library. The static library is most often seen in Python distributions compiled from source without the <code>--enable-shared</code> configuration option. For example, this is the default for <code>pyenv</code> on macOS.</p>
<h3 id="dynamically-embedding-the-python-interpreter"><a class="header" href="#dynamically-embedding-the-python-interpreter">Dynamically embedding the Python interpreter</a></h3>
<p>Embedding the Python interpreter dynamically is much easier than doing so statically. This is done by linking your program against a Python shared library (such as <code>libpython.3.9.so</code> on UNIX, or <code>python39.dll</code> on Windows). The implementation of the Python interpreter resides inside the shared library. This means that when the OS runs your Rust program it also needs to be able to find the Python shared library.</p>
<p>This mode of embedding works well for Rust tests which need access to the Python interpreter. It is also great for Rust software which is installed inside a Python virtualenv, because the virtualenv sets up appropriate environment variables to locate the correct Python shared library.</p>
<p>For distributing your program to non-technical users, you will have to consider including the Python shared library in your distribution as well as setting up wrapper scripts to set the right environment variables (such as <code>LD_LIBRARY_PATH</code> on UNIX, or <code>PATH</code> on Windows).</p>
<p>Note that PyPy cannot be embedded in Rust (or any other software). Support for this is tracked on the <a href="https://foss.heptapod.net/pypy/pypy/-/issues/3286">PyPy issue tracker</a>.</p>
<h3 id="statically-embedding-the-python-interpreter"><a class="header" href="#statically-embedding-the-python-interpreter">Statically embedding the Python interpreter</a></h3>
<p>Embedding the Python interpreter statically means including the contents of a Python static library directly inside your Rust binary. This means that to distribute your program you only need to ship your binary file: it contains the Python interpreter inside the binary!</p>
<p>On Windows static linking is almost never done, so Python distributions don't usually include a static library. The information below applies only to UNIX.</p>
<p>The Python static library is usually called <code>libpython.a</code>.</p>
<p>Static linking has a lot of complications, listed below. For these reasons PyO3 does not yet have first-class support for this embedding mode. See <a href="https://github.com/PyO3/pyo3/issues/416">issue 416 on PyO3's Github</a> for more information and to discuss any issues you encounter.</p>
<p>The <a href="features.html#auto-initialize"><code>auto-initialize</code></a> feature is deliberately disabled when embedding the interpreter statically because this is often unintentionally done by new users to PyO3 running test programs. Trying out PyO3 is much easier using dynamic embedding.</p>
<p>The known complications are:</p>
<ul>
<li>
<p>To import compiled extension modules (such as other Rust extension modules, or those written in C), your binary must have the correct linker flags set during compilation to export the original contents of <code>libpython.a</code> so that extensions can use them (e.g. <code>-Wl,--export-dynamic</code>).</p>
</li>
<li>
<p>The C compiler and flags which were used to create <code>libpython.a</code> must be compatible with your Rust compiler and flags, else you will experience compilation failures.</p>
<p>Significantly different compiler versions may see errors like this:</p>
<pre><code class="language-text">lto1: fatal error: bytecode stream in file 'rust-numpy/target/release/deps/libpyo3-6a7fb2ed970dbf26.rlib' generated with LTO version 6.0 instead of the expected 6.2
</code></pre>
<p>Mismatching flags may lead to errors like this:</p>
<pre><code class="language-text">/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/libpython3.9.a(zlibmodule.o): relocation R_X86_64_32 against `.data' can not be used when making a PIE object; recompile with -fPIE
</code></pre>
</li>
</ul>
<p>If you encounter these or other complications when linking the interpreter statically, discuss them on <a href="https://github.com/PyO3/pyo3/issues/416">issue 416 on PyO3's Github</a>. It is hoped that eventually that discussion will contain enough information and solutions that PyO3 can offer first-class support for static embedding.</p>
<h3 id="import-your-module-when-embedding-the-python-interpreter"><a class="header" href="#import-your-module-when-embedding-the-python-interpreter">Import your module when embedding the Python interpreter</a></h3>
<p>When you run your Rust binary with an embedded interpreter, any <code>#[pymodule]</code> created modules won't be accessible to import unless added to a table called <code>PyImport_Inittab</code> before the embedded interpreter is initialized. This will cause Python statements in your embedded interpreter such as <code>import your_new_module</code> to fail. You can call the macro <a href="https://pyo3.rs/main/doc/pyo3/macro.append_to_inittab.html"><code>append_to_inittab</code></a> with your module before initializing the Python interpreter to add the module function into that table. (The Python interpreter will be initialized by calling <code>prepare_freethreaded_python</code>, <code>with_embedded_interpreter</code>, or <code>Python::with_gil</code> with the <a href="features.html#auto-initialize"><code>auto-initialize</code></a> feature enabled.)</p>
<h2 id="cross-compiling"><a class="header" href="#cross-compiling">Cross Compiling</a></h2>
<p>Thanks to Rust's great cross-compilation support, cross-compiling using PyO3 is relatively straightforward. To get started, you'll need a few pieces of software:</p>
<ul>
<li>A toolchain for your target.</li>
<li>The appropriate options in your Cargo <code>.config</code> for the platform you're targeting and the toolchain you are using.</li>
<li>A Python interpreter that's already been compiled for your target (optional when building &quot;abi3&quot; extension modules).</li>
<li>A Python interpreter that is built for your host and available through the <code>PATH</code> or setting the <a href="building_and_distribution.html#python-version"><code>PYO3_PYTHON</code></a> variable (optional when building &quot;abi3&quot; extension modules).</li>
</ul>
<p>After you've obtained the above, you can build a cross-compiled PyO3 module by using Cargo's <code>--target</code> flag. PyO3's build script will detect that you are attempting a cross-compile based on your host machine and the desired target.</p>
<p>When cross-compiling, PyO3's build script cannot execute the target Python interpreter to query the configuration, so there are a few additional environment variables you may need to set:</p>
<ul>
<li><code>PYO3_CROSS</code>: If present this variable forces PyO3 to configure as a cross-compilation.</li>
<li><code>PYO3_CROSS_LIB_DIR</code>: This variable can be set to the directory containing the target's libpython DSO and the associated <code>_sysconfigdata*.py</code> file for Unix-like targets, or the Python DLL import libraries for the Windows target. This variable is only needed when the output binary must link to libpython explicitly (e.g. when targeting Windows and Android or embedding a Python interpreter), or when it is absolutely required to get the interpreter configuration from <code>_sysconfigdata*.py</code>.</li>
<li><code>PYO3_CROSS_PYTHON_VERSION</code>: Major and minor version (e.g. 3.9) of the target Python installation. This variable is only needed if PyO3 cannot determine the version to target from <code>abi3-py3*</code> features, or if <code>PYO3_CROSS_LIB_DIR</code> is not set, or if there are multiple versions of Python present in <code>PYO3_CROSS_LIB_DIR</code>.</li>
<li><code>PYO3_CROSS_PYTHON_IMPLEMENTATION</code>: Python implementation name (&quot;CPython&quot; or &quot;PyPy&quot;) of the target Python installation. CPython is assumed by default when this variable is not set, unless <code>PYO3_CROSS_LIB_DIR</code> is set for a Unix-like target and PyO3 can get the interpreter configuration from <code>_sysconfigdata*.py</code>.</li>
</ul>
<p>An experimental <code>pyo3</code> crate feature <code>generate-import-lib</code> enables the user to cross-compile
extension modules for Windows targets without setting the <code>PYO3_CROSS_LIB_DIR</code> environment
variable or providing any Windows Python library files. It uses an external <a href="https://docs.rs/python3-dll-a/latest/python3_dll_a/"><code>python3-dll-a</code></a> crate
to generate import libraries for the Python DLL for MinGW-w64 and MSVC compile targets.
<em>Note</em>: MSVC targets require LLVM binutils or MSVC build tools to be available on the host system.
More specifically, <code>python3-dll-a</code> requires <code>llvm-dlltool</code> or <code>lib.exe</code> executable to be present in <code>PATH</code> when
targeting <code>*-pc-windows-msvc</code>.</p>
<p>An example might look like the following (assuming your target's sysroot is at <code>/home/pyo3/cross/sysroot</code> and that your target is <code>armv7</code>):</p>
<pre><code class="language-sh">export PYO3_CROSS_LIB_DIR=&quot;/home/pyo3/cross/sysroot/usr/lib&quot;

cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>If there are multiple python versions at the cross lib directory and you cannot set a more precise location to include both the <code>libpython</code> DSO and <code>_sysconfigdata*.py</code> files, you can set the required version:</p>
<pre><code class="language-sh">export PYO3_CROSS_PYTHON_VERSION=3.8
export PYO3_CROSS_LIB_DIR=&quot;/home/pyo3/cross/sysroot/usr/lib&quot;

cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>Or another example with the same sys root but building for Windows:</p>
<pre><code class="language-sh">export PYO3_CROSS_PYTHON_VERSION=3.9
export PYO3_CROSS_LIB_DIR=&quot;/home/pyo3/cross/sysroot/usr/lib&quot;

cargo build --target x86_64-pc-windows-gnu
</code></pre>
<p>Any of the <code>abi3-py3*</code> features can be enabled instead of setting <code>PYO3_CROSS_PYTHON_VERSION</code> in the above examples.</p>
<p><code>PYO3_CROSS_LIB_DIR</code> can often be omitted when cross compiling extension modules for Unix and macOS targets,
or when cross compiling extension modules for Windows and the experimental <code>generate-import-lib</code>
crate feature is enabled.</p>
<p>The following resources may also be useful for cross-compiling:</p>
<ul>
<li><a href="https://github.com/japaric/rust-cross">github.com/japaric/rust-cross</a> is a primer on cross compiling Rust.</li>
<li><a href="https://github.com/rust-embedded/cross">github.com/rust-embedded/cross</a> uses Docker to make Rust cross-compilation easier.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supporting-multiple-python-versions"><a class="header" href="#supporting-multiple-python-versions">Supporting multiple Python versions</a></h1>
<p>PyO3 supports all actively-supported Python 3 and PyPy versions. As much as possible, this is done internally to PyO3 so that your crate's code does not need to adapt to the differences between each version. However, as Python features grow and change between versions, PyO3 cannot a completely identical API for every Python version. This may require you to add conditional compilation to your crate or runtime checks for the Python version.</p>
<p>This section of the guide first introduces the <code>pyo3-build-config</code> crate, which you can use as a <code>build-dependency</code> to add additional <code>#[cfg]</code> flags which allow you to support multiple Python versions at compile-time.</p>
<p>Second, we'll show how to check the Python version at runtime. This can be useful when building for multiple versions with the <code>abi3</code> feature, where the Python API compiled against is not always the same as the one in use.</p>
<h2 id="conditional-compilation-for-different-python-versions"><a class="header" href="#conditional-compilation-for-different-python-versions">Conditional compilation for different Python versions</a></h2>
<p>The <code>pyo3-build-config</code> exposes multiple <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html"><code>#[cfg]</code> flags</a> which can be used to conditionally compile code for a given Python version. PyO3 itself depends on this crate, so by using it you can be sure that you are configured correctly for the Python version PyO3 is building against.</p>
<p>This allows us to write code like the following</p>
<pre><code class="language-rust ignore">#[cfg(Py_3_7)]
fn function_only_supported_on_python_3_7_and_up() { }

#[cfg(not(Py_3_8))]
fn function_only_supported_before_python_3_8() { }

#[cfg(not(Py_LIMITED_API))]
fn function_incompatible_with_abi3_feature() { }
</code></pre>
<p>The following sections first show how to add these <code>#[cfg]</code> flags to your build process, and then cover some common patterns flags in a little more detail.</p>
<p>To see a full reference of all the <code>#[cfg]</code> flags provided, see the <a href="https://docs.rs/pyo3-build-config"><code>pyo3-build-cfg</code> docs</a>.</p>
<h3 id="using-pyo3-build-config"><a class="header" href="#using-pyo3-build-config">Using <code>pyo3-build-config</code></a></h3>
<p>You can use the <code>#[cfg]</code> flags in just two steps:</p>
<ol>
<li>
<p>Add <code>pyo3-build-config</code> it to your crate's build dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
pyo3-build-config = &quot;git = &quot;https://github.com/pyo3/pyo3&quot;&quot;
</code></pre>
</li>
<li>
<p>Add a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> file to your crate with the following contents:</p>
<pre><code class="language-rust ignore">fn main() {
    // If you have an existing build.rs file, just add this line to it.
    pyo3_build_config::use_pyo3_cfgs();
}
</code></pre>
</li>
</ol>
<p>After these steps you are ready to annotate your code!</p>
<h3 id="common-usages-of-pyo3-build-cfg-flags"><a class="header" href="#common-usages-of-pyo3-build-cfg-flags">Common usages of <code>pyo3-build-cfg</code> flags</a></h3>
<p>The <code>#[cfg]</code> flags added by <code>pyo3-build-cfg</code> can be combined with all of Rust's logic in the <code>#[cfg]</code> attribute to create very precise conditional code generation. The following are some common patterns implemented using these flags:</p>
<pre><code class="language-text">#[cfg(Py_3_7)]
</code></pre>
<p>This <code>#[cfg]</code> marks code that will only be present on Python 3.7 and upwards. There are similar options <code>Py_3_8</code>, <code>Py_3_9</code>, <code>Py_3_10</code> and so on for each minor version.</p>
<pre><code class="language-text">#[cfg(not(Py_3_7))]
</code></pre>
<p>This <code>#[cfg]</code> marks code that will only be present on Python versions before (but not including) Python 3.7.</p>
<pre><code class="language-text">#[cfg(not(Py_LIMITED_API))]
</code></pre>
<p>This <code>#[cfg]</code> marks code that is only available when building for the unlimited Python API (i.e. PyO3's <code>abi3</code> feature is not enabled). This might be useful if you want to ship your extension module as an <code>abi3</code> wheel and also allow users to compile it from source to make use of optimizations only possible with the unlimited API.</p>
<pre><code class="language-text">#[cfg(any(Py_3_9, not(Py_LIMITED_API)))]
</code></pre>
<p>This <code>#[cfg]</code> marks code which is available when running Python 3.9 or newer, or when using the unlimited API with an older Python version. Patterns like this are commonly seen on Python APIs which were added to the limited Python API in a specific minor version.</p>
<pre><code class="language-text">#[cfg(PyPy)]
</code></pre>
<p>This <code>#[cfg]</code> marks code which is running on PyPy.</p>
<h2 id="checking-the-python-version-at-runtime"><a class="header" href="#checking-the-python-version-at-runtime">Checking the Python version at runtime</a></h2>
<p>When building with PyO3's <code>abi3</code> feature, your extension module will be compiled against a specific <a href="building_and_distribution/../building_and_distribution.html#minimum-python-version-for-abi3">minimum version</a> of Python, but may be running on newer Python versions.</p>
<p>For example with PyO3's <code>abi3-py38</code> feature, your extension will be compiled as if it were for Python 3.8. If you were using <code>pyo3-build-config</code>, <code>#[cfg(Py_3_8)]</code> would be present. Your user could freely install and run your abi3 extension on Python 3.9.</p>
<p>There's no way to detect your user doing that at compile time, so instead you need to fall back to runtime checks.</p>
<p>PyO3 provides the APIs <a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.version"><code>Python::version()</code></a> and <a href="https://pyo3.rs/main/doc/pyo3/struct.Python.html#method.version_info"><code>Python::version_info()</code></a> to query the running Python version. This allows you to do the following, for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::Python;

Python::with_gil(|py| {
   // PyO3 supports Python 3.7 and up.
   assert!(py.version_info() &gt;= (3, 7));
   assert!(py.version_info() &gt;= (3, 7, 0));
});

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-pyo3-ecosystem"><a class="header" href="#the-pyo3-ecosystem">The PyO3 Ecosystem</a></h1>
<p>This portion of the guide is dedicated to crates which are external to the main PyO3 project and provide additional functionality you might find useful.</p>
<p>Because these projects evolve independently of the PyO3 repository the content of these articles may fall out of date over time; please file issues on the PyO3 Github to alert maintainers when this is the case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>It is desirable if both the Python and Rust parts of the application end up
logging using the same configuration into the same place.</p>
<p>This section of the guide briefly discusses how to connect the two languages'
logging ecosystems together. The recommended way for Python extension modules is
to configure Rust's logger to send log messages to Python using the <code>pyo3-log</code>
crate. For users who want to do the opposite and send Python log messages to
Rust, see the note at the end of this guide.</p>
<h2 id="using-pyo3-log-to-send-rust-log-messages-to-python"><a class="header" href="#using-pyo3-log-to-send-rust-log-messages-to-python">Using <code>pyo3-log</code> to send Rust log messages to Python</a></h2>
<p>The <a href="https://crates.io/crates/pyo3-log">pyo3-log</a> crate allows sending the messages from the Rust side to Python's
<a href="https://docs.python.org/3/library/logging.html">logging</a> system. This is mostly suitable for writing native extensions for
Python programs.</p>
<p>Use <a href="https://docs.rs/pyo3-log/*/pyo3_log/fn.init.html"><code>pyo3_log::init</code></a> to install the logger in its default configuration.
It's also possible to tweak its configuration (mostly to tune its performance).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::info;
use pyo3::prelude::*;

#[pyfunction]
fn log_something() {
    // This will use the logger installed in `my_module` to send the `info`
    // message to the Python logging facilities.
    info!(&quot;Something!&quot;);
}

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    // A good place to install the Rust -&gt; Python logger.
    pyo3_log::init();

    m.add_function(wrap_pyfunction!(log_something))?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Then it is up to the Python side to actually output the messages somewhere.</p>
<pre><code class="language-python">import logging
import my_module

FORMAT = '%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'
logging.basicConfig(format=FORMAT)
logging.getLogger().setLevel(logging.INFO)
my_module.log_something()
</code></pre>
<p>It is important to initialize the Python loggers first, before calling any Rust
functions that may log. This limitation can be worked around if it is not
possible to satisfy, read the documentation about <a href="https://docs.rs/pyo3-log/*/pyo3_log/#performance-filtering-and-caching">caching</a>.</p>
<h2 id="the-python-to-rust-direction"><a class="header" href="#the-python-to-rust-direction">The Python to Rust direction</a></h2>
<p>To best of our knowledge nobody implemented the reverse direction yet, though it
should be possible. If interested, the <code>pyo3</code> community would be happy to
provide guidance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async--await"><a class="header" href="#async--await">Async / Await</a></h1>
<p>If you are working with a Python library that makes use of async functions or wish to provide
Python bindings for an async Rust library, <a href="https://github.com/awestlake87/pyo3-asyncio"><code>pyo3-asyncio</code></a>
likely has the tools you need. It provides conversions between async functions in both Python and
Rust and was designed with first-class support for popular Rust runtimes such as
<a href="https://tokio.rs/"><code>tokio</code></a> and <a href="https://async.rs/"><code>async-std</code></a>. In addition, all async Python
code runs on the default <code>asyncio</code> event loop, so <code>pyo3-asyncio</code> should work just fine with existing
Python libraries.</p>
<p>In the following sections, we'll give a general overview of <code>pyo3-asyncio</code> explaining how to call
async Python functions with PyO3, how to call async Rust functions from Python, and how to configure
your codebase to manage the runtimes of both.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Here are some examples to get you started right away! A more detailed breakdown
of the concepts in these examples can be found in the following sections.</p>
<h3 id="rust-applications"><a class="header" href="#rust-applications">Rust Applications</a></h3>
<p>Here we initialize the runtime, import Python's <code>asyncio</code> library and run the given future to completion using Python's default <code>EventLoop</code> and <code>async-std</code>. Inside the future, we convert <code>asyncio</code> sleep into a Rust future and await it.</p>
<pre><code class="language-toml"># Cargo.toml dependencies
[dependencies]
pyo3 = { version = &quot;0.14&quot; }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;attributes&quot;, &quot;async-std-runtime&quot;] }
async-std = &quot;1.9&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">//! main.rs

use pyo3::prelude::*;

#[pyo3_asyncio::async_std::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let fut = Python::with_gil(|py| {
        let asyncio = py.import(&quot;asyncio&quot;)?;
        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::async_std::into_future(asyncio.call_method1(&quot;sleep&quot;, (1.into_py(py),))?)
    })?;

    fut.await?;

    Ok(())
}
</code></pre></pre>
<p>The same application can be written to use <code>tokio</code> instead using the <code>#[pyo3_asyncio::tokio::main]</code>
attribute.</p>
<pre><code class="language-toml"># Cargo.toml dependencies
[dependencies]
pyo3 = { version = &quot;0.14&quot; }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;attributes&quot;, &quot;tokio-runtime&quot;] }
tokio = &quot;1.4&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">//! main.rs

use pyo3::prelude::*;

#[pyo3_asyncio::tokio::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let fut = Python::with_gil(|py| {
        let asyncio = py.import(&quot;asyncio&quot;)?;
        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::tokio::into_future(asyncio.call_method1(&quot;sleep&quot;, (1.into_py(py),))?)
    })?;

    fut.await?;

    Ok(())
}
</code></pre></pre>
<p>More details on the usage of this library can be found in the <a href="https://awestlake87.github.io/pyo3-asyncio/master/doc">API docs</a> and the primer below.</p>
<h3 id="pyo3-native-rust-modules"><a class="header" href="#pyo3-native-rust-modules">PyO3 Native Rust Modules</a></h3>
<p>PyO3 Asyncio can also be used to write native modules with async functions.</p>
<p>Add the <code>[lib]</code> section to <code>Cargo.toml</code> to make your library a <code>cdylib</code> that Python can import.</p>
<pre><code class="language-toml">[lib]
name = &quot;my_async_module&quot;
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>Make your project depend on <code>pyo3</code> with the <code>extension-module</code> feature enabled and select your
<code>pyo3-asyncio</code> runtime:</p>
<p>For <code>async-std</code>:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = { version = &quot;0.14&quot;, features = [&quot;extension-module&quot;] }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;async-std-runtime&quot;] }
async-std = &quot;1.9&quot;
</code></pre>
<p>For <code>tokio</code>:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = { version = &quot;0.14&quot;, features = [&quot;extension-module&quot;] }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;tokio-runtime&quot;] }
tokio = &quot;1.4&quot;
</code></pre>
<p>Export an async function that makes use of <code>async-std</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python&lt;'_&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {
    pyo3_asyncio::async_std::future_into_py(py, async {
        async_std::task::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;

    Ok(())
}

<span class="boring">}
</span></code></pre></pre>
<p>If you want to use <code>tokio</code> instead, here's what your module should look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python&lt;'_&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {
    pyo3_asyncio::tokio::future_into_py(py, async {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>You can build your module with maturin (see the <a href="https://pyo3.rs/main/#using-rust-from-python">Using Rust in Python</a> section in the PyO3 guide for setup instructions). After that you should be able to run the Python REPL to try it out.</p>
<pre><code class="language-bash">maturin develop &amp;&amp; python3
🔗 Found pyo3 bindings
🐍 Found CPython 3.8 at python3
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
Python 3.8.5 (default, Jan 27 2021, 15:41:15)
[GCC 9.3.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt;
&gt;&gt;&gt; from my_async_module import rust_sleep
&gt;&gt;&gt;
&gt;&gt;&gt; async def main():
&gt;&gt;&gt;     await rust_sleep()
&gt;&gt;&gt;
&gt;&gt;&gt; # should sleep for 1s
&gt;&gt;&gt; asyncio.run(main())
&gt;&gt;&gt;
</code></pre>
<h2 id="awaiting-an-async-python-function-in-rust"><a class="header" href="#awaiting-an-async-python-function-in-rust">Awaiting an Async Python Function in Rust</a></h2>
<p>Let's take a look at a dead simple async Python function:</p>
<pre><code class="language-python"># Sleep for 1 second
async def py_sleep():
    await asyncio.sleep(1)
</code></pre>
<p><strong>Async functions in Python are simply functions that return a <code>coroutine</code> object</strong>. For our purposes,
we really don't need to know much about these <code>coroutine</code> objects. The key factor here is that calling
an <code>async</code> function is <em>just like calling a regular function</em>, the only difference is that we have
to do something special with the object that it returns.</p>
<p>Normally in Python, that something special is the <code>await</code> keyword, but in order to await this
coroutine in Rust, we first need to convert it into Rust's version of a <code>coroutine</code>: a <code>Future</code>.
That's where <code>pyo3-asyncio</code> comes in.
<a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/fn.into_future.html"><code>pyo3_asyncio::into_future</code></a>
performs this conversion for us.</p>
<p>The following example uses <code>into_future</code> to call the <code>py_sleep</code> function shown above and then await the
coroutine object returned from the call:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[pyo3_asyncio::tokio::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let future = Python::with_gil(|py| -&gt; PyResult&lt;_&gt; {
        // import the module containing the py_sleep function
        let example = py.import(&quot;example&quot;)?;

        // calling the py_sleep method like a normal function
        // returns a coroutine
        let coroutine = example.call_method0(&quot;py_sleep&quot;)?;

        // convert the coroutine into a Rust future using the
        // tokio runtime
        pyo3_asyncio::tokio::into_future(coroutine)
    })?;

    // await the future
    future.await?;

    Ok(())
}
</code></pre></pre>
<p>Alternatively, the below example shows how to write a <code>#[pyfunction]</code> which uses <code>into_future</code> to receive and await
a coroutine argument:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyfunction]
fn await_coro(coro: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
    // convert the coroutine into a Rust future using the
    // async_std runtime
    let f = pyo3_asyncio::async_std::into_future(coro)?;

    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {
        // await the future
        f.await?;
        Ok(())
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This could be called from Python as:</p>
<pre><code class="language-python">import asyncio

async def py_sleep():
    asyncio.sleep(1)

await_coro(py_sleep())
</code></pre>
<p>If for you wanted to pass a callable function to the <code>#[pyfunction]</code> instead, (i.e. the last line becomes <code>await_coro(py_sleep))</code>, then the above example needs to be tweaked to first call the callable to get the coroutine:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyfunction]
fn await_coro(callable: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
    // get the coroutine by calling the callable
    let coro = callable.call0()?;

    // convert the coroutine into a Rust future using the
    // async_std runtime
    let f = pyo3_asyncio::async_std::into_future(coro)?;

    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {
        // await the future
        f.await?;
        Ok(())
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This can be particularly helpful where you need to repeatedly create and await a coroutine. Trying to await the same coroutine multiple times will raise an error:</p>
<pre><code class="language-python">RuntimeError: cannot reuse already awaited coroutine
</code></pre>
<blockquote>
<p>If you're interested in learning more about <code>coroutines</code> and <code>awaitables</code> in general, check out the
<a href="https://docs.python.org/3/library/asyncio-task.html">Python 3 <code>asyncio</code> docs</a> for more information.</p>
</blockquote>
<h2 id="awaiting-a-rust-future-in-python"><a class="header" href="#awaiting-a-rust-future-in-python">Awaiting a Rust Future in Python</a></h2>
<p>Here we have the same async function as before written in Rust using the
<a href="https://async.rs/"><code>async-std</code></a> runtime:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sleep for 1 second
async fn rust_sleep() {
    async_std::task::sleep(std::time::Duration::from_secs(1)).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>Similar to Python, Rust's async functions also return a special object called a
<code>Future</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let future = rust_sleep();
<span class="boring">}
</span></code></pre></pre>
<p>We can convert this <code>Future</code> object into Python to make it <code>awaitable</code>. This tells Python that you
can use the <code>await</code> keyword with it. In order to do this, we'll call
<a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.future_into_py.html"><code>pyo3_asyncio::async_std::future_into_py</code></a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

async fn rust_sleep() {
    async_std::task::sleep(std::time::Duration::from_secs(1)).await;
}

#[pyfunction]
fn call_rust_sleep(py: Python&lt;'_&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {
    pyo3_asyncio::async_std::future_into_py(py, async move {
        rust_sleep().await;
        Ok(Python::with_gil(|py| py.None()))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>In Python, we can call this pyo3 function just like any other async function:</p>
<pre><code class="language-python">from example import call_rust_sleep

async def rust_sleep():
    await call_rust_sleep()
</code></pre>
<h2 id="managing-event-loops"><a class="header" href="#managing-event-loops">Managing Event Loops</a></h2>
<p>Python's event loop requires some special treatment, especially regarding the main thread. Some of
Python's <code>asyncio</code> features, like proper signal handling, require control over the main thread, which
doesn't always play well with Rust.</p>
<p>Luckily, Rust's event loops are pretty flexible and don't <em>need</em> control over the main thread, so in
<code>pyo3-asyncio</code>, we decided the best way to handle Rust/Python interop was to just surrender the main
thread to Python and run Rust's event loops in the background. Unfortunately, since most event loop
implementations <em>prefer</em> control over the main thread, this can still make some things awkward.</p>
<h3 id="pyo3-asyncio-initialization"><a class="header" href="#pyo3-asyncio-initialization">PyO3 Asyncio Initialization</a></h3>
<p>Because Python needs to control the main thread, we can't use the convenient proc macros from Rust
runtimes to handle the <code>main</code> function or <code>#[test]</code> functions. Instead, the initialization for PyO3 has to be done from the <code>main</code> function and the main
thread must block on <a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/fn.run_forever.html"><code>pyo3_asyncio::run_forever</code></a> or <a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.run_until_complete.html"><code>pyo3_asyncio::async_std::run_until_complete</code></a>.</p>
<p>Because we have to block on one of those functions, we can't use <a href="https://docs.rs/async-std/latest/async_std/attr.main.html"><code>#[async_std::main]</code></a> or <a href="https://docs.rs/tokio/1.1.0/tokio/attr.main.html"><code>#[tokio::main]</code></a>
since it's not a good idea to make long blocking calls during an async function.</p>
<blockquote>
<p>Internally, these <code>#[main]</code> proc macros are expanded to something like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // your async main fn
    async fn _main_impl() { /* ... */ }
    Runtime::new().block_on(_main_impl());
}
</code></pre></pre>
<p>Making a long blocking call inside the <code>Future</code> that's being driven by <code>block_on</code> prevents that
thread from doing anything else and can spell trouble for some runtimes (also this will actually
deadlock a single-threaded runtime!). Many runtimes have some sort of <code>spawn_blocking</code> mechanism
that can avoid this problem, but again that's not something we can use here since we need it to
block on the <em>main</em> thread.</p>
</blockquote>
<p>For this reason, <code>pyo3-asyncio</code> provides its own set of proc macros to provide you with this
initialization. These macros are intended to mirror the initialization of <code>async-std</code> and <code>tokio</code>
while also satisfying the Python runtime's needs.</p>
<p>Here's a full example of PyO3 initialization with the <code>async-std</code> runtime:</p>
<pre><pre class="playground"><code class="language-rust">use pyo3::prelude::*;

#[pyo3_asyncio::async_std::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    // PyO3 is initialized - Ready to go

    let fut = Python::with_gil(|py| -&gt; PyResult&lt;_&gt; {
        let asyncio = py.import(&quot;asyncio&quot;)?;

        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::async_std::into_future(
            asyncio.call_method1(&quot;sleep&quot;, (1.into_py(py),))?
        )
    })?;

    fut.await?;

    Ok(())
}
</code></pre></pre>
<h3 id="a-note-about-asynciorun"><a class="header" href="#a-note-about-asynciorun">A Note About <code>asyncio.run</code></a></h3>
<p>In Python 3.7+, the recommended way to run a top-level coroutine with <code>asyncio</code>
is with <code>asyncio.run</code>. In <code>v0.13</code> we recommended against using this function due to initialization issues, but in <code>v0.14</code> it's perfectly valid to use this function... with a caveat.</p>
<p>Since our Rust &lt;--&gt; Python conversions require a reference to the Python event loop, this poses a problem. Imagine we have a PyO3 Asyncio module that defines
a <code>rust_sleep</code> function like in previous examples. You might rightfully assume that you can call pass this directly into <code>asyncio.run</code> like this:</p>
<pre><code class="language-python">import asyncio

from my_async_module import rust_sleep

asyncio.run(rust_sleep())
</code></pre>
<p>You might be surprised to find out that this throws an error:</p>
<pre><code class="language-bash">Traceback (most recent call last):
  File &quot;example.py&quot;, line 5, in &lt;module&gt;
    asyncio.run(rust_sleep())
RuntimeError: no running event loop
</code></pre>
<p>What's happening here is that we are calling <code>rust_sleep</code> <em>before</em> the future is
actually running on the event loop created by <code>asyncio.run</code>. This is counter-intuitive, but expected behaviour, and unfortunately there doesn't seem to be a good way of solving this problem within PyO3 Asyncio itself.</p>
<p>However, we can make this example work with a simple workaround:</p>
<pre><code class="language-python">import asyncio

from my_async_module import rust_sleep

# Calling main will just construct the coroutine that later calls rust_sleep.
# - This ensures that rust_sleep will be called when the event loop is running,
#   not before.
async def main():
    await rust_sleep()

# Run the main() coroutine at the top-level instead
asyncio.run(main())
</code></pre>
<h3 id="non-standard-python-event-loops"><a class="header" href="#non-standard-python-event-loops">Non-standard Python Event Loops</a></h3>
<p>Python allows you to use alternatives to the default <code>asyncio</code> event loop. One
popular alternative is <code>uvloop</code>. In <code>v0.13</code> using non-standard event loops was
a bit of an ordeal, but in <code>v0.14</code> it's trivial.</p>
<h4 id="using-uvloop-in-a-pyo3-asyncio-native-extensions"><a class="header" href="#using-uvloop-in-a-pyo3-asyncio-native-extensions">Using <code>uvloop</code> in a PyO3 Asyncio Native Extensions</a></h4>
<pre><code class="language-toml"># Cargo.toml

[lib]
name = &quot;my_async_module&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
pyo3 = { version = &quot;0.14&quot;, features = [&quot;extension-module&quot;] }
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;tokio-runtime&quot;] }
async-std = &quot;1.9&quot;
tokio = &quot;1.4&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python&lt;'_&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {
    pyo3_asyncio::tokio::future_into_py(py, async {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-bash">$ maturin develop &amp;&amp; python3
🔗 Found pyo3 bindings
🐍 Found CPython 3.8 at python3
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
Python 3.8.8 (default, Apr 13 2021, 19:58:26)
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; import uvloop
&gt;&gt;&gt;
&gt;&gt;&gt; import my_async_module
&gt;&gt;&gt;
&gt;&gt;&gt; uvloop.install()
&gt;&gt;&gt;
&gt;&gt;&gt; async def main():
...     await my_async_module.rust_sleep()
...
&gt;&gt;&gt; asyncio.run(main())
&gt;&gt;&gt;
</code></pre>
<h4 id="using-uvloop-in-rust-applications"><a class="header" href="#using-uvloop-in-rust-applications">Using <code>uvloop</code> in Rust Applications</a></h4>
<p>Using <code>uvloop</code> in Rust applications is a bit trickier, but it's still possible
with relatively few modifications.</p>
<p>Unfortunately, we can't make use of the <code>#[pyo3_asyncio::&lt;runtime&gt;::main]</code> attribute with non-standard event loops. This is because the <code>#[pyo3_asyncio::&lt;runtime&gt;::main]</code> proc macro has to interact with the Python
event loop before we can install the <code>uvloop</code> policy.</p>
<pre><code class="language-toml">[dependencies]
async-std = &quot;1.9&quot;
pyo3 = &quot;0.14&quot;
pyo3-asyncio = { version = &quot;0.14&quot;, features = [&quot;async-std-runtime&quot;] }
</code></pre>
<pre><pre class="playground"><code class="language-rust">//! main.rs

use pyo3::{prelude::*, types::PyType};

fn main() -&gt; PyResult&lt;()&gt; {
    pyo3::prepare_freethreaded_python();

    Python::with_gil(|py| {
        let uvloop = py.import(&quot;uvloop&quot;)?;
        uvloop.call_method0(&quot;install&quot;)?;

        // store a reference for the assertion
        let uvloop = PyObject::from(uvloop);

        pyo3_asyncio::async_std::run(py, async move {
            // verify that we are on a uvloop.Loop
            Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
                assert!(pyo3_asyncio::async_std::get_current_loop(py)?.is_instance(
                    uvloop
                        .as_ref(py)
                        .getattr(&quot;Loop&quot;)?
                        .downcast::&lt;PyType&gt;()
                        .unwrap()
                )?);
                Ok(())
            })?;

            async_std::task::sleep(std::time::Duration::from_secs(1)).await;

            Ok(())
        })
    })
}
</code></pre></pre>
<h2 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h2>
<ul>
<li>Managing event loop references can be tricky with pyo3-asyncio. See <a href="https://docs.rs/pyo3-asyncio/#event-loop-references">Event Loop References</a> in the API docs to get a better intuition for how event loop references are managed in this library.</li>
<li>Testing pyo3-asyncio libraries and applications requires a custom test harness since Python requires control over the main thread. You can find a testing guide in the <a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/testing">API docs for the <code>testing</code> module</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions--troubleshooting"><a class="header" href="#frequently-asked-questions--troubleshooting">Frequently Asked Questions / Troubleshooting</a></h1>
<h2 id="im-experiencing-deadlocks-using-pyo3-with-lazy_static-or-once_cell"><a class="header" href="#im-experiencing-deadlocks-using-pyo3-with-lazy_static-or-once_cell">I'm experiencing deadlocks using PyO3 with lazy_static or once_cell!</a></h2>
<p><code>lazy_static</code> and <code>once_cell::sync</code> both use locks to ensure that initialization is performed only by a single thread. Because the Python GIL is an additional lock this can lead to deadlocks in the following way:</p>
<ol>
<li>A thread (thread A) which has acquired the Python GIL starts initialization of a <code>lazy_static</code> value.</li>
<li>The initialization code calls some Python API which temporarily releases the GIL e.g. <code>Python::import</code>.</li>
<li>Another thread (thread B) acquires the Python GIL and attempts to access the same <code>lazy_static</code> value.</li>
<li>Thread B is blocked, because it waits for <code>lazy_static</code>'s initialization to lock to release.</li>
<li>Thread A is blocked, because it waits to re-acquire the GIL which thread B still holds.</li>
<li>Deadlock.</li>
</ol>
<p>PyO3 provides a struct <a href="https://pyo3.rs/main/doc/pyo3/once_cell/struct.GILOnceCell.html"><code>GILOnceCell</code></a> which works equivalently to <code>OnceCell</code> but relies solely on the Python GIL for thread safety. This means it can be used in place of <code>lazy_static</code> or <code>once_cell</code> where you are experiencing the deadlock described above. See the documentation for <a href="https://pyo3.rs/main/doc/pyo3/once_cell/struct.GILOnceCell.html"><code>GILOnceCell</code></a> for an example how to use it.</p>
<h2 id="i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror"><a class="header" href="#i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">I can't run <code>cargo test</code>: I'm having linker issues like &quot;Symbol not found&quot; or &quot;Undefined reference to _PyExc_SystemError&quot;!</a></h2>
<p>Currently, <a href="https://github.com/PyO3/pyo3/issues/340">#340</a> causes <code>cargo test</code> to fail with linking errors when the <code>extension-module</code> feature is activated. For now you can work around this by making the <code>extension-module</code> feature optional and running the tests with <code>cargo test --no-default-features</code>:</p>
<pre><code class="language-toml">[dependencies.pyo3]
git = &quot;https://github.com/pyo3/pyo3&quot;

[features]
extension-module = [&quot;pyo3/extension-module&quot;]
default = [&quot;extension-module&quot;]
</code></pre>
<h2 id="i-cant-run-cargo-test-my-crate-cannot-be-found-for-tests-in-tests-directory"><a class="header" href="#i-cant-run-cargo-test-my-crate-cannot-be-found-for-tests-in-tests-directory">I can't run <code>cargo test</code>: my crate cannot be found for tests in <code>tests/</code> directory!</a></h2>
<p>The Rust book suggests to <a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">put integration tests inside a <code>tests/</code> directory</a>.</p>
<p>For a PyO3 <code>extension-module</code> project where the <code>crate-type</code> is set to <code>&quot;cdylib&quot;</code> in your <code>Cargo.toml</code>,
the compiler won't be able to find your crate and will display errors such as <code>E0432</code> or <code>E0463</code>:</p>
<pre><code class="language-text">error[E0432]: unresolved import `my_crate`
 --&gt; tests/test_my_crate.rs:1:5
  |
1 | use my_crate;
  |     ^^^^^^^^^^^^ no external crate `my_crate`
</code></pre>
<p>The best solution is to make your crate types include both <code>rlib</code> and <code>cdylib</code>:</p>
<pre><code class="language-toml"># Cargo.toml
[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
</code></pre>
<h2 id="ctrl-c-doesnt-do-anything-while-my-rust-code-is-executing"><a class="header" href="#ctrl-c-doesnt-do-anything-while-my-rust-code-is-executing">Ctrl-C doesn't do anything while my Rust code is executing!</a></h2>
<p>This is because Ctrl-C raises a SIGINT signal, which is handled by the calling Python process by simply setting a flag to action upon later. This flag isn't checked while Rust code called from Python is executing, only once control returns to the Python interpreter.</p>
<p>You can give the Python interpreter a chance to process the signal properly by calling <code>Python::check_signals</code>. It's good practice to call this function regularly if you have a long-running Rust function so that your users can cancel it.</p>
<h2 id="pyo3get-clones-my-field"><a class="header" href="#pyo3get-clones-my-field"><code>#[pyo3(get)]</code> clones my field!</a></h2>
<p>You may have a nested struct similar to this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct Inner { /* fields omitted */ }

#[pyclass]
struct Outer {
    #[pyo3(get)]
    inner: Inner,
}

#[pymethods]
impl Outer {
    #[new]
    fn __new__() -&gt; Self {
        Self { inner: Inner {} }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When Python code accesses <code>Outer</code>'s field, PyO3 will return a new object on every access (note that their addresses are different):</p>
<pre><code class="language-python">outer = Outer()

a = outer.inner
b = outer.inner

assert a is b, f&quot;a: {a}\nb: {b}&quot;
</code></pre>
<pre><code class="language-text">AssertionError: a: &lt;builtins.Inner object at 0x00000238FFB9C7B0&gt;
b: &lt;builtins.Inner object at 0x00000238FFB9C830&gt;
</code></pre>
<p>This can be especially confusing if the field is mutable, as getting the field and then mutating it won't persist - you'll just get a fresh clone of the original on the next access. Unfortunately Python and Rust don't agree about ownership - if PyO3 gave out references to (possibly) temporary Rust objects to Python code, Python code could then keep that reference alive indefinitely. Therefore returning Rust objects requires cloning.</p>
<p>If you don't want that cloning to happen, a workaround is to allocate the field on the Python heap and store a reference to that, by using <a href="https://pyo3.rs/main/doc/pyo3/struct.Py.html"><code>Py&lt;...&gt;</code></a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct Inner { /* fields omitted */ }

#[pyclass]
struct Outer {
    #[pyo3(get)]
    inner: Py&lt;Inner&gt;,
}

#[pymethods]
impl Outer {
    #[new]
    fn __new__(py: Python&lt;'_&gt;) -&gt; PyResult&lt;Self&gt; {
        Ok(Self {
            inner: Py::new(py, Inner {})?,
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This time <code>a</code> and <code>b</code> <em>are</em> the same object:</p>
<pre><code class="language-python">outer = Outer()

a = outer.inner
b = outer.inner

assert a is b, f&quot;a: {a}\nb: {b}&quot;
print(f&quot;a: {a}\nb: {b}&quot;)
</code></pre>
<pre><code class="language-text">a: &lt;builtins.Inner object at 0x0000020044FCC670&gt;
b: &lt;builtins.Inner object at 0x0000020044FCC670&gt;
</code></pre>
<p>The downside to this approach is that any Rust code working on the <code>Outer</code> struct now has to acquire the GIL to do anything with its field.</p>
<h2 id="i-want-to-use-the-pyo3-crate-re-exported-from-from-dependency-but-the-proc-macros-fail"><a class="header" href="#i-want-to-use-the-pyo3-crate-re-exported-from-from-dependency-but-the-proc-macros-fail">I want to use the <code>pyo3</code> crate re-exported from from dependency but the proc-macros fail!</a></h2>
<p>All PyO3 proc-macros (<code>#[pyclass]</code>, <code>#[pyfunction]</code>, <code>#[derive(FromPyObject)]</code>
and so on) expect the <code>pyo3</code> crate to be available under that name in your crate
root, which is the normal situation when <code>pyo3</code> is a direct dependency of your
crate.</p>
<p>However, when the dependency is renamed, or your crate only indirectly depends
on <code>pyo3</code>, you need to let the macro code know where to find the crate.  This is
done with the <code>crate</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">pub extern crate pyo3;
</span><span class="boring">mod reexported { pub use ::pyo3; }
</span>#[pyclass]
#[pyo3(crate = &quot;reexported::pyo3&quot;)]
struct MyClass;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-older-pyo3-versions"><a class="header" href="#migrating-from-older-pyo3-versions">Migrating from older PyO3 versions</a></h1>
<p>This guide can help you upgrade code through breaking changes from one PyO3 version to the next.
For a detailed list of all changes, see the <a href="changelog.html">CHANGELOG</a>.</p>
<h2 id="from-016-to-017"><a class="header" href="#from-016-to-017">from 0.16.* to 0.17</a></h2>
<h3 id="added-impl-intopypypystring-for-str"><a class="header" href="#added-impl-intopypypystring-for-str">Added <code>impl IntoPy&lt;Py&lt;PyString&gt;&gt; for &amp;str</code></a></h3>
<p>This may cause inference errors.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>Python::with_gil(|py| {
    // Cannot infer either `Py&lt;PyAny&gt;` or `Py&lt;PyString&gt;`
    let _test = &quot;test&quot;.into_py(py);
});
<span class="boring">}
</span></code></pre></pre>
<p>After, some type annotations may be necessary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>Python::with_gil(|py| {
    let _test: Py&lt;PyAny&gt; = &quot;test&quot;.into_py(py);
});
<span class="boring">}
</span></code></pre></pre>
<h3 id="the-pyproto-feature-is-now-disabled-by-default"><a class="header" href="#the-pyproto-feature-is-now-disabled-by-default">The <code>pyproto</code> feature is now disabled by default</a></h3>
<p>In preparation for removing the deprecated <code>#[pyproto]</code> attribute macro in a future PyO3 version, it is now gated behind an opt-in feature flag. This also gives a slight saving to compile times for code which does not use the deprecated macro.</p>
<h3 id="pytypeobject-trait-has-been-deprecated"><a class="header" href="#pytypeobject-trait-has-been-deprecated"><code>PyTypeObject</code> trait has been deprecated</a></h3>
<p>The <code>PyTypeObject</code> trait already was near-useless; almost all functionality was already on the <code>PyTypeInfo</code> trait, which <code>PyTypeObject</code> had a blanket implementation based upon. In PyO3 0.17 the final method, <code>PyTypeObject::type_object</code> was moved to <code>PyTypeInfo::type_object</code>.</p>
<p>To migrate, update trait bounds and imports from <code>PyTypeObject</code> to <code>PyTypeInfo</code>.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::Python;
use pyo3::type_object::PyTypeObject;
use pyo3::types::PyType;

fn get_type_object&lt;T: PyTypeObject&gt;(py: Python&lt;'_&gt;) -&gt; &amp;PyType {
    T::type_object(py)
}
<span class="boring">}
</span></code></pre></pre>
<p>After</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::{Python, PyTypeInfo};
use pyo3::types::PyType;

fn get_type_object&lt;T: PyTypeInfo&gt;(py: Python&lt;'_&gt;) -&gt; &amp;PyType {
    T::type_object(py)
}

<span class="boring">Python::with_gil(|py| { get_type_object::&lt;pyo3::types::PyList&gt;(py); });
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="implt-const-n-usize-intopypyobject-for-t-n-now-requires-t-intopy-rather-than-t-topyobject"><a class="header" href="#implt-const-n-usize-intopypyobject-for-t-n-now-requires-t-intopy-rather-than-t-topyobject"><code>impl&lt;T, const N: usize&gt; IntoPy&lt;PyObject&gt; for [T; N]</code> now requires <code>T: IntoPy</code> rather than <code>T: ToPyObject</code></a></h3>
<p>If this leads to errors, simply implement <code>IntoPy</code>. Because pyclasses already implement <code>IntoPy</code>, you probably don't need to worry about this.</p>
<h2 id="from-015-to-016"><a class="header" href="#from-015-to-016">from 0.15.* to 0.16</a></h2>
<h3 id="drop-support-for-older-technologies"><a class="header" href="#drop-support-for-older-technologies">Drop support for older technologies</a></h3>
<p>PyO3 0.16 has increased minimum Rust version to 1.48 and minimum Python version to 3.7. This enables use of newer language features (enabling some of the other additions in 0.16) and simplifies maintenance of the project.</p>
<h3 id="pyproto-has-been-deprecated"><a class="header" href="#pyproto-has-been-deprecated"><code>#[pyproto]</code> has been deprecated</a></h3>
<p>In PyO3 0.15, the <code>#[pymethods]</code> attribute macro gained support for implementing &quot;magic methods&quot; such as <code>__str__</code> (aka &quot;dunder&quot; methods). This implementation was not quite finalized at the time, with a few edge cases to be decided upon. The existing <code>#[pyproto]</code> attribute macro was left untouched, because it covered these edge cases.</p>
<p>In PyO3 0.16, the <code>#[pymethods]</code> implementation has been completed and is now the preferred way to implement magic methods. To allow the PyO3 project to move forward, <code>#[pyproto]</code> has been deprecated (with expected removal in PyO3 0.18).</p>
<p>Migration from <code>#[pyproto]</code> to <code>#[pymethods]</code> is straightforward; copying the existing methods directly from the <code>#[pyproto]</code> trait implementation is all that is needed in most cases.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::class::{PyBasicProtocol, PyIterProtocol};
use pyo3::types::PyString;

#[pyclass]
struct MyClass { }

#[pyproto]
impl PyBasicProtocol for MyClass {
    fn __str__(&amp;self) -&gt; &amp;'static [u8] {
        b&quot;hello, world&quot;
    }
}

#[pyproto]
impl PyIterProtocol for MyClass {
    fn __iter__(slf: PyRef&lt;self&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {
        PyString::new(slf.py(), &quot;hello, world&quot;).iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyString;

#[pyclass]
struct MyClass { }

#[pymethods]
impl MyClass {
    fn __str__(&amp;self) -&gt; &amp;'static [u8] {
        b&quot;hello, world&quot;
    }

    fn __iter__(slf: PyRef&lt;self&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {
        PyString::new(slf.py(), &quot;hello, world&quot;).iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="removed-partialeq-for-object-wrappers"><a class="header" href="#removed-partialeq-for-object-wrappers">Removed <code>PartialEq</code> for object wrappers</a></h3>
<p>The Python object wrappers <code>Py</code> and <code>PyAny</code> had implementations of <code>PartialEq</code>
so that <code>object_a == object_b</code> would compare the Python objects for pointer
equality, which corresponds to the <code>is</code> operator, not the <code>==</code> operator in
Python.  This has been removed in favor of a new method: use
<code>object_a.is(object_b)</code>.  This also has the advantage of not requiring the same
wrapper type for <code>object_a</code> and <code>object_b</code>; you can now directly compare a
<code>Py&lt;T&gt;</code> with a <code>&amp;PyAny</code> without having to convert.</p>
<p>To check for Python object equality (the Python <code>==</code> operator), use the new
method <code>eq()</code>.</p>
<h3 id="container-magic-methods-now-match-python-behavior"><a class="header" href="#container-magic-methods-now-match-python-behavior">Container magic methods now match Python behavior</a></h3>
<p>In PyO3 0.15, <code>__getitem__</code>, <code>__setitem__</code> and <code>__delitem__</code> in <code>#[pymethods]</code> would generate only the <em>mapping</em> implementation for a <code>#[pyclass]</code>. To match the Python behavior, these methods now generate both the <em>mapping</em> <strong>and</strong> <em>sequence</em> implementations.</p>
<p>This means that classes implementing these <code>#[pymethods]</code> will now also be treated as sequences, same as a Python <code>class</code> would be. Small differences in behavior may result:</p>
<ul>
<li>PyO3 will allow instances of these classes to be cast to <code>PySequence</code> as well as <code>PyMapping</code>.</li>
<li>Python will provide a default implementation of <code>__iter__</code> (if the class did not have one) which repeatedly calls <code>__getitem__</code> with integers (starting at 0) until an <code>IndexError</code> is raised.</li>
</ul>
<p>To explain this in detail, consider the following Python class:</p>
<pre><code class="language-python">class ExampleContainer:

    def __len__(self):
        return 5

    def __getitem__(self, idx: int) -&gt; int:
        if idx &lt; 0 or idx &gt; 5:
            raise IndexError()
        return idx
</code></pre>
<p>This class implements a Python <a href="https://docs.python.org/3/glossary.html#term-sequence">sequence</a>.</p>
<p>The <code>__len__</code> and <code>__getitem__</code> methods are also used to implement a Python <a href="https://docs.python.org/3/glossary.html#term-mapping">mapping</a>. In the Python C-API, these methods are not shared: the sequence <code>__len__</code> and <code>__getitem__</code> are defined by the <code>sq_len</code> and <code>sq_item</code> slots, and the mapping equivalents are <code>mp_len</code> and <code>mp_subscript</code>. There are similar distinctions for <code>__setitem__</code> and <code>__delitem__</code>.</p>
<p>Because there is no such distinction from Python, implementing these methods will fill the mapping and sequence slots simultaneously. A Python class with <code>__len__</code> implemented, for example, will have both the <code>sq_len</code> and <code>mp_len</code> slots filled.</p>
<p>The PyO3 behavior in 0.16 has been changed to be closer to this Python behavior by default.</p>
<h3 id="wrap_pymodule-and-wrap_pyfunction-now-respect-privacy-correctly"><a class="header" href="#wrap_pymodule-and-wrap_pyfunction-now-respect-privacy-correctly"><code>wrap_pymodule!</code> and <code>wrap_pyfunction!</code> now respect privacy correctly</a></h3>
<p>Prior to PyO3 0.16 the <code>wrap_pymodule!</code> and <code>wrap_pyfunction!</code> macros could use modules and functions whose defining <code>fn</code> was not reachable according Rust privacy rules.</p>
<p>For example, the following code was legal before 0.16, but in 0.16 is rejected because the <code>wrap_pymodule!</code> macro cannot access the <code>private_submodule</code> function:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    use pyo3::prelude::*;

    #[pymodule]
    fn private_submodule(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
        Ok(())
    }
}

use pyo3::prelude::*;
use foo::*;

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pymodule!(private_submodule))?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>To fix it, make the private submodule visible, e.g. with <code>pub</code> or <code>pub(crate)</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    use pyo3::prelude::*;

    #[pymodule]
    pub(crate) fn private_submodule(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
        Ok(())
    }
}

use pyo3::prelude::*;
use pyo3::wrap_pymodule;
use foo::*;

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pymodule!(private_submodule))?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="from-014-to-015"><a class="header" href="#from-014-to-015">from 0.14.* to 0.15</a></h2>
<h3 id="changes-in-sequence-indexing"><a class="header" href="#changes-in-sequence-indexing">Changes in sequence indexing</a></h3>
<p>For all types that take sequence indices (<code>PyList</code>, <code>PyTuple</code> and <code>PySequence</code>),
the API has been made consistent to only take <code>usize</code> indices, for consistency
with Rust's indexing conventions.  Negative indices, which were only
sporadically supported even in APIs that took <code>isize</code>, now aren't supported
anywhere.</p>
<p>Further, the <code>get_item</code> methods now always return a <code>PyResult</code> instead of
panicking on invalid indices.  The <code>Index</code> trait has been implemented instead,
and provides the same panic behavior as on Rust vectors.</p>
<p>Note that <em>slice</em> indices (accepted by <code>PySequence::get_slice</code> and other) still
inherit the Python behavior of clamping the indices to the actual length, and
not panicking/returning an error on out of range indices.</p>
<p>An additional advantage of using Rust's indexing conventions for these types is
that these types can now also support Rust's indexing operators as part of a
consistent API:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::{Python, types::PyList};

Python::with_gil(|py| {
    let list = PyList::new(py, &amp;[1, 2, 3]);
    assert_eq!(list[0..2].to_string(), &quot;[1, 2]&quot;);
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="from-013-to-014"><a class="header" href="#from-013-to-014">from 0.13.* to 0.14</a></h2>
<h3 id="auto-initialize-feature-is-now-opt-in"><a class="header" href="#auto-initialize-feature-is-now-opt-in"><code>auto-initialize</code> feature is now opt-in</a></h3>
<p>For projects embedding Python in Rust, PyO3 no longer automatically initializes a Python interpreter on the first call to <code>Python::with_gil</code> (or <code>Python::acquire_gil</code>) unless the <a href="features.html#auto-initialize"><code>auto-initialize</code> feature</a> is enabled.</p>
<h3 id="new-multiple-pymethods-feature"><a class="header" href="#new-multiple-pymethods-feature">New <code>multiple-pymethods</code> feature</a></h3>
<p><code>#[pymethods]</code> have been reworked with a simpler default implementation which removes the dependency on the <code>inventory</code> crate. This reduces dependencies and compile times for the majority of users.</p>
<p>The limitation of the new default implementation is that it cannot support multiple <code>#[pymethods]</code> blocks for the same <code>#[pyclass]</code>. If you need this functionality, you must enable the <code>multiple-pymethods</code> feature which will switch <code>#[pymethods]</code> to the inventory-based implementation.</p>
<h3 id="deprecated-pyproto-methods"><a class="header" href="#deprecated-pyproto-methods">Deprecated <code>#[pyproto]</code> methods</a></h3>
<p>Some protocol (aka <code>__dunder__</code>) methods such as <code>__bytes__</code> and <code>__format__</code> have been possible to implement two ways in PyO3 for some time: via a <code>#[pyproto]</code> (e.g. <code>PyBasicProtocol</code> for the methods listed here), or by writing them directly in <code>#[pymethods]</code>. This is only true for a handful of the <code>#[pyproto]</code> methods (for technical reasons to do with the way PyO3 currently interacts with the Python C-API).</p>
<p>In the interest of having onle one way to do things, the <code>#[pyproto]</code> forms of these methods have been deprecated.</p>
<p>To migrate just move the affected methods from a <code>#[pyproto]</code> to a <code>#[pymethods]</code> block.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::class::basic::PyBasicProtocol;

#[pyclass]
struct MyClass { }

#[pyproto]
impl PyBasicProtocol for MyClass {
    fn __bytes__(&amp;self) -&gt; &amp;'static [u8] {
        b&quot;hello, world&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass { }

#[pymethods]
impl MyClass {
    fn __bytes__(&amp;self) -&gt; &amp;'static [u8] {
        b&quot;hello, world&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="from-012-to-013"><a class="header" href="#from-012-to-013">from 0.12.* to 0.13</a></h2>
<h3 id="minimum-rust-version-increased-to-rust-145"><a class="header" href="#minimum-rust-version-increased-to-rust-145">Minimum Rust version increased to Rust 1.45</a></h3>
<p>PyO3 <code>0.13</code> makes use of new Rust language features stabilised between Rust 1.40 and Rust 1.45. If you are using a Rust compiler older than Rust 1.45, you will need to update your toolchain to be able to continue using PyO3.</p>
<h3 id="runtime-changes-to-support-the-cpython-limited-api"><a class="header" href="#runtime-changes-to-support-the-cpython-limited-api">Runtime changes to support the CPython limited API</a></h3>
<p>In PyO3 <code>0.13</code> support was added for compiling against the CPython limited API. This had a number of implications for <em>all</em> PyO3 users, described here.</p>
<p>The largest of these is that all types created from PyO3 are what CPython calls &quot;heap&quot; types. The specific implications of this are:</p>
<ul>
<li>If you wish to subclass one of these types <em>from Rust</em> you must mark it <code>#[pyclass(subclass)]</code>, as you would if you wished to allow subclassing it from Python code.</li>
<li>Type objects are now mutable - Python code can set attributes on them.</li>
<li><code>__module__</code> on types without <code>#[pyclass(module=&quot;mymodule&quot;)]</code> no longer returns <code>builtins</code>, it now raises <code>AttributeError</code>.</li>
</ul>
<h2 id="from-011-to-012"><a class="header" href="#from-011-to-012">from 0.11.* to 0.12</a></h2>
<h3 id="pyerr-has-been-reworked"><a class="header" href="#pyerr-has-been-reworked"><code>PyErr</code> has been reworked</a></h3>
<p>In PyO3 <code>0.12</code> the <code>PyErr</code> type has been re-implemented to be significantly more compatible with
the standard Rust error handling ecosystem. Specifically <code>PyErr</code> now implements
<code>Error + Send + Sync</code>, which are the standard traits used for error types.</p>
<p>While this has necessitated the removal of a number of APIs, the resulting <code>PyErr</code> type should now
be much more easier to work with. The following sections list the changes in detail and how to
migrate to the new APIs.</p>
<h4 id="pyerrnew-and-pyerrfrom_type-now-require-send--sync-for-their-argument"><a class="header" href="#pyerrnew-and-pyerrfrom_type-now-require-send--sync-for-their-argument"><code>PyErr::new</code> and <code>PyErr::from_type</code> now require <code>Send + Sync</code> for their argument</a></h4>
<p>For most uses no change will be needed. If you are trying to construct <code>PyErr</code> from a value that is
not <code>Send + Sync</code>, you will need to first create the Python object and then use
<code>PyErr::from_instance</code>.</p>
<p>Similarly, any types which implemented <code>PyErrArguments</code> will now need to be <code>Send + Sync</code>.</p>
<h4 id="pyerrs-contents-are-now-private"><a class="header" href="#pyerrs-contents-are-now-private"><code>PyErr</code>'s contents are now private</a></h4>
<p>It is no longer possible to access the fields <code>.ptype</code>, <code>.pvalue</code> and <code>.ptraceback</code> of a <code>PyErr</code>.
You should instead now use the new methods <code>PyErr::ptype</code>, <code>PyErr::pvalue</code> and <code>PyErr::ptraceback</code>.</p>
<h4 id="pyerrvalue-and-pyerrfrom_value-have-been-removed"><a class="header" href="#pyerrvalue-and-pyerrfrom_value-have-been-removed"><code>PyErrValue</code> and <code>PyErr::from_value</code> have been removed</a></h4>
<p>As these were part the internals of <code>PyErr</code> which have been reworked, these APIs no longer exist.</p>
<p>If you used this API, it is recommended to use <code>PyException::new_err</code> (see <a href="migration.html#exception-types-have-been-reworked">the section on
Exception types</a>).</p>
<h4 id="intopyresultt-for-pyerr-has-been-removed"><a class="header" href="#intopyresultt-for-pyerr-has-been-removed"><code>Into&lt;PyResult&lt;T&gt;&gt;</code> for <code>PyErr</code> has been removed</a></h4>
<p>This implementation was redundant. Just construct the <code>Result::Err</code> variant directly.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: PyResult&lt;()&gt; = PyErr::new::&lt;TypeError, _&gt;(&quot;error message&quot;).into();
<span class="boring">}
</span></code></pre></pre>
<p>After (also using the new reworked exception types; see the following section):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::{PyResult, exceptions::PyTypeError};
</span>let result: PyResult&lt;()&gt; = Err(PyTypeError::new_err(&quot;error message&quot;));
<span class="boring">}
</span></code></pre></pre>
<h3 id="exception-types-have-been-reworked"><a class="header" href="#exception-types-have-been-reworked">Exception types have been reworked</a></h3>
<p>Previously exception types were zero-sized marker types purely used to construct <code>PyErr</code>. In PyO3
0.12, these types have been replaced with full definitions and are usable in the same way as <code>PyAny</code>, <code>PyDict</code> etc. This
makes it possible to interact with Python exception objects.</p>
<p>The new types also have names starting with the &quot;Py&quot; prefix. For example, before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err: PyErr = TypeError::py_err(&quot;error message&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::{PyErr, PyResult, Python, type_object::PyTypeObject};
</span><span class="boring">use pyo3::exceptions::{PyBaseException, PyTypeError};
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let err: PyErr = PyTypeError::new_err(&quot;error message&quot;);

// Uses Display for PyErr, new for PyO3 0.12
assert_eq!(err.to_string(), &quot;TypeError: error message&quot;);

// Now possible to interact with exception instances, new for PyO3 0.12
let instance: &amp;PyBaseException = err.instance(py);
assert_eq!(instance.getattr(&quot;__class__&quot;)?, PyTypeError::type_object(py).as_ref());
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="frompy-has-been-removed"><a class="header" href="#frompy-has-been-removed"><code>FromPy</code> has been removed</a></h3>
<p>To simplify the PyO3 conversion traits, the <code>FromPy</code> trait has been removed. Previously there were
two ways to define the to-Python conversion for a type:
<code>FromPy&lt;T&gt; for PyObject</code> and <code>IntoPy&lt;PyObject&gt; for T</code>.</p>
<p>Now there is only one way to define the conversion, <code>IntoPy</code>, so downstream crates may need to
adjust accordingly.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>struct MyPyObjectWrapper(PyObject);

impl FromPy&lt;MyPyObjectWrapper&gt; for PyObject {
    fn from_py(other: MyPyObjectWrapper, _py: Python&lt;'_&gt;) -&gt; Self {
        other.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>struct MyPyObjectWrapper(PyObject);

impl IntoPy&lt;PyObject&gt; for MyPyObjectWrapper {
    fn into_py(self, _py: Python&lt;'_&gt;) -&gt; PyObject {
        self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Similarly, code which was using the <code>FromPy</code> trait can be trivially rewritten to use <code>IntoPy</code>.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span>let obj = PyObject::from_py(1.234, py);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span>let obj: PyObject = 1.234.into_py(py);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="pyobject-is-now-a-type-alias-of-pypyany"><a class="header" href="#pyobject-is-now-a-type-alias-of-pypyany"><code>PyObject</code> is now a type alias of <code>Py&lt;PyAny&gt;</code></a></h3>
<p>This should change very little from a usage perspective. If you implemented traits for both
<code>PyObject</code> and <code>Py&lt;T&gt;</code>, you may find you can just remove the <code>PyObject</code> implementation.</p>
<h3 id="aspyref-has-been-removed"><a class="header" href="#aspyref-has-been-removed"><code>AsPyRef</code> has been removed</a></h3>
<p>As <code>PyObject</code> has been changed to be just a type alias, the only remaining implementor of <code>AsPyRef</code>
was <code>Py&lt;T&gt;</code>. This removed the need for a trait, so the <code>AsPyRef::as_ref</code> method has been moved to
<code>Py::as_ref</code>.</p>
<p>This should require no code changes except removing <code>use pyo3::AsPyRef</code> for code which did not use
<code>pyo3::prelude::*</code>.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::{AsPyRef, Py, types::PyList};
<span class="boring">pyo3::Python::with_gil(|py| {
</span>let list_py: Py&lt;PyList&gt; = PyList::empty(py).into();
let list_ref: &amp;PyList = list_py.as_ref(py);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::{Py, types::PyList};
<span class="boring">pyo3::Python::with_gil(|py| {
</span>let list_py: Py&lt;PyList&gt; = PyList::empty(py).into();
let list_ref: &amp;PyList = list_py.as_ref(py);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="from-010-to-011"><a class="header" href="#from-010-to-011">from 0.10.* to 0.11</a></h2>
<h3 id="stable-rust"><a class="header" href="#stable-rust">Stable Rust</a></h3>
<p>PyO3 now supports the stable Rust toolchain. The minimum required version is 1.39.0.</p>
<h3 id="pyclass-structs-must-now-be-send-or-unsendable"><a class="header" href="#pyclass-structs-must-now-be-send-or-unsendable"><code>#[pyclass]</code> structs must now be <code>Send</code> or <code>unsendable</code></a></h3>
<p>Because <code>#[pyclass]</code> structs can be sent between threads by the Python interpreter, they must implement
<code>Send</code> or declared as <code>unsendable</code> (by <code>#[pyclass(unsendable)]</code>).
Note that <code>unsendable</code> is added in PyO3 <code>0.11.1</code> and <code>Send</code> is always required in PyO3 <code>0.11.0</code>.</p>
<p>This may &quot;break&quot; some code which previously was accepted, even though it could be unsound.
There can be two fixes:</p>
<ol>
<li>
<p>If you think that your <code>#[pyclass]</code> actually must be <code>Send</code>able, then let's implement <code>Send</code>.
A common, safer way is using thread-safe types. E.g., <code>Arc</code> instead of <code>Rc</code>, <code>Mutex</code> instead of
<code>RefCell</code>, and <code>Box&lt;dyn Send + T&gt;</code> instead of <code>Box&lt;dyn T&gt;</code>.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use std::rc::Rc;
use std::cell::RefCell;

#[pyclass]
struct NotThreadSafe {
    shared_bools: Rc&lt;RefCell&lt;Vec&lt;bool&gt;&gt;&gt;,
    closure: Box&lt;dyn Fn()&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;
use std::sync::{Arc, Mutex};

#[pyclass]
struct ThreadSafe {
    shared_bools: Arc&lt;Mutex&lt;Vec&lt;bool&gt;&gt;&gt;,
    closure: Box&lt;dyn Fn() + Send&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>In situations where you cannot change your <code>#[pyclass]</code> to automatically implement <code>Send</code>
(e.g., when it contains a raw pointer), you can use <code>unsafe impl Send</code>.
In such cases, care should be taken to ensure the struct is actually thread safe.
See <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">the Rustnomicon</a> for more.</p>
</li>
<li>
<p>If you think that your <code>#[pyclass]</code> should not be accessed by another thread, you can use
<code>unsendable</code> flag. A class marked with <code>unsendable</code> panics when accessed by another thread,
making it thread-safe to expose an unsendable object to the Python interpreter.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct Unsendable {
    pointers: Vec&lt;*mut std::os::raw::c_char&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

#[pyclass(unsendable)]
struct Unsendable {
    pointers: Vec&lt;*mut std::os::raw::c_char&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<h3 id="all-pyobject-and-pyt-methods-now-take-python-as-an-argument"><a class="header" href="#all-pyobject-and-pyt-methods-now-take-python-as-an-argument">All <code>PyObject</code> and <code>Py&lt;T&gt;</code> methods now take <code>Python</code> as an argument</a></h3>
<p>Previously, a few methods such as <code>Object::get_refcnt</code> did not take <code>Python</code> as an argument (to
ensure that the Python GIL was held by the current thread). Technically, this was not sound.
To migrate, just pass a <code>py</code> argument to any calls to these methods.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pyo3::Python::with_gil(|py| {
</span>py.None().get_refcnt();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pyo3::Python::with_gil(|py| {
</span>py.None().get_refcnt(py);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="from-09-to-010"><a class="header" href="#from-09-to-010">from 0.9.* to 0.10</a></h2>
<h3 id="objectprotocol-is-removed"><a class="header" href="#objectprotocol-is-removed"><code>ObjectProtocol</code> is removed</a></h3>
<p>All methods are moved to <a href="https://pyo3.rs/main/doc/pyo3/types/struct.PyAny.html"><code>PyAny</code></a>.
And since now all native types (e.g., <code>PyList</code>) implements <code>Deref&lt;Target=PyAny&gt;</code>,
all you need to do is remove <code>ObjectProtocol</code> from your code.
Or if you use <code>ObjectProtocol</code> by <code>use pyo3::prelude::*</code>, you have to do nothing.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::ObjectProtocol;

<span class="boring">pyo3::Python::with_gil(|py| {
</span>let obj = py.eval(&quot;lambda: 'Hi :)'&quot;, None, None).unwrap();
let hi: &amp;pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();
assert_eq!(hi.len().unwrap(), 5);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pyo3::Python::with_gil(|py| {
</span>let obj = py.eval(&quot;lambda: 'Hi :)'&quot;, None, None).unwrap();
let hi: &amp;pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();
assert_eq!(hi.len().unwrap(), 5);
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="no-featurespecialization-in-user-code"><a class="header" href="#no-featurespecialization-in-user-code">No <code>#![feature(specialization)]</code> in user code</a></h3>
<p>While PyO3 itself still requires specialization and nightly Rust,
now you don't have to use <code>#![feature(specialization)]</code> in your crate.</p>
<h2 id="from-08-to-09"><a class="header" href="#from-08-to-09">from 0.8.* to 0.9</a></h2>
<h3 id="new-interface"><a class="header" href="#new-interface"><code>#[new]</code> interface</a></h3>
<p><a href="https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct.PyRawObject.html"><code>PyRawObject</code></a>
is now removed and our syntax for constructors has changed.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
   #[new]
   fn new(obj: &amp;PyRawObject) {
       obj.init(MyClass { })
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
   #[new]
   fn new() -&gt; Self {
       MyClass {}
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically you can return <code>Self</code> or <code>Result&lt;Self&gt;</code> directly.
For more, see <a href="class.html#constructor">the constructor section</a> of this guide.</p>
<h3 id="pycell"><a class="header" href="#pycell">PyCell</a></h3>
<p>PyO3 0.9 introduces <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a>, which is a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>-like object wrapper
for ensuring Rust's rules regarding aliasing of references are upheld.
For more detail, see the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references">Rust Book's section on Rust's rules of references</a></p>
<p>For <code>#[pymethods]</code> or <code>#[pyfunction]</code>s, your existing code should continue to work without any change.
Python exceptions will automatically be raised when your functions are used in a way which breaks Rust's
rules of references.</p>
<p>Here is an example.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct Names {
    names: Vec&lt;String&gt;
}

#[pymethods]
impl Names {
    #[new]
    fn new() -&gt; Self {
        Names { names: vec![] }
    }
    fn merge(&amp;mut self, other: &amp;mut Names) {
        self.names.append(&amp;mut other.names)
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let names = PyCell::new(py, Names::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, names, r&quot;
</span><span class="boring">    try:
</span><span class="boring">       names.merge(names)
</span><span class="boring">       assert False, 'Unreachable'
</span><span class="boring">    except RuntimeError as e:
</span><span class="boring">       assert str(e) == 'Already borrowed'
</span><span class="boring">    &quot;);
</span><span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p><code>Names</code> has a <code>merge</code> method, which takes <code>&amp;mut self</code> and another argument of type <code>&amp;mut Self</code>.
Given this <code>#[pyclass]</code>, calling <code>names.merge(names)</code> in Python raises
a <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyBorrowMutError.html"><code>PyBorrowMutError</code></a> exception, since it requires two mutable borrows of <code>names</code>.</p>
<p>However, for <code>#[pyproto]</code> and some functions, you need to manually fix the code.</p>
<h4 id="object-creation"><a class="header" href="#object-creation">Object creation</a></h4>
<p>In 0.8 object creation was done with <code>PyRef::new</code> and <code>PyRefMut::new</code>.
In 0.9 these have both been removed.
To upgrade code, please use
<a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyCell.html#method.new"><code>PyCell::new</code></a> instead.
If you need <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html"><code>PyRefMut</code></a>, just call <code>.borrow()</code> or <code>.borrow_mut()</code>
on the newly-created <code>PyCell</code>.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span><span class="boring">Python::with_gil(|py| {
</span>let obj_ref = PyRef::new(py, MyClass {}).unwrap();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span><span class="boring">Python::with_gil(|py| {
</span>let obj = PyCell::new(py, MyClass {}).unwrap();
let obj_ref = obj.borrow();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h4 id="object-extraction"><a class="header" href="#object-extraction">Object extraction</a></h4>
<p>For <code>PyClass</code> types <code>T</code>, <code>&amp;T</code> and <code>&amp;mut T</code> no longer have <a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementations.
Instead you should extract <code>PyRef&lt;T&gt;</code> or <code>PyRefMut&lt;T&gt;</code>, respectively.
If <code>T</code> implements <code>Clone</code>, you can extract <code>T</code> itself.
In addition, you can also extract <code>&amp;PyCell&lt;T&gt;</code>, though you rarely need it.</p>
<p>Before:</p>
<pre><code class="language-compile_fail">let obj: &amp;PyAny = create_obj();
let obj_ref: &amp;MyClass = obj.extract().unwrap();
let obj_ref_mut: &amp;mut MyClass = obj.extract().unwrap();
</code></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::IntoPyDict;
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass {}
</span><span class="boring">#[pymethods] impl MyClass { #[new]fn new() -&gt; Self { MyClass {} }}
</span><span class="boring">Python::with_gil(|py| {
</span><span class="boring">let typeobj = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">let d = [(&quot;c&quot;, typeobj)].into_py_dict(py);
</span><span class="boring">let create_obj = || py.eval(&quot;c()&quot;, None, Some(d)).unwrap();
</span>let obj: &amp;PyAny = create_obj();
let obj_cell: &amp;PyCell&lt;MyClass&gt; = obj.extract().unwrap();
let obj_cloned: MyClass = obj.extract().unwrap(); // extracted by cloning the object
{
    let obj_ref: PyRef&lt;'_, MyClass&gt; = obj.extract().unwrap();
    // we need to drop obj_ref before we can extract a PyRefMut due to Rust's rules of references
}
let obj_ref_mut: PyRefMut&lt;'_, MyClass&gt; = obj.extract().unwrap();
<span class="boring">})
</span><span class="boring">}
</span></code></pre></pre>
<h4 id="pyproto-1"><a class="header" href="#pyproto-1"><code>#[pyproto]</code></a></h4>
<p>Most of the arguments to methods in <code>#[pyproto]</code> impls require a
<a href="https://pyo3.rs/main/doc/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementation.
So if your protocol methods take <code>&amp;T</code> or <code>&amp;mut T</code> (where <code>T: PyClass</code>),
please use <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://pyo3.rs/main/doc/pyo3/pycell/struct.PyRef.html"><code>PyRefMut</code></a> instead.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(deprecated)]
</span><span class="boring">#[cfg(feature = &quot;pyproto&quot;)]
</span><span class="boring">{
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: PyRef&lt;'p, Self&gt;) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pyo3-and-rust-cpython"><a class="header" href="#pyo3-and-rust-cpython">PyO3 and rust-cpython</a></h1>
<p>PyO3 began as fork of <a href="https://github.com/dgrunwald/rust-cpython">rust-cpython</a> when rust-cpython wasn't maintained. Over time PyO3 has become fundamentally different from rust-cpython.</p>
<h2 id="macros-2"><a class="header" href="#macros-2">Macros</a></h2>
<p>While rust-cpython has a <code>macro_rules!</code> based dsl for declaring modules and classes, PyO3 uses proc macros. PyO3 also doesn't change your struct and functions so you can still use them as normal Rust functions.</p>
<p><strong>rust-cpython</strong></p>
<pre><code class="language-rust ignore">py_class!(class MyClass |py| {
    data number: i32;
    def __new__(_cls, arg: i32) -&gt; PyResult&lt;MyClass&gt; {
        MyClass::create_instance(py, arg)
    }
    def half(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.number(py) / 2)
    }
});
</code></pre>
<p><strong>pyo3</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass {
   num: u32,
}

#[pymethods]
impl MyClass {
    #[new]
    fn new(num: u32) -&gt; Self {
        MyClass { num }
    }

    fn half(&amp;self) -&gt; PyResult&lt;u32&gt; {
        Ok(self.num / 2)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="ownership-and-lifetimes"><a class="header" href="#ownership-and-lifetimes">Ownership and lifetimes</a></h2>
<p>While in rust-cpython you always own python objects, PyO3 allows efficient <em>borrowed objects</em>
and most APIs are available with references.</p>
<p>Here is an example of the PyList API:</p>
<p><strong>rust-cpython</strong></p>
<pre><code class="language-rust ignore">impl PyList {

   fn new(py: Python&lt;'_&gt;) -&gt; PyList {...}

   fn get_item(&amp;self, py: Python&lt;'_&gt;, index: isize) -&gt; PyObject {...}
}
</code></pre>
<p><strong>pyo3</strong></p>
<pre><code class="language-rust ignore">impl PyList {

   fn new(py: Python&lt;'_&gt;) -&gt; &amp;PyList {...}

   fn get_item(&amp;self, index: isize) -&gt; &amp;PyAny {...}
}
</code></pre>
<p>In PyO3, all object references are bounded by the GIL lifetime.
So the owned Python object is not required, and it is safe to have functions like <code>fn py&lt;'p&gt;(&amp;'p self) -&gt; Python&lt;'p&gt; {}</code>.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>rust-cpython requires a <code>Python</code> parameter for constructing a <code>PyErr</code>, so error handling ergonomics is pretty bad. It is not possible to use <code>?</code> with Rust errors.</p>
<p>PyO3 on other hand does not require <code>Python</code> for constructing a <code>PyErr</code>, it is only required if you want to raise an exception in Python with the <code>PyErr::restore()</code> method. Due to various <code>std::convert::From&lt;E&gt; for PyErr</code> implementations for Rust standard error types <code>E</code>, propagating <code>?</code> is supported automatically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-in-python-a-rust-function-with-trait-bounds"><a class="header" href="#using-in-python-a-rust-function-with-trait-bounds">Using in Python a Rust function with trait bounds</a></h1>
<p>PyO3 allows for easy conversion from Rust to Python for certain functions and classes (see the <a href="conversions/tables.html">conversion table</a>.
However, it is not always straightforward to convert Rust code that requires a given trait implementation as an argument.</p>
<p>This tutorial explains how to convert a Rust function that takes a trait as argument for use in Python with classes implementing the same methods as the trait.</p>
<p>Why is this useful?</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>Make your Rust code available to Python users</li>
<li>Code complex algorithms in Rust with the help of the borrow checker</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>Not as fast as native Rust (type conversion has to be performed and one part of the code runs in Python)</li>
<li>You need to adapt your code to expose it</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's work with the following basic example of an implementation of a optimization solver operating on a given model.</p>
<p>Let's say we have a function <code>solve</code> that operates on a model and mutates its state.
The argument of the function can be any model that implements the <code>Model</code> trait :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span>pub trait Model {
  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
  fn compute(&amp;mut self);
  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
}

pub fn solve&lt;T: Model&gt;(model: &amp;mut T) {
  println!(&quot;Magic solver that mutates the model into a resolved state&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's assume we have the following constraints:</p>
<ul>
<li>We cannot change that code as it runs on many Rust models.</li>
<li>We also have many Python models that cannot be solved as this solver is not available in that language.
Rewriting it in Python would be cumbersome and error-prone, as everything is already available in Rust.</li>
</ul>
<p>How could we expose this solver to Python thanks to PyO3 ?</p>
<h2 id="implementation-of-the-trait-bounds-for-the-python-class"><a class="header" href="#implementation-of-the-trait-bounds-for-the-python-class">Implementation of the trait bounds for the Python class</a></h2>
<p>If a Python class implements the same three methods as the <code>Model</code> trait, it seems logical it could be adapted to use the solver.
However, it is not possible to pass a <code>PyObject</code> to it as it does not implement the Rust trait (even if the Python model has the required methods).</p>
<p>In order to implement the trait, we must write a wrapper around the calls in Rust to the Python model.
The method signatures must be the same as the trait, keeping in mind that the Rust trait cannot be changed for the purpose of making the code available in Python.</p>
<p>The Python model we want to expose is the following one, which already contains all the required methods:</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 - 3 for elt in self.inputs]
    def get_results(self):
        return self.results
</code></pre>
<p>The following wrapper will call the Python model from Rust, using a struct to hold the model as a <code>PyAny</code> object:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyAny;

<span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span>
struct UserModel {
    model: Py&lt;PyAny&gt;,
}

impl Model for UserModel {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
        println!(&quot;Rust calling Python to set the variables&quot;);
        Python::with_gil(|py| {
            let values: Vec&lt;f64&gt; = var.clone();
            let list: PyObject = values.into_py(py);
            let py_model = self.model.as_ref(py);
            py_model
                .call_method(&quot;set_variables&quot;, (list,), None)
                .unwrap();
        })
    }

    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Rust calling Python to get the results&quot;);
        Python::with_gil(|py| {
            self.model
                .as_ref(py)
                .call_method(&quot;get_results&quot;, (), None)
                .unwrap()
                .extract()
                .unwrap()
        })
    }

    fn compute(&amp;mut self) {
        println!(&quot;Rust calling Python to perform the computation&quot;);
        Python::with_gil(|py| {
            self.model
                .as_ref(py)
                .call_method(&quot;compute&quot;, (), None)
                .unwrap();
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that this bit is implemented, let's expose the model wrapper to Python.
Let's add the PyO3 annotations and add a constructor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dead_code)]
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span>
#[pyclass]
struct UserModel {
    model: Py&lt;PyAny&gt;,
}

#[pymodule]
fn trait_exposure(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;UserModel&gt;()?;
    Ok(())
}

#[pymethods]
impl UserModel {
    #[new]
    pub fn new(model: Py&lt;PyAny&gt;) -&gt; Self {
        UserModel { model }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we add the PyO3 annotations to the trait implementation:</p>
<pre><code class="language-rust ignore">#[pymethods]
impl Model for UserModel {
  // the previous trait implementation
}
</code></pre>
<p>However, the previous code will not compile. The compilation error is the following one:
<code>error: #[pymethods] cannot be used on trait impl blocks</code></p>
<p>That's a bummer!
However, we can write a second wrapper around these functions to call them directly.
This wrapper will also perform the type conversions between Python and Rust.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Model for UserModel {
</span><span class="boring"> fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">     println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">         let list: PyObject = values.into_py(py);
</span><span class="boring">         let py_model = self.model.as_ref(py);
</span><span class="boring">         py_model
</span><span class="boring">             .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">             .unwrap();
</span><span class="boring">     })
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
</span><span class="boring">     println!(&quot;Rust calling Python to get the results&quot;);
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         self.model
</span><span class="boring">             .as_ref(py)
</span><span class="boring">             .call_method(&quot;get_results&quot;, (), None)
</span><span class="boring">             .unwrap()
</span><span class="boring">             .extract()
</span><span class="boring">             .unwrap()
</span><span class="boring">     })
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn compute(&amp;mut self) {
</span><span class="boring">     println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         self.model
</span><span class="boring">             .as_ref(py)
</span><span class="boring">             .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">             .unwrap();
</span><span class="boring">     })
</span><span class="boring">
</span><span class="boring"> }
</span><span class="boring">}
</span>
#[pymethods]
impl UserModel {
    pub fn set_variables(&amp;mut self, var: Vec&lt;f64&gt;) {
        println!(&quot;Set variables from Python calling Rust&quot;);
        Model::set_variables(self, &amp;var)
    }

    pub fn get_results(&amp;mut self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Python calling Rust&quot;);
        Model::get_results(self)
    }

    pub fn compute(&amp;mut self) {
        println!(&quot;Compute from Python calling Rust&quot;);
        Model::compute(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This wrapper handles the type conversion between the PyO3 requirements and the trait.
In order to meet PyO3 requirements, this wrapper must:</p>
<ul>
<li>return an object of type <code>PyResult</code></li>
<li>use only values, not references in the method signatures</li>
</ul>
<p>Let's run the file python file:</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 - 3 for elt in self.inputs]
    def get_results(self):
        return self.results

if __name__==&quot;__main__&quot;:
  import trait_exposure

  myModel = Model()
  my_rust_model = trait_exposure.UserModel(myModel)
  my_rust_model.set_variables([2.0])
  print(&quot;Print value from Python: &quot;, myModel.inputs)
  my_rust_model.compute()
  print(&quot;Print value from Python through Rust: &quot;, my_rust_model.get_results())
  print(&quot;Print value directly from Python: &quot;, myModel.get_results())
</code></pre>
<p>This outputs:</p>
<pre><code class="language-block">Set variables from Python calling Rust
Set variables from Rust calling Python
Print value from Python:  [2.0]
Compute from Python calling Rust
Compute from Rust calling Python
Get results from Python calling Rust
Get results from Rust calling Python
Print value from Python through Rust:  [1.0]
Print value directly from Python:  [1.0]
</code></pre>
<p>We have now successfully exposed a Rust model that implements the <code>Model</code> trait to Python!</p>
<p>We will now expose the <code>solve</code> function, but before, let's talk about types errors.</p>
<h2 id="type-errors-in-python"><a class="header" href="#type-errors-in-python">Type errors in Python</a></h2>
<p>What happens if you have type errors when using Python and how can you improve the error messages?</p>
<h3 id="wrong-types-in-python-function-arguments"><a class="header" href="#wrong-types-in-python-function-arguments">Wrong types in Python function arguments</a></h3>
<p>Let's assume in the first case that you will use in your Python file <code>my_rust_model.set_variables(2.0)</code> instead of <code>my_rust_model.set_variables([2.0])</code>.</p>
<p>The Rust signature expects a vector, which corresponds to a list in Python.
What happens if instead of a vector, we pass a single value ?</p>
<p>At the execution of Python, we get :</p>
<pre><code class="language-block">File &quot;main.py&quot;, line 15, in &lt;module&gt;
   my_rust_model.set_variables(2)
TypeError
</code></pre>
<p>It is a type error and Python points to it, so it's easy to identify and solve.</p>
<h3 id="wrong-types-in-python-method-signatures"><a class="header" href="#wrong-types-in-python-method-signatures">Wrong types in Python method signatures</a></h3>
<p>Let's assume now that the return type of one of the methods of our Model class is wrong, for example the <code>get_results</code> method that is expected to return a <code>Vec&lt;f64&gt;</code> in Rust, a list in Python.</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 -3 for elt in self.inputs]
    def get_results(self):
        return self.results[0]
        #return self.results &lt;-- this is the expected output
</code></pre>
<p>This call results in the following panic:</p>
<pre><code class="language-block">pyo3_runtime.PanicException: called `Result::unwrap()` on an `Err` value: PyErr { type: Py(0x10dcf79f0, PhantomData) }
</code></pre>
<p>This error code is not helpful for a Python user that does not know anything about Rust, or someone that does not know PyO3 was used to interface the Rust code.</p>
<p>However, as we are responsible for making the Rust code available to Python, we can do something about it.</p>
<p>The issue is that we called <code>unwrap</code> anywhere we could, and therefore any panic from PyO3 will be directly forwarded to the end user.</p>
<p>Let's modify the code performing the type conversion to give a helpful error message to the Python user:</p>
<p>We used in our <code>get_results</code> method the following call that performs the type conversion:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span>
impl Model for UserModel {
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Rust calling Python to get the results&quot;);
        Python::with_gil(|py| {
            self.model
                .as_ref(py)
                .call_method(&quot;get_results&quot;, (), None)
                .unwrap()
                .extract()
                .unwrap()
        })
    }
<span class="boring">    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">        println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">            let list: PyObject = values.into_py(py);
</span><span class="boring">            let py_model = self.model.as_ref(py);
</span><span class="boring">            py_model
</span><span class="boring">                .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn compute(&amp;mut self) {
</span><span class="boring">        println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            self.model
</span><span class="boring">                .as_ref(py)
</span><span class="boring">                .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>Let's break it down in order to perform better error handling:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyAny;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span>
impl Model for UserModel {
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Rust calling Python&quot;);
        Python::with_gil(|py| {
            let py_result: &amp;PyAny = self
                .model
                .as_ref(py)
                .call_method(&quot;get_results&quot;, (), None)
                .unwrap();

            if py_result.get_type().name().unwrap() != &quot;list&quot; {
                panic!(&quot;Expected a list for the get_results() method signature, got {}&quot;, py_result.get_type().name().unwrap());
            }
            py_result.extract()
        })
        .unwrap()
    }
<span class="boring">    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">        println!(&quot;Rust calling Python to set the variables&quot;);
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            let values: Vec&lt;f64&gt; = var.clone();
</span><span class="boring">            let list: PyObject = values.into_py(py);
</span><span class="boring">            let py_model = self.model.as_ref(py);
</span><span class="boring">            py_model
</span><span class="boring">                .call_method(&quot;set_variables&quot;, (list,), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn compute(&amp;mut self) {
</span><span class="boring">        println!(&quot;Rust calling Python to perform the computation&quot;);
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            self.model
</span><span class="boring">                .as_ref(py)
</span><span class="boring">                .call_method(&quot;compute&quot;, (), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>By doing so, you catch the result of the Python computation and check its type in order to be able to deliver a better error message before performing the unwrapping.</p>
<p>Of course, it does not cover all the possible wrong outputs:
the user could return a list of strings instead of a list of floats.
In this case, a runtime panic would still occur due to PyO3, but with an error message much more difficult to decipher for non-rust user.</p>
<p>It is up to the developer exposing the rust code to decide how much effort to invest into Python type error handling and improved error messages.</p>
<h2 id="the-final-code"><a class="header" href="#the-final-code">The final code</a></h2>
<p>Now let's expose the <code>solve()</code> function to make it available from Python.</p>
<p>It is not possible to directly expose the <code>solve</code> function to Python, as the type conversion cannot be performed.
It requires an object implementing the <code>Model</code> trait as input.</p>
<p>However, the <code>UserModel</code> already implements this trait.
Because of this, we can write a function wrapper that takes the <code>UserModel</code>--which has already been exposed to Python--as an argument in order to call the core function <code>solve</code>.</p>
<p>It is also required to make the struct public.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyAny;

pub trait Model {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;);
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
    fn compute(&amp;mut self);
}

pub fn solve&lt;T: Model&gt;(model: &amp;mut T) {
  println!(&quot;Magic solver that mutates the model into a resolved state&quot;);
}

#[pyfunction]
#[pyo3(name = &quot;solve&quot;)]
pub fn solve_wrapper(model: &amp;mut UserModel) {
    solve(model);
}

#[pyclass]
pub struct UserModel {
    model: Py&lt;PyAny&gt;,
}

#[pymodule]
fn trait_exposure(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;UserModel&gt;()?;
    m.add_function(wrap_pyfunction!(solve_wrapper, m)?)?;
    Ok(())
}

#[pymethods]
impl UserModel {
    #[new]
    pub fn new(model: Py&lt;PyAny&gt;) -&gt; Self {
        UserModel { model }
    }

    pub fn set_variables(&amp;mut self, var: Vec&lt;f64&gt;) {
        println!(&quot;Set variables from Python calling Rust&quot;);
        Model::set_variables(self, &amp;var)
    }

    pub fn get_results(&amp;mut self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Python calling Rust&quot;);
        Model::get_results(self)
    }

    pub fn compute(&amp;mut self) {
        Model::compute(self)
    }
}

impl Model for UserModel {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
        println!(&quot;Rust calling Python to set the variables&quot;);
        Python::with_gil(|py| {
            let values: Vec&lt;f64&gt; = var.clone();
            let list: PyObject = values.into_py(py);
            let py_model = self.model.as_ref(py);
            py_model
                .call_method(&quot;set_variables&quot;, (list,), None)
                .unwrap();
        })
    }

    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!(&quot;Get results from Rust calling Python&quot;);
        Python::with_gil(|py| {
            let py_result: &amp;PyAny = self
                .model
                .as_ref(py)
                .call_method(&quot;get_results&quot;, (), None)
                .unwrap();

            if py_result.get_type().name().unwrap() != &quot;list&quot; {
                panic!(&quot;Expected a list for the get_results() method signature, got {}&quot;, py_result.get_type().name().unwrap());
            }
            py_result.extract()
        })
        .unwrap()
    }

    fn compute(&amp;mut self) {
        println!(&quot;Rust calling Python to perform the computation&quot;);
        Python::with_gil(|py| {
            self.model
                .as_ref(py)
                .call_method(&quot;compute&quot;, (), None)
                .unwrap();
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typing-and-ide-hints-for-you-python-package"><a class="header" href="#typing-and-ide-hints-for-you-python-package">Typing and IDE hints for you Python package</a></h1>
<p>PyO3 provides an easy to use interface to code native Python libraries in Rust. The accompanying Maturin allows you to build and publish them as a package. Yet, for the better user experience, Python libraries should provide typing hints and documentation for all public entities, so that IDEs can show them during development and type analyzing tools such as <code>mypy</code> can use them to properly verify the code.</p>
<p>Currently the best solution for the problem is to maintain manually the <code>*.pyi</code> files and ship them along with the package.</p>
<h2 id="the-pyi-files-introduction"><a class="header" href="#the-pyi-files-introduction">The <code>pyi</code> files introduction</a></h2>
<p><code>pyi</code> (an abbreviation for <code>Python Interface</code>) is called a <code>Stub File</code> in most of the documentations related to them. Very good definition of what it is can be found in <a href="https://github.com/python/mypy/wiki/Creating-Stubs-For-Python-Modules">old MyPy documentation</a>:</p>
<blockquote>
<p>A stubs file only contains a description of the public interface of the module without any implementations.</p>
</blockquote>
<p>Probably most Python developers encountered them already when trying to use the IDE &quot;Go to Definition&quot; function on any builtin type. For example the definitions of few standard exceptions look like this:</p>
<pre><code class="language-python">class BaseException(object):
    args: Tuple[Any, ...]
    __cause__: BaseException | None
    __context__: BaseException | None
    __suppress_context__: bool
    __traceback__: TracebackType | None
    def __init__(self, *args: object) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def with_traceback(self: _TBE, tb: TracebackType | None) -&gt; _TBE: ...

class SystemExit(BaseException):
    code: int

class Exception(BaseException): ...

class StopIteration(Exception):
    value: Any
</code></pre>
<p>As we can see those are not full definitions containing implementation, but just a description of interface. It is usually all that is needed by the user of the library.</p>
<h3 id="what-does-the-peps-say"><a class="header" href="#what-does-the-peps-say">What does the PEPs say?</a></h3>
<p>As of the time of writing this documentation the <code>pyi</code> files are referenced in three PEPs.</p>
<p><a href="https://www.python.org/dev/peps/pep-0008/#function-annotations">PEP8 - Style Guide for Python Code - #Function Annotations</a> (last point) recommends all third party library creators to provide stub files as the source of knowledge about the package for type checker tools.</p>
<blockquote>
<p>(...) it is expected that users of third party library packages may want to run type checkers over those packages. For this purpose <a href="https://www.python.org/dev/peps/pep-0484">PEP 484</a> recommends the use of stub files: .pyi files that are read by the type checker in preference of the corresponding .py files. (...)</p>
</blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0484/#stub-files">PEP484 - Type Hints - #Stub Files</a> defines stub files as follows.</p>
<blockquote>
<p>Stub files are files containing type hints that are only for use by the type checker, not at runtime.</p>
</blockquote>
<p>It contains a specification for them (highly recommended reading, since it contains at least one thing that is not used in normal Python code) and also some general information about where to store the stub files.</p>
<p><a href="https://www.python.org/dev/peps/pep-0561/">PEP561 - Distributing and Packaging Type Information</a> describes in detail how to build packages that will enable type checking. In particular it contains information about how the stub files must be distributed in order for type checkers to use them.</p>
<h2 id="how-to-do-it"><a class="header" href="#how-to-do-it">How to do it?</a></h2>
<p><a href="https://www.python.org/dev/peps/pep-0561/">PEP561</a> recognizes three ways of distributing type information:</p>
<ul>
<li><code>inline</code> - the typing is placed directly in source (<code>py</code>) files;</li>
<li><code>separate package with stub files</code> - the typing is placed in <code>pyi</code> files distributed in their own, separate package;</li>
<li><code>in-package stub files</code> - the typing is placed in <code>pyi</code> files distributed in the same package as source files.</li>
</ul>
<p>The first way is tricky with PyO3 since we do not have <code>py</code> files. When it will be investigated and necessary changes are implemented, this document will be updated.</p>
<p>The second way is easy to do, and the whole work can be fully separated from the main library code. The example repo for the package with stub files can be found in <a href="https://www.python.org/dev/peps/pep-0561/#references">PEP561 references section</a>: <a href="https://github.com/ethanhs/stub-package">Stub package repository</a></p>
<p>The third way is described below.</p>
<h3 id="including-pyi-files-in-your-pyo3maturin-build-package"><a class="header" href="#including-pyi-files-in-your-pyo3maturin-build-package">Including <code>pyi</code> files in your PyO3/Maturin build package</a></h3>
<p>When source files are in the same package as stub files, they should be placed next to each other. We need a way to do that with Maturin. Also, in order to mark our package as typing-enabled we need to add an empty file named <code>py.typed</code> to the package.</p>
<h4 id="if-you-do-not-have-other-python-files"><a class="header" href="#if-you-do-not-have-other-python-files">If you do not have other Python files</a></h4>
<p>If you do not need to add any other Python files apart from <code>pyi</code> to the package, the Maturin provides a way to do most of the work for you. As documented in <a href="https://github.com/PyO3/maturin/blob/084cfaced651b28616aeea1f818bdc933a536bfe/guide/src/project_layout.md#adding-python-type-information">Maturin Guide</a> the only thing you need to do is create a stub file for your module named <code>&lt;module_name&gt;.pyi</code> in your project root and Maturin will do the rest.</p>
<pre><code class="language-text">my-rust-project/
├── Cargo.toml
├── my_project.pyi  # &lt;&lt;&lt; add type stubs for Rust functions in the my_project module here
├── pyproject.toml
└── src
    └── lib.rs
</code></pre>
<p>For example of <code>pyi</code> file see <a href="python_typing_hints.html#my_projectpyi-content"><code>my_project.pyi</code> content</a> section.</p>
<h4 id="if-you-need-other-python-files"><a class="header" href="#if-you-need-other-python-files">If you need other Python files</a></h4>
<p>If you need to add other Python files apart from <code>pyi</code> to the package, you can do it also, but that requires some more work. Maturin provides easy way to add files to package (<a href="https://github.com/PyO3/maturin/blob/0dee40510083c03607834c821eea76964140a126/Readme.md#mixed-rustpython-projects">documentation</a>). You just need to create a folder with the name of your module next to the <code>Cargo.toml</code> file (for customization see documentation linked above).</p>
<p>The folder structure would be:</p>
<pre><code class="language-text">my-project
├── Cargo.toml
├── my_project
│   ├── __init__.py
│   ├── my_project.pyi
│   ├── other_python_file.py
│   └── py.typed
├── pyproject.toml
├── Readme.md
└── src
    └── lib.rs
</code></pre>
<p>Let's go a little bit more into details on the files inside the package folder.</p>
<h5 id="__init__py-content"><a class="header" href="#__init__py-content"><code>__init__.py</code> content</a></h5>
<p>As we now specify our own package content, we have to provide the <code>__init__.py</code> file, so the folder is treated as a package and we can import things from it. We can always use the same content that the Maturin creates for us if we do not specify a python source folder. For PyO3 bindings it would be:</p>
<pre><code class="language-python">from .my_project import *
</code></pre>
<p>That way everything that is exposed by our native module can be imported directly from the package.</p>
<h5 id="pytyped-requirement"><a class="header" href="#pytyped-requirement"><code>py.typed</code> requirement</a></h5>
<p>As stated in <a href="https://www.python.org/dev/peps/pep-0561/">PEP561</a>:</p>
<blockquote>
<p>Package maintainers who wish to support type checking of their code MUST add a marker file named py.typed to their package supporting typing. This marker applies recursively: if a top-level package includes it, all its sub-packages MUST support type checking as well.</p>
</blockquote>
<p>If we do not include that file, some IDEs might still use our <code>pyi</code> files to show hints, but the type checkers might not. MyPy will raise an error in this situation:</p>
<pre><code class="language-text">error: Skipping analyzing &quot;my_project&quot;: found module but no type hints or library stubs
</code></pre>
<p>The file is just a marker file, so it should be empty.</p>
<h5 id="my_projectpyi-content"><a class="header" href="#my_projectpyi-content"><code>my_project.pyi</code> content</a></h5>
<p>Our module stub file. This document does not aim at describing how to write them, since you can find a lot of documentation on it, starting from already quoted <a href="https://www.python.org/dev/peps/pep-0484/#stub-files">PEP484</a>.</p>
<p>The example can look like this:</p>
<pre><code class="language-python">class Car:
    &quot;&quot;&quot;
    A class representing a car.

    :param body_type: the name of body type, e.g. hatchback, sedan
    :param horsepower: power of the engine in horsepower
    &quot;&quot;&quot;
    def __init__(self, body_type: str, horsepower: int) -&gt; None: ...

    @classmethod
    def from_unique_name(cls, name: str) -&gt; 'Car':
        &quot;&quot;&quot;
        Creates a Car based on unique name

        :param name: model name of a car to be created
        :return: a Car instance with default data
        &quot;&quot;&quot;

    def best_color(self) -&gt; str:
        &quot;&quot;&quot;
        Gets the best color for the car.

        :return: the name of the color our great algorithm thinks is the best for this car
        &quot;&quot;&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to this project will be documented in this file. For help with updating to new
PyO3 versions, please see the <a href="https://pyo3.rs/latest/migration.html">migration guide</a>.</p>
<p>The format is based on <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>
and this project adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0165headunreleaseda"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0165headunreleaseda"><a href="https://github.com/pyo3/pyo3/compare/v0.16.5...HEAD">Unreleased</a></a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>Implement <code>ToPyObject</code> for <code>[T; N]</code>. <a href="https://github.com/PyO3/pyo3/pull/2313">#2313</a></li>
<li>Added the internal <code>IntoPyResult</code> trait to give better error messages when function return types do not implement <code>IntoPy</code>. <a href="https://github.com/PyO3/pyo3/pull/2326">#2326</a></li>
<li>Add <code>PyDictKeys</code>, <code>PyDictValues</code> and <code>PyDictItems</code> Rust types to represent <code>dict_keys</code>, <code>dict_values</code> and <code>dict_items</code> types. <a href="https://github.com/PyO3/pyo3/pull/2358">#2358</a></li>
<li>Add macro <code>append_to_inittab</code>. <a href="https://github.com/PyO3/pyo3/pull/2377">#2377</a></li>
<li>Add FFI definition <code>PyFrame_GetCode</code>. <a href="https://github.com/PyO3/pyo3/pull/2406">#2406</a></li>
<li>Added <code>PyCode</code> and <code>PyFrame</code> high level objects. <a href="https://github.com/PyO3/pyo3/pull/2408">#2408</a></li>
<li>Add FFI definitions <code>Py_fstring_input</code>, <code>sendfunc</code>, and <code>_PyErr_StackItem</code>. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Add <code>PyDateTime::new_with_fold</code>, <code>PyTime::new_with_fold</code>, <code>PyTime::get_fold</code>, <code>PyDateTime::get_fold</code> for PyPy. <a href="https://github.com/PyO3/pyo3/pull/2428">#2428</a></li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li>Several methods of <code>Py</code> and <code>PyAny</code> now accept <code>impl IntoPy&lt;Py&lt;PyString&gt;&gt;</code> rather than just <code>&amp;str</code> to allow use of the <code>intern!</code> macro. <a href="https://github.com/PyO3/pyo3/pull/2312">#2312</a></li>
<li>Move <code>PyTypeObject::type_object</code> method to <code>PyTypeInfo</code> trait, and deprecate <code>PyTypeObject</code> trait. <a href="https://github.com/PyO3/pyo3/pull/2287">#2287</a></li>
<li>The deprecated <code>pyproto</code> feature is now disabled by default. <a href="https://github.com/PyO3/pyo3/pull/2322">#2322</a></li>
<li>Deprecate <code>ToBorrowedObject</code> trait (it is only used as a wrapper for <code>ToPyObject</code>). <a href="https://github.com/PyO3/pyo3/pull/2333">#2333</a></li>
<li><code>impl&lt;T, const N: usize&gt; IntoPy&lt;PyObject&gt; for [T; N]</code> now requires <code>T: IntoPy</code> rather than <code>T: ToPyObject</code>. <a href="https://github.com/PyO3/pyo3/pull/2326">#2326</a></li>
<li>Correct <code>wrap_pymodule</code> to match normal namespacing rules: it no longer &quot;sees through&quot; glob imports of <code>use submodule::*</code> when <code>submodule::submodule</code> is a <code>#[pymodule]</code>. <a href="https://github.com/PyO3/pyo3/pull/2363">#2363</a></li>
<li>Allow <code>#[classattr]</code> methods to be fallible. <a href="https://github.com/PyO3/pyo3/pull/2385">#2385</a></li>
<li>Prevent multiple <code>#[pymethods]</code> with the same name for a single <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/2399">#2399</a></li>
<li>Fixup <code>lib_name</code> when using <code>PYO3_CONFIG_FILE</code>. <a href="https://github.com/PyO3/pyo3/pull/2404">#2404</a></li>
<li>Iterators over <code>PySet</code> and <code>PyDict</code> will now panic if the underlying collection is mutated during the iteration. <a href="https://github.com/PyO3/pyo3/pull/2380">#2380</a></li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Fixed incorrectly disabled FFI definition <code>PyThreadState_DeleteCurrent</code>. <a href="https://github.com/PyO3/pyo3/pull/2357">#2357</a></li>
<li>Correct FFI definition <code>PyEval_EvalCodeEx</code> to take <code>*const *mut PyObject</code> array arguments instead of <code>*mut *mut PyObject</code> (this was changed in CPython 3.6). <a href="https://github.com/PyO3/pyo3/pull/2368">#2368</a></li>
<li>Fix &quot;raw-ident&quot; structs (e.g. <code>#[pyclass] struct r#RawName</code>) incorrectly having <code>r#</code> at the start of the class name created in Python. <a href="https://github.com/PyO3/pyo3/pull/2395">#2395</a></li>
<li>Correct FFI definition <code>Py_tracefunc</code> to be <code>unsafe extern &quot;C&quot; fn</code> (was previously safe). <a href="https://github.com/PyO3/pyo3/pull/2407">#2407</a></li>
<li>Fix case where <code>ValueError</code> without message could be raised by the <code>#[derive(FromPyObject)]</code> generated implementation for a tuple struct. <a href="https://github.com/PyO3/pyo3/pull/2414">#2414</a></li>
<li>Fix compile failure when using <code>#[pyo3(from_py_with = &quot;pouf&quot;)]</code> in on a field in a <code>#[derive(FromPyObject)]</code> struct. <a href="https://github.com/PyO3/pyo3/pull/2414">#2414</a></li>
<li>Fix FFI definitions <code>_PyDateTime_BaseTime</code> and <code>_PyDateTime_BaseDateTime</code> lacking leading underscores in their names. <a href="https://github.com/PyO3/pyo3/pull/2421">#2421</a></li>
<li>Remove FFI definition <code>PyArena</code> on Python 3.10 and up. <a href="https://github.com/PyO3/pyo3/pull/2421">#2421</a></li>
<li>Fix FFI definition <code>PyCompilerFlags</code> missing member <code>cf_feature_version</code> on Python 3.8 and up. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PyAsyncMethods</code> missing member <code>am_send</code> on Python 3.10 and up. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PyGenObject</code> having multiple incorrect members on various Python versions. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PySyntaxErrorObject</code> missing members <code>end_lineno</code> and <code>end_offset</code> on Python 3.10 and up. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PyHeapTypeObject</code> missing member <code>ht_module</code> on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PyFrameObject</code> having multiple incorrect members on various Python versions. <a href="https://github.com/PyO3/pyo3/pull/2424">#2424</a></li>
<li>Fix FFI definition <code>PyTypeObject</code> missing deprecated field <code>tp_print</code> on Python 3.8. <a href="https://github.com/PyO3/pyo3/pull/2428">#2428</a></li>
<li>Fix FFI definitions <code>PyDateTime_CAPI</code>. <code>PyDateTime_Date</code>, <code>PyASCIIObject</code>, <code>PyBaseExceptionObject</code>, <code>PyListObject</code>, and <code>PyTypeObject</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/2428">#2428</a></li>
<li>Fix FFI definition <code>_inittab</code> field <code>initfunc</code> typo'd as <code>initfun</code>. <a href="https://github.com/PyO3/pyo3/pull/2431">#2431</a></li>
<li>Fix FFI definitions <code>_PyDateTime_BaseTime</code> and <code>_PyDateTime_BaseDateTime</code> incorrectly having <code>fold</code> member. <a href="https://github.com/PyO3/pyo3/pull/2432">#2432</a></li>
<li>Fix FFI definitions <code>PyTypeObject</code>. <code>PyHeapTypeObject</code>, and <code>PyCFunctionObject</code> having incorrect members on PyPy 3.9. <a href="https://github.com/PyO3/pyo3/pull/2428">#2428</a></li>
<li>Fix FFI definition <code>PyGetSetDef</code> to have <code>*const c_char</code> for <code>doc</code> member (not <code>*mut c_char</code>). <a href="https://github.com/PyO3/pyo3/pull/2439">#2439</a></li>
<li>Fix <code>#[pyo3(from_py_with = &quot;...&quot;)]</code> being ignored for 1-element tuple structs and transparent structs. <a href="https://github.com/PyO3/pyo3/pull/2440">#2440</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0164v01650165a---2022-05-15"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0164v01650165a---2022-05-15"><a href="https://github.com/pyo3/pyo3/compare/v0.16.4...v0.16.5">0.16.5</a> - 2022-05-15</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>Add an experimental <code>generate-import-lib</code> feature to support auto-generating non-abi3 python import libraries for Windows targets. <a href="https://github.com/PyO3/pyo3/pull/2364">#2364</a></li>
<li>Add FFI definition <code>Py_ExitStatusException</code>. <a href="https://github.com/PyO3/pyo3/pull/2374">#2374</a></li>
</ul>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li>Deprecate experimental <code>generate-abi3-import-lib</code> feature in favor of the new <code>generate-import-lib</code> feature. <a href="https://github.com/PyO3/pyo3/pull/2364">#2364</a></li>
</ul>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>Added missing <code>warn_default_encoding</code> field to <code>PyConfig</code> on 3.10+. The previously missing field could result in incorrect behavior or crashes. <a href="https://github.com/PyO3/pyo3/pull/2370">#2370</a></li>
<li>Fixed order of <code>pathconfig_warnings</code> and <code>program_name</code> fields of <code>PyConfig</code> on 3.10+. Previously, the order of the fields was swapped and this could lead to incorrect behavior or crashes. <a href="https://github.com/PyO3/pyo3/pull/2370">#2370</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0163v01640164a---2022-04-14"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0163v01640164a---2022-04-14"><a href="https://github.com/pyo3/pyo3/compare/v0.16.3...v0.16.4">0.16.4</a> - 2022-04-14</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>Add <code>PyTzInfoAccess</code> trait for safe access to time zone information. <a href="https://github.com/PyO3/pyo3/pull/2263">#2263</a></li>
<li>Add an experimental <code>generate-abi3-import-lib</code> feature to auto-generate <code>python3.dll</code> import libraries for Windows. <a href="https://github.com/PyO3/pyo3/pull/2282">#2282</a></li>
<li>Add FFI definitions for <code>PyDateTime_BaseTime</code> and <code>PyDateTime_BaseDateTime</code>. <a href="https://github.com/PyO3/pyo3/pull/2294">#2294</a></li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li>Improved performance of failing calls to <code>FromPyObject::extract</code> which is common when functions accept multiple distinct types. <a href="https://github.com/PyO3/pyo3/pull/2279">#2279</a></li>
<li>Default to &quot;m&quot; ABI tag when choosing <code>libpython</code> link name for CPython 3.7 on Unix. <a href="https://github.com/PyO3/pyo3/pull/2288">#2288</a></li>
<li>Allow to compile &quot;abi3&quot; extensions without a working build host Python interpreter. <a href="https://github.com/PyO3/pyo3/pull/2293">#2293</a></li>
</ul>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li>Crates depending on PyO3 can collect code coverage via LLVM instrumentation using stable Rust. <a href="https://github.com/PyO3/pyo3/pull/2286">#2286</a></li>
<li>Fix segfault when calling FFI methods <code>PyDateTime_DATE_GET_TZINFO</code> or <code>PyDateTime_TIME_GET_TZINFO</code> on <code>datetime</code> or <code>time</code> without a tzinfo. <a href="https://github.com/PyO3/pyo3/pull/2289">#2289</a></li>
<li>Fix directory names starting with the letter <code>n</code> breaking serialization of the interpreter configuration on Windows since PyO3 0.16.3. <a href="https://github.com/PyO3/pyo3/pull/2299">#2299</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0162v01630163a---2022-04-05"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0162v01630163a---2022-04-05"><a href="https://github.com/pyo3/pyo3/compare/v0.16.2...v0.16.3">0.16.3</a> - 2022-04-05</a></h2>
<h3 id="packaging"><a class="header" href="#packaging">Packaging</a></h3>
<ul>
<li>Extend <code>parking_lot</code> dependency supported versions to include 0.12. <a href="https://github.com/PyO3/pyo3/pull/2239">#2239</a></li>
</ul>
<h3 id="added-3"><a class="header" href="#added-3">Added</a></h3>
<ul>
<li>Add methods to <code>pyo3_build_config::InterpreterConfig</code> to run Python scripts using the configured executable. <a href="https://github.com/PyO3/pyo3/pull/2092">#2092</a></li>
<li>Add <code>as_bytes</code> method to <code>Py&lt;PyBytes&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/2235">#2235</a></li>
<li>Add FFI definitions for <code>PyType_FromModuleAndSpec</code>, <code>PyType_GetModule</code>, <code>PyType_GetModuleState</code> and <code>PyModule_AddType</code>. <a href="https://github.com/PyO3/pyo3/pull/2250">#2250</a></li>
<li>Add <code>pyo3_build_config::cross_compiling_from_to</code> as a helper to detect when PyO3 is cross-compiling. <a href="https://github.com/PyO3/pyo3/pull/2253">#2253</a></li>
<li>Add <code>#[pyclass(mapping)]</code> option to leave sequence slots empty in container implementations. <a href="https://github.com/PyO3/pyo3/pull/2265">#2265</a></li>
<li>Add <code>PyString::intern</code> to enable usage of the Python's built-in string interning. <a href="https://github.com/PyO3/pyo3/pull/2268">#2268</a></li>
<li>Add <code>intern!</code> macro which can be used to amortize the cost of creating Python strings by storing them inside a <code>GILOnceCell</code>. <a href="https://github.com/PyO3/pyo3/pull/2269">#2269</a></li>
<li>Add <code>PYO3_CROSS_PYTHON_IMPLEMENTATION</code> environment variable for selecting the default cross Python implementation. <a href="https://github.com/PyO3/pyo3/pull/2272">#2272</a></li>
</ul>
<h3 id="changed-3"><a class="header" href="#changed-3">Changed</a></h3>
<ul>
<li>Allow <code>#[pyo3(crate = &quot;...&quot;, text_signature = &quot;...&quot;)]</code> options to be used directly in <code>#[pyclass(crate = &quot;...&quot;, text_signature = &quot;...&quot;)]</code>. <a href="https://github.com/PyO3/pyo3/pull/2234">#2234</a></li>
<li>Make <code>PYO3_CROSS_LIB_DIR</code> environment variable optional when cross compiling. <a href="https://github.com/PyO3/pyo3/pull/2241">#2241</a></li>
<li>Mark <code>METH_FASTCALL</code> calling convention as limited API on Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/2250">#2250</a></li>
<li>Deprecate <code>pyo3_build_config::cross_compiling</code> in favour of <code>pyo3_build_config::cross_compiling_from_to</code>. <a href="https://github.com/PyO3/pyo3/pull/2253">#2253</a></li>
</ul>
<h3 id="fixed-3"><a class="header" href="#fixed-3">Fixed</a></h3>
<ul>
<li>Fix <code>abi3-py310</code> feature: use Python 3.10 ABI when available instead of silently falling back to the 3.9 ABI. <a href="https://github.com/PyO3/pyo3/pull/2242">#2242</a></li>
<li>Use shared linking mode when cross compiling against a <a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html">Framework bundle</a> for macOS. <a href="https://github.com/PyO3/pyo3/pull/2233">#2233</a></li>
<li>Fix panic during compilation when <code>PYO3_CROSS_LIB_DIR</code> is set for some host/target combinations. <a href="https://github.com/PyO3/pyo3/pull/2232">#2232</a></li>
<li>Correct dependency version for <code>syn</code> to require minimal patch version 1.0.56. <a href="https://github.com/PyO3/pyo3/pull/2240">#2240</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0161v01620162a---2022-03-15"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0161v01620162a---2022-03-15"><a href="https://github.com/pyo3/pyo3/compare/v0.16.1...v0.16.2">0.16.2</a> - 2022-03-15</a></h2>
<h3 id="packaging-1"><a class="header" href="#packaging-1">Packaging</a></h3>
<ul>
<li>Warn when modules are imported on PyPy 3.7 versions older than PyPy 7.3.8, as they are known to have binary compatibility issues. <a href="https://github.com/PyO3/pyo3/pull/2217">#2217</a></li>
<li>Ensure build script of <code>pyo3-ffi</code> runs before that of <code>pyo3</code> to fix cross compilation. <a href="https://github.com/PyO3/pyo3/pull/2224">#2224</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0160v01610161a---2022-03-05"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0160v01610161a---2022-03-05"><a href="https://github.com/pyo3/pyo3/compare/v0.16.0...v0.16.1">0.16.1</a> - 2022-03-05</a></h2>
<h3 id="packaging-2"><a class="header" href="#packaging-2">Packaging</a></h3>
<ul>
<li>Extend <code>hashbrown</code> optional dependency supported versions to include 0.12. <a href="https://github.com/PyO3/pyo3/pull/2197">#2197</a></li>
</ul>
<h3 id="fixed-4"><a class="header" href="#fixed-4">Fixed</a></h3>
<ul>
<li>Fix incorrect platform detection for Windows in <code>pyo3-build-config</code>. <a href="https://github.com/PyO3/pyo3/pull/2198">#2198</a></li>
<li>Fix regression from 0.16 preventing cross compiling to aarch64 macOS. <a href="https://github.com/PyO3/pyo3/pull/2201">#2201</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0151v01600160a---2022-02-27"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0151v01600160a---2022-02-27"><a href="https://github.com/pyo3/pyo3/compare/v0.15.1...v0.16.0">0.16.0</a> - 2022-02-27</a></h2>
<h3 id="packaging-3"><a class="header" href="#packaging-3">Packaging</a></h3>
<ul>
<li>Update MSRV to Rust 1.48. <a href="https://github.com/PyO3/pyo3/pull/2004">#2004</a></li>
<li>Update <code>indoc</code> optional dependency to 1.0. <a href="https://github.com/PyO3/pyo3/pull/2004">#2004</a></li>
<li>Drop support for Python 3.6, remove <code>abi3-py36</code> feature. <a href="https://github.com/PyO3/pyo3/pull/2006">#2006</a></li>
<li><code>pyo3-build-config</code> no longer enables the <code>resolve-config</code> feature by default. <a href="https://github.com/PyO3/pyo3/pull/2008">#2008</a></li>
<li>Update <code>inventory</code> optional dependency to 0.2. <a href="https://github.com/PyO3/pyo3/pull/2019">#2019</a></li>
<li>Drop <code>paste</code> dependency. <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a></li>
<li>The bindings found in <code>pyo3::ffi</code> are now a re-export of a separate <code>pyo3-ffi</code> crate. <a href="https://github.com/PyO3/pyo3/pull/2126">#2126</a></li>
<li>Support PyPy 3.9. <a href="https://github.com/PyO3/pyo3/pull/2143">#2143</a></li>
</ul>
<h3 id="added-4"><a class="header" href="#added-4">Added</a></h3>
<ul>
<li>Add <code>PyCapsule</code> type exposing the <a href="https://docs.python.org/3/c-api/capsule.html#capsules">Capsule API</a>. <a href="https://github.com/PyO3/pyo3/pull/1980">#1980</a></li>
<li>Add <code>pyo3_build_config::Sysconfigdata</code> and supporting APIs. <a href="https://github.com/PyO3/pyo3/pull/1996">#1996</a></li>
<li>Add <code>Py::setattr</code> method. <a href="https://github.com/PyO3/pyo3/pull/2009">#2009</a></li>
<li>Add <code>#[pyo3(crate = &quot;some::path&quot;)]</code> option to all attribute macros (except the deprecated <code>#[pyproto]</code>). <a href="https://github.com/PyO3/pyo3/pull/2022">#2022</a></li>
<li>Enable <code>create_exception!</code> macro to take an optional docstring. <a href="https://github.com/PyO3/pyo3/pull/2027">#2027</a></li>
<li>Enable <code>#[pyclass]</code> for fieldless (aka C-like) enums. <a href="https://github.com/PyO3/pyo3/pull/2034">#2034</a></li>
<li>Add buffer magic methods <code>__getbuffer__</code> and <code>__releasebuffer__</code> to <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2067">#2067</a></li>
<li>Add support for paths in <code>wrap_pyfunction</code> and <code>wrap_pymodule</code>. <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a></li>
<li>Enable <code>wrap_pyfunction!</code> to wrap a <code>#[pyfunction]</code> implemented in a different Rust module or crate. <a href="https://github.com/PyO3/pyo3/pull/2091">#2091</a></li>
<li>Add <code>PyAny::contains</code> method (<code>in</code> operator for <code>PyAny</code>). <a href="https://github.com/PyO3/pyo3/pull/2115">#2115</a></li>
<li>Add <code>PyMapping::contains</code> method (<code>in</code> operator for <code>PyMapping</code>). <a href="https://github.com/PyO3/pyo3/pull/2133">#2133</a></li>
<li>Add garbage collection magic magic methods <code>__traverse__</code> and <code>__clear__</code> to <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2159">#2159</a></li>
<li>Add support for <code>from_py_with</code> on struct tuples and enums to override the default from-Python conversion. <a href="https://github.com/PyO3/pyo3/pull/2181">#2181</a></li>
<li>Add <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code> methods to <code>PyAny</code> that wrap <code>rich_compare</code>. <a href="https://github.com/PyO3/pyo3/pull/2175">#2175</a></li>
<li>Add <code>Py::is</code> and <code>PyAny::is</code> methods to check for object identity. <a href="https://github.com/PyO3/pyo3/pull/2183">#2183</a></li>
<li>Add support for the <code>__getattribute__</code> magic method. <a href="https://github.com/PyO3/pyo3/pull/2187">#2187</a></li>
</ul>
<h3 id="changed-4"><a class="header" href="#changed-4">Changed</a></h3>
<ul>
<li><code>PyType::is_subclass</code>, <code>PyErr::is_instance</code> and <code>PyAny::is_instance</code> now operate run-time type object instead of a type known at compile-time. The old behavior is still available as <code>PyType::is_subclass_of</code>, <code>PyErr::is_instance_of</code> and <code>PyAny::is_instance_of</code>.  <a href="https://github.com/PyO3/pyo3/pull/1985">#1985</a></li>
<li>Rename some methods on <code>PyErr</code> (the old names are just marked deprecated for now): <a href="https://github.com/PyO3/pyo3/pull/2026">#2026</a>
<ul>
<li><code>pytype</code> -&gt; <code>get_type</code></li>
<li><code>pvalue</code> -&gt; <code>value</code> (and deprecate equivalent <code>instance</code>)</li>
<li><code>ptraceback</code> -&gt; <code>traceback</code></li>
<li><code>from_instance</code> -&gt; <code>from_value</code></li>
<li><code>into_instance</code> -&gt; <code>into_value</code></li>
</ul>
</li>
<li><code>PyErr::new_type</code> now takes an optional docstring and now returns <code>PyResult&lt;Py&lt;PyType&gt;&gt;</code> rather than a <code>ffi::PyTypeObject</code> pointer. <a href="https://github.com/PyO3/pyo3/pull/2027">#2027</a></li>
<li>Deprecate <code>PyType::is_instance</code>; it is inconsistent with other <code>is_instance</code> methods in PyO3. Instead of <code>typ.is_instance(obj)</code>, use <code>obj.is_instance(typ)</code>. <a href="https://github.com/PyO3/pyo3/pull/2031">#2031</a></li>
<li><code>__getitem__</code>, <code>__setitem__</code> and <code>__delitem__</code> in <code>#[pymethods]</code> now implement both a Python mapping and sequence by default. <a href="https://github.com/PyO3/pyo3/pull/2065">#2065</a></li>
<li>Improve performance and error messages for <code>#[derive(FromPyObject)]</code> for enums. <a href="https://github.com/PyO3/pyo3/pull/2068">#2068</a></li>
<li>Reduce generated LLVM code size (to improve compile times) for:
<ul>
<li>internal <code>handle_panic</code> helper <a href="https://github.com/PyO3/pyo3/pull/2074">#2074</a> <a href="https://github.com/PyO3/pyo3/pull/2158">#2158</a></li>
<li><code>#[pyfunction]</code> and <code>#[pymethods]</code> argument extraction <a href="https://github.com/PyO3/pyo3/pull/2075">#2075</a> <a href="https://github.com/PyO3/pyo3/pull/2085">#2085</a></li>
<li><code>#[pyclass]</code> type object creation <a href="https://github.com/PyO3/pyo3/pull/2076">#2076</a> <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a> <a href="https://github.com/PyO3/pyo3/pull/2157">#2157</a></li>
</ul>
</li>
<li>Respect Rust privacy rules for items wrapped with <code>wrap_pyfunction</code> and <code>wrap_pymodule</code>. <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a></li>
<li>Add modulo argument to <code>__ipow__</code> magic method. <a href="https://github.com/PyO3/pyo3/pull/2083">#2083</a></li>
<li>Fix FFI definition for <code>_PyCFunctionFast</code>. <a href="https://github.com/PyO3/pyo3/pull/2126">#2126</a></li>
<li><code>PyDateTimeAPI</code> and <code>PyDateTime_TimeZone_UTC</code> are are now unsafe functions instead of statics. <a href="https://github.com/PyO3/pyo3/pull/2126">#2126</a></li>
<li><code>PyDateTimeAPI</code> does not implicitly call <code>PyDateTime_IMPORT</code> anymore to reflect the original Python API more closely. Before the first call to <code>PyDateTime_IMPORT</code> a null pointer is returned. Therefore before calling any of the following FFI functions <code>PyDateTime_IMPORT</code> must be called to avoid undefined behaviour: <a href="https://github.com/PyO3/pyo3/pull/2126">#2126</a>
<ul>
<li><code>PyDateTime_TimeZone_UTC</code></li>
<li><code>PyDate_Check</code></li>
<li><code>PyDate_CheckExact</code></li>
<li><code>PyDateTime_Check</code></li>
<li><code>PyDateTime_CheckExact</code></li>
<li><code>PyTime_Check</code></li>
<li><code>PyTime_CheckExact</code></li>
<li><code>PyDelta_Check</code></li>
<li><code>PyDelta_CheckExact</code></li>
<li><code>PyTZInfo_Check</code></li>
<li><code>PyTZInfo_CheckExact</code></li>
<li><code>PyDateTime_FromTimestamp</code></li>
<li><code>PyDate_FromTimestamp</code></li>
</ul>
</li>
<li>Deprecate the <code>gc</code> option for <code>pyclass</code> (e.g. <code>#[pyclass(gc)]</code>). Just implement a <code>__traverse__</code> <code>#[pymethod]</code>. <a href="https://github.com/PyO3/pyo3/pull/2159">#2159</a></li>
<li>The <code>ml_meth</code> field of <code>PyMethodDef</code> is now represented by the <code>PyMethodDefPointer</code> union. <a href="https://github.com/PyO3/pyo3/pull/2166">2166</a></li>
<li>Deprecate the <code>#[pyproto]</code> traits. <a href="https://github.com/PyO3/pyo3/pull/2173">#2173</a></li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<ul>
<li>Remove all functionality deprecated in PyO3 0.14. <a href="https://github.com/PyO3/pyo3/pull/2007">#2007</a></li>
<li>Remove <code>Default</code> impl for <code>PyMethodDef</code>. <a href="https://github.com/PyO3/pyo3/pull/2166">#2166</a></li>
<li>Remove <code>PartialEq</code> impl for <code>Py</code> and <code>PyAny</code> (use the new <code>is()</code> instead). <a href="https://github.com/PyO3/pyo3/pull/2183">#2183</a></li>
</ul>
<h3 id="fixed-5"><a class="header" href="#fixed-5">Fixed</a></h3>
<ul>
<li>Fix undefined symbol for <code>PyObject_HasAttr</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/2025">#2025</a></li>
<li>Fix memory leak in <code>PyErr::into_value</code>. <a href="https://github.com/PyO3/pyo3/pull/2026">#2026</a></li>
<li>Fix clippy warning <code>needless-option-as-deref</code> in code generated by <code>#[pyfunction]</code> and <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2040">#2040</a></li>
<li>Fix undefined behavior in <code>PySlice::indices</code>. <a href="https://github.com/PyO3/pyo3/pull/2061">#2061</a></li>
<li>Fix the <code>wrap_pymodule!</code> macro using the wrong name for a <code>#[pymodule]</code> with a <code>#[pyo3(name = &quot;..&quot;)]</code> attribute. <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a></li>
<li>Fix magic methods in <code>#[pymethods]</code> accepting implementations with the wrong number of arguments. <a href="https://github.com/PyO3/pyo3/pull/2083">#2083</a></li>
<li>Fix panic in <code>#[pyfunction]</code> generated code when a required argument following an <code>Option</code> was not provided.  <a href="https://github.com/PyO3/pyo3/pull/2093">#2093</a></li>
<li>Fixed undefined behaviour caused by incorrect <code>ExactSizeIterator</code> implementations. <a href="https://github.com/PyO3/pyo3/pull/2124">#2124</a></li>
<li>Fix missing FFI definition <code>PyCMethod_New</code> on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/2143">#2143</a></li>
<li>Add missing FFI definitions <code>_PyLong_NumBits</code> and <code>_PyLong_AsByteArray</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/2146">#2146</a></li>
<li>Fix memory leak in implementation of <code>AsPyPointer</code> for <code>Option&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/2160">#2160</a></li>
<li>Fix FFI definition of <code>_PyLong_NumBits</code> to return <code>size_t</code> instead of <code>c_int</code>. <a href="https://github.com/PyO3/pyo3/pull/2161">#2161</a></li>
<li>Fix <code>TypeError</code> thrown when argument parsing failed missing the originating causes. <a href="https://github.com/PyO3/pyo3/pull/2178">2177</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0151v01520152a---2022-04-14"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0151v01520152a---2022-04-14"><a href="https://github.com/pyo3/pyo3/compare/v0.15.1...v0.15.2">0.15.2</a> - 2022-04-14</a></h2>
<h3 id="packaging-4"><a class="header" href="#packaging-4">Packaging</a></h3>
<ul>
<li>Backport of PyPy 3.9 support from PyO3 0.16. <a href="https://github.com/PyO3/pyo3/pull/2262">#2262</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0150v01510151a---2021-11-19"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0150v01510151a---2021-11-19"><a href="https://github.com/pyo3/pyo3/compare/v0.15.0...v0.15.1">0.15.1</a> - 2021-11-19</a></h2>
<h3 id="added-5"><a class="header" href="#added-5">Added</a></h3>
<ul>
<li>Add implementations for <code>Py::as_ref()</code> and <code>Py::into_ref()</code> for <code>Py&lt;PySequence&gt;</code>, <code>Py&lt;PyIterator&gt;</code> and <code>Py&lt;PyMapping&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1682">#1682</a></li>
<li>Add <code>PyTraceback</code> type to represent and format Python tracebacks. <a href="https://github.com/PyO3/pyo3/pull/1977">#1977</a></li>
</ul>
<h3 id="changed-5"><a class="header" href="#changed-5">Changed</a></h3>
<ul>
<li><code>#[classattr]</code> constants with a known magic method name (which is lowercase) no longer trigger lint warnings expecting constants to be uppercase. <a href="https://github.com/PyO3/pyo3/pull/1969">#1969</a></li>
</ul>
<h3 id="fixed-6"><a class="header" href="#fixed-6">Fixed</a></h3>
<ul>
<li>Fix creating <code>#[classattr]</code> by functions with the name of a known magic method. <a href="https://github.com/PyO3/pyo3/pull/1969">#1969</a></li>
<li>Fix use of <code>catch_unwind</code> in <code>allow_threads</code> which can cause fatal crashes. <a href="https://github.com/PyO3/pyo3/pull/1989">#1989</a></li>
<li>Fix build failure on PyPy when abi3 features are activated. <a href="https://github.com/PyO3/pyo3/pull/1991">#1991</a></li>
<li>Fix mingw platform detection. <a href="https://github.com/PyO3/pyo3/pull/1993">#1993</a></li>
<li>Fix panic in <code>__get__</code> implementation when accessing descriptor on type object. <a href="https://github.com/PyO3/pyo3/pull/1997">#1997</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0145v01500150a---2021-11-03"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0145v01500150a---2021-11-03"><a href="https://github.com/pyo3/pyo3/compare/v0.14.5...v0.15.0">0.15.0</a> - 2021-11-03</a></h2>
<h3 id="packaging-5"><a class="header" href="#packaging-5">Packaging</a></h3>
<ul>
<li><code>pyo3</code>'s <code>Cargo.toml</code> now advertises <code>links = &quot;python&quot;</code> to inform Cargo that it links against <em>libpython</em>. <a href="https://github.com/PyO3/pyo3/pull/1819">#1819</a></li>
<li>Added optional <code>anyhow</code> feature to convert <code>anyhow::Error</code> into <code>PyErr</code>. <a href="https://github.com/PyO3/pyo3/pull/1822">#1822</a></li>
<li>Support Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1889">#1889</a></li>
<li>Added optional <code>eyre</code> feature to convert <code>eyre::Report</code> into <code>PyErr</code>. <a href="https://github.com/PyO3/pyo3/pull/1893">#1893</a></li>
<li>Support PyPy 3.8. <a href="https://github.com/PyO3/pyo3/pull/1948">#1948</a></li>
</ul>
<h3 id="added-6"><a class="header" href="#added-6">Added</a></h3>
<ul>
<li>Add <code>PyList::get_item_unchecked</code> and <code>PyTuple::get_item_unchecked</code> to get items without bounds checks. <a href="https://github.com/PyO3/pyo3/pull/1733">#1733</a></li>
<li>Support <code>#[doc = include_str!(...)]</code> attributes on Rust 1.54 and up. <a href="https://github.com/PyO3/pyo3/issues/1746">#1746</a></li>
<li>Add <code>PyAny::py</code> as a convenience for <code>PyNativeType::py</code>. <a href="https://github.com/PyO3/pyo3/pull/1751">#1751</a></li>
<li>Add implementation of <code>std::ops::Index&lt;usize&gt;</code> for <code>PyList</code>, <code>PyTuple</code> and <code>PySequence</code>. <a href="https://github.com/PyO3/pyo3/pull/1825">#1825</a></li>
<li>Add range indexing implementations of <code>std::ops::Index</code> for <code>PyList</code>, <code>PyTuple</code> and <code>PySequence</code>. <a href="https://github.com/PyO3/pyo3/pull/1829">#1829</a></li>
<li>Add <code>PyMapping</code> type to represent the Python mapping protocol. <a href="https://github.com/PyO3/pyo3/pull/1844">#1844</a></li>
<li>Add commonly-used sequence methods to <code>PyList</code> and <code>PyTuple</code>. <a href="https://github.com/PyO3/pyo3/pull/1849">#1849</a></li>
<li>Add <code>as_sequence</code> methods to <code>PyList</code> and <code>PyTuple</code>. <a href="https://github.com/PyO3/pyo3/pull/1860">#1860</a></li>
<li>Add support for magic methods in <code>#[pymethods]</code>, intended as a replacement for <code>#[pyproto]</code>. <a href="https://github.com/PyO3/pyo3/pull/1864">#1864</a></li>
<li>Add <code>abi3-py310</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1889">#1889</a></li>
<li>Add <code>PyCFunction::new_closure</code> to create a Python function from a Rust closure. <a href="https://github.com/PyO3/pyo3/pull/1901">#1901</a></li>
<li>Add support for positional-only arguments in <code>#[pyfunction]</code>. <a href="https://github.com/PyO3/pyo3/pull/1925">#1925</a></li>
<li>Add <code>PyErr::take</code> to attempt to fetch a Python exception if present. <a href="https://github.com/PyO3/pyo3/pull/1957">#1957</a></li>
</ul>
<h3 id="changed-6"><a class="header" href="#changed-6">Changed</a></h3>
<ul>
<li><code>PyList</code>, <code>PyTuple</code> and <code>PySequence</code>'s APIs now accepts only <code>usize</code> indices instead of <code>isize</code>.
<a href="https://github.com/PyO3/pyo3/pull/1733">#1733</a>, <a href="https://github.com/PyO3/pyo3/pull/1802">#1802</a>,
<a href="https://github.com/PyO3/pyo3/pull/1803">#1803</a></li>
<li><code>PyList::get_item</code> and <code>PyTuple::get_item</code> now return <code>PyResult&lt;&amp;PyAny&gt;</code> instead of panicking. <a href="https://github.com/PyO3/pyo3/pull/1733">#1733</a></li>
<li><code>PySequence::in_place_repeat</code> and <code>PySequence::in_place_concat</code> now return <code>PyResult&lt;&amp;PySequence&gt;</code> instead of <code>PyResult&lt;()&gt;</code>, which is needed in case of immutable sequences such as tuples. <a href="https://github.com/PyO3/pyo3/pull/1803">#1803</a></li>
<li><code>PySequence::get_slice</code> now returns <code>PyResult&lt;&amp;PySequence&gt;</code> instead of <code>PyResult&lt;&amp;PyAny&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1829">#1829</a></li>
<li>Deprecate <code>PyTuple::split_from</code>. <a href="https://github.com/PyO3/pyo3/pull/1804">#1804</a></li>
<li>Deprecate <code>PyTuple::slice</code>, new method <code>PyTuple::get_slice</code> added with <code>usize</code> indices. <a href="https://github.com/PyO3/pyo3/pull/1828">#1828</a></li>
<li>Deprecate FFI definitions <code>PyParser_SimpleParseStringFlags</code>, <code>PyParser_SimpleParseStringFlagsFilename</code>, <code>PyParser_SimpleParseFileFlags</code> when building for Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/1830">#1830</a></li>
<li>Mark FFI definitions removed in Python 3.10 <code>PyParser_ASTFromString</code>, <code>PyParser_ASTFromStringObject</code>, <code>PyParser_ASTFromFile</code>, <code>PyParser_ASTFromFileObject</code>, <code>PyParser_SimpleParseStringFlags</code>, <code>PyParser_SimpleParseStringFlagsFilename</code>, <code>PyParser_SimpleParseFileFlags</code>, <code>PyParser_SimpleParseString</code>, <code>PyParser_SimpleParseFile</code>, <code>Py_SymtableString</code>, and <code>Py_SymtableStringObject</code>. <a href="https://github.com/PyO3/pyo3/pull/1830">#1830</a></li>
<li><code>#[pymethods]</code> now handles magic methods similarly to <code>#[pyproto]</code>. In the future, <code>#[pyproto]</code> may be deprecated. <a href="https://github.com/PyO3/pyo3/pull/1864">#1864</a></li>
<li>Deprecate FFI definitions <code>PySys_AddWarnOption</code>, <code>PySys_AddWarnOptionUnicode</code> and <code>PySys_HasWarnOptions</code>. <a href="https://github.com/PyO3/pyo3/pull/1887">#1887</a></li>
<li>Deprecate <code>#[call]</code> attribute in favor of using <code>fn __call__</code>. <a href="https://github.com/PyO3/pyo3/pull/1929">#1929</a></li>
<li>Fix missing FFI definition <code>_PyImport_FindExtensionObject</code> on Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1942">#1942</a></li>
<li>Change <code>PyErr::fetch</code> to panic in debug mode if no exception is present. <a href="https://github.com/PyO3/pyo3/pull/1957">#1957</a></li>
</ul>
<h3 id="fixed-7"><a class="header" href="#fixed-7">Fixed</a></h3>
<ul>
<li>Fix building with a conda environment on Windows. <a href="https://github.com/PyO3/pyo3/pull/1873">#1873</a></li>
<li>Fix panic on Python 3.6 when calling <code>Python::with_gil</code> with Python initialized but threading not initialized. <a href="https://github.com/PyO3/pyo3/pull/1874">#1874</a></li>
<li>Fix incorrect linking to version-specific DLL instead of <code>python3.dll</code> when cross-compiling to Windows with <code>abi3</code>. <a href="https://github.com/PyO3/pyo3/pull/1880">#1880</a></li>
<li>Fix FFI definition for <code>PyTuple_ClearFreeList</code> incorrectly being present for Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1887">#1887</a></li>
<li>Fix panic in generated <code>#[derive(FromPyObject)]</code> for enums. <a href="https://github.com/PyO3/pyo3/pull/1888">#1888</a></li>
<li>Fix cross-compiling to Python 3.7 builds with the &quot;m&quot; abi flag. <a href="https://github.com/PyO3/pyo3/pull/1908">#1908</a></li>
<li>Fix <code>__mod__</code> magic method fallback to <code>__rmod__</code>. <a href="https://github.com/PyO3/pyo3/pull/1934">#1934</a>.</li>
<li>Fix missing FFI definition <code>_PyImport_FindExtensionObject</code> on Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1942">#1942</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0144v01450145a---2021-09-05"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0144v01450145a---2021-09-05"><a href="https://github.com/pyo3/pyo3/compare/v0.14.4...v0.14.5">0.14.5</a> - 2021-09-05</a></h2>
<h3 id="added-7"><a class="header" href="#added-7">Added</a></h3>
<ul>
<li>Make <code>pyo3_build_config::InterpreterConfig</code> and subfields public. <a href="https://github.com/PyO3/pyo3/pull/1848">#1848</a></li>
<li>Add <code>resolve-config</code> feature to the <code>pyo3-build-config</code> to control whether its build script does anything. <a href="https://github.com/PyO3/pyo3/pull/1856">#1856</a></li>
</ul>
<h3 id="fixed-8"><a class="header" href="#fixed-8">Fixed</a></h3>
<ul>
<li>Fix 0.14.4 compile regression on <code>s390x-unknown-linux-gnu</code> target. <a href="https://github.com/PyO3/pyo3/pull/1850">#1850</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0143v01440144a---2021-08-29"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0143v01440144a---2021-08-29"><a href="https://github.com/pyo3/pyo3/compare/v0.14.3...v0.14.4">0.14.4</a> - 2021-08-29</a></h2>
<h3 id="changed-7"><a class="header" href="#changed-7">Changed</a></h3>
<ul>
<li>Mark <code>PyString::data</code> as <code>unsafe</code> and disable it and some supporting PyUnicode FFI APIs (which depend on a C bitfield) on big-endian targets. <a href="https://github.com/PyO3/pyo3/pull/1834">#1834</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0142v01430143a---2021-08-22"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0142v01430143a---2021-08-22"><a href="https://github.com/pyo3/pyo3/compare/v0.14.2...v0.14.3">0.14.3</a> - 2021-08-22</a></h2>
<h3 id="added-8"><a class="header" href="#added-8">Added</a></h3>
<ul>
<li>Add <code>PyString::data</code> to access the raw bytes stored in a Python string. <a href="https://github.com/PyO3/pyo3/pull/1794">#1794</a></li>
</ul>
<h3 id="fixed-9"><a class="header" href="#fixed-9">Fixed</a></h3>
<ul>
<li>Raise <code>AttributeError</code> to avoid panic when calling <code>del</code> on a <code>#[setter]</code> defined class property. <a href="https://github.com/PyO3/pyo3/pull/1779">#1779</a></li>
<li>Restrict FFI definitions <code>PyGILState_Check</code> and <code>Py_tracefunc</code> to the unlimited API. <a href="https://github.com/PyO3/pyo3/pull/1787">#1787</a></li>
<li>Add missing <code>_type</code> field to <code>PyStatus</code> struct definition. <a href="https://github.com/PyO3/pyo3/pull/1791">#1791</a></li>
<li>Reduce lower bound <code>num-complex</code> optional dependency to support interop with <code>rust-numpy</code> and <code>ndarray</code> when building with the MSRV of 1.41 <a href="https://github.com/PyO3/pyo3/pull/1799">#1799</a></li>
<li>Fix memory leak in <code>Python::run_code</code>. <a href="https://github.com/PyO3/pyo3/pull/1806">#1806</a></li>
<li>Fix memory leak in <code>PyModule::from_code</code>. <a href="https://github.com/PyO3/pyo3/pull/1810">#1810</a></li>
<li>Remove use of <code>pyo3::</code> in <code>pyo3::types::datetime</code> which broke builds using <code>-Z avoid-dev-deps</code> <a href="https://github.com/PyO3/pyo3/pull/1811">#1811</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0141v01420142a---2021-08-09"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0141v01420142a---2021-08-09"><a href="https://github.com/pyo3/pyo3/compare/v0.14.1...v0.14.2">0.14.2</a> - 2021-08-09</a></h2>
<h3 id="added-9"><a class="header" href="#added-9">Added</a></h3>
<ul>
<li>Add <code>indexmap</code> feature to add <code>ToPyObject</code>, <code>IntoPy</code> and <code>FromPyObject</code> implementations for <code>indexmap::IndexMap</code>. <a href="https://github.com/PyO3/pyo3/pull/1728">#1728</a></li>
<li>Add <code>pyo3_build_config::add_extension_module_link_args</code> to use in build scripts to set linker arguments (for macOS). <a href="https://github.com/PyO3/pyo3/pull/1755">#1755</a></li>
<li>Add <code>Python::with_gil_unchecked</code> unsafe variation of <code>Python::with_gil</code> to allow obtaining a <code>Python</code> in scenarios where <code>Python::with_gil</code> would fail. <a href="https://github.com/PyO3/pyo3/pull/1769">#1769</a></li>
</ul>
<h3 id="changed-8"><a class="header" href="#changed-8">Changed</a></h3>
<ul>
<li><code>PyErr::new</code> no longer acquires the Python GIL internally. <a href="https://github.com/PyO3/pyo3/pull/1724">#1724</a></li>
<li>Reverted PyO3 0.14.0's use of <code>cargo:rustc-cdylib-link-arg</code> in its build script, as Cargo unintentionally allowed crates to pass linker args to downstream crates in this way. Projects supporting macOS may need to restore <code>.cargo/config.toml</code> files. <a href="https://github.com/PyO3/pyo3/pull/1755">#1755</a></li>
</ul>
<h3 id="fixed-10"><a class="header" href="#fixed-10">Fixed</a></h3>
<ul>
<li>Fix regression in 0.14.0 rejecting usage of <code>#[doc(hidden)]</code> on structs and functions annotated with PyO3 macros. <a href="https://github.com/PyO3/pyo3/pull/1722">#1722</a></li>
<li>Fix regression in 0.14.0 leading to incorrect code coverage being computed for <code>#[pyfunction]</code>s. <a href="https://github.com/PyO3/pyo3/pull/1726">#1726</a></li>
<li>Fix incorrect FFI definition of <code>Py_Buffer</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/1737">#1737</a></li>
<li>Fix incorrect calculation of <code>dictoffset</code> on 32-bit Windows. <a href="https://github.com/PyO3/pyo3/pull/1475">#1475</a></li>
<li>Fix regression in 0.13.2 leading to linking to incorrect Python library on Windows &quot;gnu&quot; targets. <a href="https://github.com/PyO3/pyo3/pull/1759">#1759</a></li>
<li>Fix compiler warning: deny trailing semicolons in expression macro. <a href="https://github.com/PyO3/pyo3/pull/1762">#1762</a></li>
<li>Fix incorrect FFI definition of <code>Py_DecodeLocale</code>. The 2nd argument is now <code>*mut Py_ssize_t</code> instead of <code>Py_ssize_t</code>. <a href="https://github.com/PyO3/pyo3/pull/1766">#1766</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0140v01410141a---2021-07-04"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0140v01410141a---2021-07-04"><a href="https://github.com/pyo3/pyo3/compare/v0.14.0...v0.14.1">0.14.1</a> - 2021-07-04</a></h2>
<h3 id="added-10"><a class="header" href="#added-10">Added</a></h3>
<ul>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>&amp;PathBuf</code> and <code>&amp;OsString</code>. <a href="https://github.com/PyO3/pyo3/pull/1712">#1712</a></li>
</ul>
<h3 id="fixed-11"><a class="header" href="#fixed-11">Fixed</a></h3>
<ul>
<li>Fix crashes on PyPy due to incorrect definitions of <code>PyList_SET_ITEM</code>. <a href="https://github.com/PyO3/pyo3/pull/1713">#1713</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0132v01400140a---2021-07-03"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0132v01400140a---2021-07-03"><a href="https://github.com/pyo3/pyo3/compare/v0.13.2...v0.14.0">0.14.0</a> - 2021-07-03</a></h2>
<h3 id="packaging-6"><a class="header" href="#packaging-6">Packaging</a></h3>
<ul>
<li>Update <code>num-bigint</code> optional dependency to 0.4. <a href="https://github.com/PyO3/pyo3/pull/1481">#1481</a></li>
<li>Update <code>num-complex</code> optional dependency to 0.4. <a href="https://github.com/PyO3/pyo3/pull/1482">#1482</a></li>
<li>Extend <code>hashbrown</code> optional dependency supported versions to include 0.11. <a href="https://github.com/PyO3/pyo3/pull/1496">#1496</a></li>
<li>Support PyPy 3.7. <a href="https://github.com/PyO3/pyo3/pull/1538">#1538</a></li>
</ul>
<h3 id="added-11"><a class="header" href="#added-11">Added</a></h3>
<ul>
<li>Extend conversions for <code>[T; N]</code> to all <code>N</code> using const generics (on Rust 1.51 and up). <a href="https://github.com/PyO3/pyo3/pull/1128">#1128</a></li>
<li>Add conversions between <code>OsStr</code>/ <code>OsString</code> and Python strings. <a href="https://github.com/PyO3/pyo3/pull/1379">#1379</a></li>
<li>Add conversions between <code>Path</code>/ <code>PathBuf</code> and Python strings (and <code>pathlib.Path</code> objects). <a href="https://github.com/PyO3/pyo3/pull/1379">#1379</a> <a href="https://github.com/PyO3/pyo3/pull/1654">#1654</a></li>
<li>Add a new set of <code>#[pyo3(...)]</code> attributes to control various PyO3 macro functionality:
<ul>
<li><code>#[pyo3(from_py_with = &quot;...&quot;)]</code> function arguments and struct fields to override the default from-Python conversion. <a href="https://github.com/PyO3/pyo3/pull/1411">#1411</a></li>
<li><code>#[pyo3(name = &quot;...&quot;)]</code> for setting Python names. <a href="https://github.com/PyO3/pyo3/pull/1567">#1567</a></li>
<li><code>#[pyo3(text_signature = &quot;...&quot;)]</code> for setting text signature. <a href="https://github.com/PyO3/pyo3/pull/1658">#1658</a></li>
</ul>
</li>
<li>Add FFI definition <code>PyCFunction_CheckExact</code> for Python 3.9 and later. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>Add FFI definition <code>Py_IS_TYPE</code>. <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li>Add FFI definition <code>_Py_InitializeMain</code>. <a href="https://github.com/PyO3/pyo3/pull/1473">#1473</a></li>
<li>Add FFI definitions from <code>cpython/import.h</code>.<a href="https://github.com/PyO3/pyo3/pull/1475">#1475</a></li>
<li>Add tuple and unit struct support for <code>#[pyclass]</code> macro. <a href="https://github.com/PyO3/pyo3/pull/1504">#1504</a></li>
<li>Add FFI definition <code>PyDateTime_TimeZone_UTC</code>. <a href="https://github.com/PyO3/pyo3/pull/1572">#1572</a></li>
<li>Add support for <code>#[pyclass(extends=Exception)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1591">#1591</a></li>
<li>Add <code>PyErr::cause</code> and <code>PyErr::set_cause</code>. <a href="https://github.com/PyO3/pyo3/pull/1679">#1679</a></li>
<li>Add FFI definitions from <code>cpython/pystate.h</code>. <a href="https://github.com/PyO3/pyo3/pull/1687/">#1687</a></li>
<li>Add <code>wrap_pyfunction!</code> macro to <code>pyo3::prelude</code>. <a href="https://github.com/PyO3/pyo3/pull/1695">#1695</a></li>
</ul>
<h3 id="changed-9"><a class="header" href="#changed-9">Changed</a></h3>
<ul>
<li>Allow only one <code>#[pymethods]</code> block per <code>#[pyclass]</code> by default, to remove the dependency on <code>inventory</code>. Add a <code>multiple-pymethods</code> feature to opt-in the original behavior and dependency on <code>inventory</code>. <a href="https://github.com/PyO3/pyo3/pull/1457">#1457</a></li>
<li>Change <code>PyTimeAccess::get_fold</code> to return a <code>bool</code> instead of a <code>u8</code>. <a href="https://github.com/PyO3/pyo3/pull/1397">#1397</a></li>
<li>Deprecate FFI definition <code>PyCFunction_Call</code> for Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>Deprecate FFI definition <code>PyModule_GetFilename</code>. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>The <code>auto-initialize</code> feature is no longer enabled by default. <a href="https://github.com/PyO3/pyo3/pull/1443">#1443</a></li>
<li>Change <code>PyCFunction::new</code> and <code>PyCFunction::new_with_keywords</code> to take <code>&amp;'static str</code> arguments rather than implicitly copying (and leaking) them. <a href="https://github.com/PyO3/pyo3/pull/1450">#1450</a></li>
<li>Deprecate <code>PyModule::call</code>, <code>PyModule::call0</code>, <code>PyModule::call1</code> and <code>PyModule::get</code>. <a href="https://github.com/PyO3/pyo3/pull/1492">#1492</a></li>
<li>Add length information to <code>PyBufferError</code>s raised from <code>PyBuffer::copy_to_slice</code> and <code>PyBuffer::copy_from_slice</code>. <a href="https://github.com/PyO3/pyo3/pull/1534">#1534</a></li>
<li>Automatically set <code>-undefined</code> and <code>dynamic_lookup</code> linker arguments on macOS with the <code>extension-module</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1539">#1539</a></li>
<li>Deprecate <code>#[pyproto]</code> methods which are easier to implement as <code>#[pymethods]</code>: <a href="https://github.com/PyO3/pyo3/pull/1560">#1560</a>
<ul>
<li><code>PyBasicProtocol::__bytes__</code> and <code>PyBasicProtocol::__format__</code></li>
<li><code>PyContextProtocol::__enter__</code> and <code>PyContextProtocol::__exit__</code></li>
<li><code>PyDescrProtocol::__delete__</code> and <code>PyDescrProtocol::__set_name__</code></li>
<li><code>PyMappingProtocol::__reversed__</code></li>
<li><code>PyNumberProtocol::__complex__</code> and <code>PyNumberProtocol::__round__</code></li>
<li><code>PyAsyncProtocol::__aenter__</code> and <code>PyAsyncProtocol::__aexit__</code></li>
</ul>
</li>
<li>Deprecate several attributes in favor of the new <code>#[pyo3(...)]</code> options:
<ul>
<li><code>#[name = &quot;...&quot;]</code>, replaced by <code>#[pyo3(name = &quot;...&quot;)]</code> <a href="https://github.com/PyO3/pyo3/pull/1567">#1567</a></li>
<li><code>#[pyfn(m, &quot;name&quot;)]</code>, replaced by <code>#[pyfn(m)] #[pyo3(name = &quot;...&quot;)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1610">#1610</a></li>
<li><code>#[pymodule(name)]</code>, replaced by <code>#[pymodule] #[pyo3(name = &quot;...&quot;)]</code> <a href="https://github.com/PyO3/pyo3/pull/1650">#1650</a></li>
<li><code>#[text_signature = &quot;...&quot;]</code>, replaced by <code>#[pyo3(text_signature = &quot;...&quot;)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1658">#1658</a></li>
</ul>
</li>
<li>Reduce LLVM line counts to improve compilation times. <a href="https://github.com/PyO3/pyo3/pull/1604">#1604</a></li>
<li>No longer call <code>PyEval_InitThreads</code> in <code>#[pymodule]</code> init code. <a href="https://github.com/PyO3/pyo3/pull/1630">#1630</a></li>
<li>Use <code>METH_FASTCALL</code> argument passing convention, when possible, to improve <code>#[pyfunction]</code> and method performance.
<a href="https://github.com/PyO3/pyo3/pull/1619">#1619</a>, <a href="https://github.com/PyO3/pyo3/pull/1660">#1660</a></li>
<li>Filter sysconfigdata candidates by architecture when cross-compiling. <a href="https://github.com/PyO3/pyo3/pull/1626">#1626</a></li>
</ul>
<h3 id="removed-1"><a class="header" href="#removed-1">Removed</a></h3>
<ul>
<li>Remove deprecated exception names <code>BaseException</code> etc. <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li>Remove deprecated methods <code>Python::is_instance</code>, <code>Python::is_subclass</code>, <code>Python::release</code>, <code>Python::xdecref</code>, and <code>Py::from_owned_ptr_or_panic</code>. <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li>Remove many FFI definitions which never existed in the Python C-API:
<ul>
<li>(previously deprecated) <code>PyGetSetDef_INIT</code>, <code>PyGetSetDef_DICT</code>, <code>PyCoro_Check</code>, <code>PyCoroWrapper_Check</code>, and <code>PyAsyncGen_Check</code> <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li><code>PyMethodDef_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li><code>PyTypeObject_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li><code>PyObject_Check</code>, <code>PySuper_Check</code>, and <code>FreeFunc</code> <a href="https://github.com/PyO3/pyo3/pull/1438">#1438</a></li>
<li><code>PyModuleDef_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1630">#1630</a></li>
</ul>
</li>
<li>Remove pyclass implementation details from <code>PyTypeInfo</code>:
<ul>
<li><code>Type</code>, <code>DESCRIPTION</code>, and <code>FLAGS</code> <a href="https://github.com/PyO3/pyo3/pull/1456">#1456</a></li>
<li><code>BaseType</code>, <code>BaseLayout</code>, <code>Layout</code>, <code>Initializer</code> <a href="https://github.com/PyO3/pyo3/pull/1596">#1596</a></li>
</ul>
</li>
<li>Remove <code>PYO3_CROSS_INCLUDE_DIR</code> environment variable and the associated C header parsing functionality. <a href="https://github.com/PyO3/pyo3/pull/1521">#1521</a></li>
<li>Remove <code>raw_pycfunction!</code> macro. <a href="https://github.com/PyO3/pyo3/pull/1619">#1619</a></li>
<li>Remove <code>PyClassAlloc</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1657">#1657</a></li>
<li>Remove <code>PyList::get_parked_item</code>. <a href="https://github.com/PyO3/pyo3/pull/1664">#1664</a></li>
</ul>
<h3 id="fixed-12"><a class="header" href="#fixed-12">Fixed</a></h3>
<ul>
<li>Remove FFI definition <code>PyCFunction_ClearFreeList</code> for Python 3.9 and later. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li><code>PYO3_CROSS_LIB_DIR</code> environment variable no long required when compiling for x86-64 Python from macOS arm64 and reverse. <a href="https://github.com/PyO3/pyo3/pull/1428">#1428</a></li>
<li>Fix FFI definition <code>_PyEval_RequestCodeExtraIndex</code>, which took an argument of the wrong type. <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li>Fix FFI definition <code>PyIndex_Check</code> missing with the <code>abi3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1436">#1436</a></li>
<li>Fix incorrect <code>TypeError</code> raised when keyword-only argument passed along with a positional argument in <code>*args</code>. <a href="https://github.com/PyO3/pyo3/pull/1440">#1440</a></li>
<li>Fix inability to use a named lifetime for <code>&amp;PyTuple</code> of <code>*args</code> in <code>#[pyfunction]</code>. <a href="https://github.com/PyO3/pyo3/pull/1440">#1440</a></li>
<li>Fix use of Python argument for <code>#[pymethods]</code> inside macro expansions. <a href="https://github.com/PyO3/pyo3/pull/1505">#1505</a></li>
<li>No longer include <code>__doc__</code> in <code>__all__</code> generated for <code>#[pymodule]</code>. <a href="https://github.com/PyO3/pyo3/pull/1509">#1509</a></li>
<li>Always use cross-compiling configuration if any of the <code>PYO3_CROSS</code> family of environment variables are set. <a href="https://github.com/PyO3/pyo3/pull/1514">#1514</a></li>
<li>Support <code>EnvironmentError</code>, <code>IOError</code>, and <code>WindowsError</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/1533">#1533</a></li>
<li>Fix unnecessary rebuilds when cycling between <code>cargo check</code> and <code>cargo clippy</code> in a Python virtualenv. <a href="https://github.com/PyO3/pyo3/pull/1557">#1557</a></li>
<li>Fix segfault when dereferencing <code>ffi::PyDateTimeAPI</code> without the GIL. <a href="https://github.com/PyO3/pyo3/pull/1563">#1563</a></li>
<li>Fix memory leak in <code>FromPyObject</code> implementations for <code>u128</code> and <code>i128</code>. <a href="https://github.com/PyO3/pyo3/pull/1638">#1638</a></li>
<li>Fix <code>#[pyclass(extends=PyDict)]</code> leaking the dict contents on drop. <a href="https://github.com/PyO3/pyo3/pull/1657">#1657</a></li>
<li>Fix segfault when calling <code>PyList::get_item</code> with negative indices. <a href="https://github.com/PyO3/pyo3/pull/1668">#1668</a></li>
<li>Fix FFI definitions of <code>PyEval_SetProfile</code>/<code>PyEval_SetTrace</code> to take <code>Option&lt;Py_tracefunc&gt;</code> parameters. <a href="https://github.com/PyO3/pyo3/pull/1692">#1692</a></li>
<li>Fix <code>ToPyObject</code> impl for <code>HashSet</code> to accept non-default hashers. <a href="https://github.com/PyO3/pyo3/pull/1702">#1702</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0131v01320132a---2021-02-12"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0131v01320132a---2021-02-12"><a href="https://github.com/pyo3/pyo3/compare/v0.13.1...v0.13.2">0.13.2</a> - 2021-02-12</a></h2>
<h3 id="packaging-7"><a class="header" href="#packaging-7">Packaging</a></h3>
<ul>
<li>Lower minimum supported Rust version to 1.41. <a href="https://github.com/PyO3/pyo3/pull/1421">#1421</a></li>
</ul>
<h3 id="added-12"><a class="header" href="#added-12">Added</a></h3>
<ul>
<li>Add unsafe API <code>with_embedded_python_interpreter</code> to initialize a Python interpreter, execute a closure, and finalize the interpreter. <a href="https://github.com/PyO3/pyo3/pull/1355">#1355</a></li>
<li>Add <code>serde</code> feature which provides implementations of <code>Serialize</code> and <code>Deserialize</code> for <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1366">#1366</a></li>
<li>Add FFI definition <code>_PyCFunctionFastWithKeywords</code> on Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1384">#1384</a></li>
<li>Add <code>PyDateTime::new_with_fold</code> method. <a href="https://github.com/PyO3/pyo3/pull/1398">#1398</a></li>
<li>Add <code>size_hint</code> impls for <code>{PyDict,PyList,PySet,PyTuple}Iterator</code>s. <a href="https://github.com/PyO3/pyo3/pull/1699">#1699</a></li>
</ul>
<h3 id="changed-10"><a class="header" href="#changed-10">Changed</a></h3>
<ul>
<li><code>prepare_freethreaded_python</code> will no longer register an <code>atexit</code> handler to call <code>Py_Finalize</code>. This resolves a number of issues with incompatible C extensions causing crashes at finalization. <a href="https://github.com/PyO3/pyo3/pull/1355">#1355</a></li>
<li>Mark <code>PyLayout::py_init</code>, <code>PyClassDict::clear_dict</code>, and <code>opt_to_pyobj</code> safe, as they do not perform any unsafe operations. <a href="https://github.com/PyO3/pyo3/pull/1404">#1404</a></li>
</ul>
<h3 id="fixed-13"><a class="header" href="#fixed-13">Fixed</a></h3>
<ul>
<li>Fix support for using <code>r#raw_idents</code> as argument names in pyfunctions. <a href="https://github.com/PyO3/pyo3/pull/1383">#1383</a></li>
<li>Fix typo in FFI definition for <code>PyFunction_GetCode</code> (was incorrectly <code>PyFunction_Code</code>). <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix FFI definitions <code>PyMarshal_WriteObjectToString</code> and <code>PyMarshal_ReadObjectFromString</code> as available in limited API. <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix FFI definitions <code>PyListObject</code> and those from <code>funcobject.h</code> as requiring non-limited API. <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix unqualified <code>Result</code> usage in <code>pyobject_native_type_base</code>. <a href="https://github.com/PyO3/pyo3/pull/1402">#1402</a></li>
<li>Fix build on systems where the default Python encoding is not UTF-8. <a href="https://github.com/PyO3/pyo3/pull/1405">#1405</a></li>
<li>Fix build on mingw / MSYS2. <a href="https://github.com/PyO3/pyo3/pull/1423">#1423</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0130v01310131a---2021-01-10"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0130v01310131a---2021-01-10"><a href="https://github.com/pyo3/pyo3/compare/v0.13.0...v0.13.1">0.13.1</a> - 2021-01-10</a></h2>
<h3 id="added-13"><a class="header" href="#added-13">Added</a></h3>
<ul>
<li>Add support for <code>#[pyclass(dict)]</code> and <code>#[pyclass(weakref)]</code> with the <code>abi3</code> feature on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1342">#1342</a></li>
<li>Add FFI definitions <code>PyOS_BeforeFork</code>, <code>PyOS_AfterFork_Parent</code>, <code>PyOS_AfterFork_Child</code> for Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Add an <code>auto-initialize</code> feature to control whether PyO3 should automatically initialize an embedded Python interpreter. For compatibility this feature is enabled by default in PyO3 0.13.1, but is planned to become opt-in from PyO3 0.14.0. <a href="https://github.com/PyO3/pyo3/pull/1347">#1347</a></li>
<li>Add support for cross-compiling to Windows without needing <code>PYO3_CROSS_INCLUDE_DIR</code>. <a href="https://github.com/PyO3/pyo3/pull/1350">#1350</a></li>
</ul>
<h3 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h3>
<ul>
<li>Deprecate FFI definitions <code>PyEval_CallObjectWithKeywords</code>, <code>PyEval_CallObject</code>, <code>PyEval_CallFunction</code>, <code>PyEval_CallMethod</code> when building for Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/1338">#1338</a></li>
<li>Deprecate FFI definitions <code>PyGetSetDef_DICT</code> and <code>PyGetSetDef_INIT</code> which have never been in the Python API. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Deprecate FFI definitions <code>PyGen_NeedsFinalizing</code>, <code>PyImport_Cleanup</code> (removed in 3.9), and <code>PyOS_InitInterrupts</code> (3.10). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definition <code>PyOS_AfterFork</code> for Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definitions <code>PyCoro_Check</code>, <code>PyAsyncGen_Check</code>, and <code>PyCoroWrapper_Check</code>, which have never been in the Python API (for the first two, it is possible to use <code>PyCoro_CheckExact</code> and <code>PyAsyncGen_CheckExact</code> instead; these are the actual functions provided by the Python API). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definitions for <code>PyUnicode_FromUnicode</code>, <code>PyUnicode_AsUnicode</code> and <code>PyUnicode_AsUnicodeAndSize</code>, which will be removed from 3.12 and up due to <a href="https://www.python.org/dev/peps/pep-0623/">PEP 613</a>. <a href="https://github.com/PyO3/pyo3/pull/1370">#1370</a></li>
</ul>
<h3 id="removed-2"><a class="header" href="#removed-2">Removed</a></h3>
<ul>
<li>Remove FFI definition <code>PyFrame_ClearFreeList</code> when building for Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Remove FFI definition <code>_PyDict_Contains</code> when building for Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Remove FFI definitions <code>PyGen_NeedsFinalizing</code> and <code>PyImport_Cleanup</code> (for 3.9 and up), and <code>PyOS_InitInterrupts</code> (3.10). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
</ul>
<h3 id="fixed-14"><a class="header" href="#fixed-14">Fixed</a></h3>
<ul>
<li>Stop including <code>Py_TRACE_REFS</code> config setting automatically if <code>Py_DEBUG</code> is set on Python 3.8 and up. <a href="https://github.com/PyO3/pyo3/pull/1334">#1334</a></li>
<li>Remove <code>#[deny(warnings)]</code> attribute (and instead refuse warnings only in CI). <a href="https://github.com/PyO3/pyo3/pull/1340">#1340</a></li>
<li>Fix deprecation warning for missing <code>__module__</code> with <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/1343">#1343</a></li>
<li>Correct return type of <code>PyFrozenSet::empty</code> to <code>&amp;PyFrozenSet</code> (was incorrectly <code>&amp;PySet</code>). <a href="https://github.com/PyO3/pyo3/pull/1351">#1351</a></li>
<li>Fix missing <code>Py_INCREF</code> on heap type objects on Python versions before 3.8. <a href="https://github.com/PyO3/pyo3/pull/1365">#1365</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0124v01300130a---2020-12-22"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0124v01300130a---2020-12-22"><a href="https://github.com/pyo3/pyo3/compare/v0.12.4...v0.13.0">0.13.0</a> - 2020-12-22</a></h2>
<h3 id="packaging-8"><a class="header" href="#packaging-8">Packaging</a></h3>
<ul>
<li>Drop support for Python 3.5 (as it is now end-of-life). <a href="https://github.com/PyO3/pyo3/pull/1250">#1250</a></li>
<li>Bump minimum supported Rust version to 1.45. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Bump indoc dependency to 1.0. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Bump paste dependency to 1.0. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Rename internal crates <code>pyo3cls</code> and <code>pyo3-derive-backend</code> to <code>pyo3-macros</code> and <code>pyo3-macros-backend</code> respectively. <a href="https://github.com/PyO3/pyo3/pull/1317">#1317</a></li>
</ul>
<h3 id="added-14"><a class="header" href="#added-14">Added</a></h3>
<ul>
<li>Add support for building for CPython limited API. Opting-in to the limited API enables a single extension wheel built with PyO3 to be installable on multiple Python versions. This required a few minor changes to runtime behaviour of of PyO3 <code>#[pyclass]</code> types. See the migration guide for full details. <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a>
<ul>
<li>Add feature flags <code>abi3-py36</code>, <code>abi3-py37</code>, <code>abi3-py38</code> etc. to set the minimum Python version when using the limited API. <a href="https://github.com/PyO3/pyo3/pull/1263">#1263</a></li>
</ul>
</li>
<li>Add argument names to <code>TypeError</code> messages generated by pymethod wrappers. <a href="https://github.com/PyO3/pyo3/pull/1212">#1212</a></li>
<li>Add FFI definitions for PEP 587 &quot;Python Initialization Configuration&quot;. <a href="https://github.com/PyO3/pyo3/pull/1247">#1247</a></li>
<li>Add FFI definitions for <code>PyEval_SetProfile</code> and <code>PyEval_SetTrace</code>. <a href="https://github.com/PyO3/pyo3/pull/1255">#1255</a></li>
<li>Add FFI definitions for context.h functions (<code>PyContext_New</code>, etc). <a href="https://github.com/PyO3/pyo3/pull/1259">#1259</a></li>
<li>Add <code>PyAny::is_instance</code> method. <a href="https://github.com/PyO3/pyo3/pull/1276">#1276</a></li>
<li>Add support for conversion between <code>char</code> and <code>PyString</code>. <a href="https://github.com/PyO3/pyo3/pull/1282">#1282</a></li>
<li>Add FFI definitions for <code>PyBuffer_SizeFromFormat</code>, <code>PyObject_LengthHint</code>, <code>PyObject_CallNoArgs</code>, <code>PyObject_CallOneArg</code>, <code>PyObject_CallMethodNoArgs</code>, <code>PyObject_CallMethodOneArg</code>, <code>PyObject_VectorcallDict</code>, and <code>PyObject_VectorcallMethod</code>. <a href="https://github.com/PyO3/pyo3/pull/1287">#1287</a></li>
<li>Add conversions between <code>u128</code>/<code>i128</code> and <code>PyLong</code> for PyPy. <a href="https://github.com/PyO3/pyo3/pull/1310">#1310</a></li>
<li>Add <code>Python::version</code> and <code>Python::version_info</code> to get the running interpreter version. <a href="https://github.com/PyO3/pyo3/pull/1322">#1322</a></li>
<li>Add conversions for tuples of length 10, 11, and 12. <a href="https://github.com/PyO3/pyo3/pull/1454">#1454</a></li>
</ul>
<h3 id="changed-11"><a class="header" href="#changed-11">Changed</a></h3>
<ul>
<li>Change return type of <code>PyType::name</code> from <code>Cow&lt;str&gt;</code> to <code>PyResult&lt;&amp;str&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a></li>
<li><code>#[pyclass(subclass)]</code> is now required for subclassing from Rust (was previously just required for subclassing from Python). <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a></li>
<li>Change <code>PyIterator</code> to be consistent with other native types: it is now used as <code>&amp;PyIterator</code> instead of <code>PyIterator&lt;'a&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1176">#1176</a></li>
<li>Change formatting of <code>PyDowncastError</code> messages to be closer to Python's builtin error messages. <a href="https://github.com/PyO3/pyo3/pull/1212">#1212</a></li>
<li>Change <code>Debug</code> and <code>Display</code> impls for <code>PyException</code> to be consistent with <code>PyAny</code>. <a href="https://github.com/PyO3/pyo3/pull/1275">#1275</a></li>
<li>Change <code>Debug</code> impl of <code>PyErr</code> to output more helpful information (acquiring the GIL if necessary). <a href="https://github.com/PyO3/pyo3/pull/1275">#1275</a></li>
<li>Rename <code>PyTypeInfo::is_instance</code> and <code>PyTypeInfo::is_exact_instance</code> to <code>PyTypeInfo::is_type_of</code> and <code>PyTypeInfo::is_exact_type_of</code>. <a href="https://github.com/PyO3/pyo3/pull/1278">#1278</a></li>
<li>Optimize <code>PyAny::call0</code>, <code>Py::call0</code> and <code>PyAny::call_method0</code> and <code>Py::call_method0</code> on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1285">#1287</a></li>
<li>Require double-quotes for pyclass name argument e.g <code>#[pyclass(name = &quot;MyClass&quot;)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1303">#1303</a></li>
</ul>
<h3 id="deprecated-1"><a class="header" href="#deprecated-1">Deprecated</a></h3>
<ul>
<li>Deprecate <code>Python::is_instance</code>, <code>Python::is_subclass</code>, <code>Python::release</code>, and <code>Python::xdecref</code>. <a href="https://github.com/PyO3/pyo3/pull/1292">#1292</a></li>
</ul>
<h3 id="removed-3"><a class="header" href="#removed-3">Removed</a></h3>
<ul>
<li>Remove deprecated ffi definitions <code>PyUnicode_AsUnicodeCopy</code>, <code>PyUnicode_GetMax</code>, <code>_Py_CheckRecursionLimit</code>, <code>PyObject_AsCharBuffer</code>, <code>PyObject_AsReadBuffer</code>, <code>PyObject_CheckReadBuffer</code> and <code>PyObject_AsWriteBuffer</code>, which will be removed in Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1217">#1217</a></li>
<li>Remove unused <code>python3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1235">#1235</a></li>
</ul>
<h3 id="fixed-15"><a class="header" href="#fixed-15">Fixed</a></h3>
<ul>
<li>Fix missing field in <code>PyCodeObject</code> struct (<code>co_posonlyargcount</code>) - caused invalid access to other fields in Python &gt;3.7. <a href="https://github.com/PyO3/pyo3/pull/1260">#1260</a></li>
<li>Fix building for <code>x86_64-unknown-linux-musl</code> target from <code>x86_64-unknown-linux-gnu</code> host. <a href="https://github.com/PyO3/pyo3/pull/1267">#1267</a></li>
<li>Fix <code>#[text_signature]</code> interacting badly with rust <code>r#raw_identifiers</code>. <a href="https://github.com/PyO3/pyo3/pull/1286">#1286</a></li>
<li>Fix FFI definitions for <code>PyObject_Vectorcall</code> and <code>PyVectorcall_Call</code>. <a href="https://github.com/PyO3/pyo3/pull/1285">#1287</a></li>
<li>Fix building with Anaconda python inside a virtualenv. <a href="https://github.com/PyO3/pyo3/pull/1290">#1290</a></li>
<li>Fix definition of opaque FFI types. <a href="https://github.com/PyO3/pyo3/pull/1312">#1312</a></li>
<li>Fix using custom error type in pyclass <code>#[new]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/1319">#1319</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0123v01240124a---2020-11-28"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0123v01240124a---2020-11-28"><a href="https://github.com/pyo3/pyo3/compare/v0.12.3...v0.12.4">0.12.4</a> - 2020-11-28</a></h2>
<h3 id="fixed-16"><a class="header" href="#fixed-16">Fixed</a></h3>
<ul>
<li>Fix reference count bug in implementation of <code>From&lt;Py&lt;T&gt;&gt;</code> for <code>PyObject</code>, a regression introduced in PyO3 0.12. <a href="https://github.com/PyO3/pyo3/pull/1297">#1297</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0122v01230123a---2020-10-12"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0122v01230123a---2020-10-12"><a href="https://github.com/pyo3/pyo3/compare/v0.12.2...v0.12.3">0.12.3</a> - 2020-10-12</a></h2>
<h3 id="fixed-17"><a class="header" href="#fixed-17">Fixed</a></h3>
<ul>
<li>Fix support for Rust versions 1.39 to 1.44, broken by an incorrect internal update to paste 1.0 which was done in PyO3 0.12.2. <a href="https://github.com/PyO3/pyo3/pull/1234">#1234</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0121v01220122a---2020-10-12"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0121v01220122a---2020-10-12"><a href="https://github.com/pyo3/pyo3/compare/v0.12.1...v0.12.2">0.12.2</a> - 2020-10-12</a></h2>
<h3 id="added-15"><a class="header" href="#added-15">Added</a></h3>
<ul>
<li>Add support for keyword-only arguments without default values in <code>#[pyfunction]</code>. <a href="https://github.com/PyO3/pyo3/pull/1209">#1209</a></li>
<li>Add <code>Python::check_signals</code> as a safe a wrapper for <code>PyErr_CheckSignals</code>. <a href="https://github.com/PyO3/pyo3/pull/1214">#1214</a></li>
</ul>
<h3 id="fixed-18"><a class="header" href="#fixed-18">Fixed</a></h3>
<ul>
<li>Fix invalid document for protocol methods. <a href="https://github.com/PyO3/pyo3/pull/1169">#1169</a></li>
<li>Hide docs of PyO3 private implementation details in <code>pyo3::class::methods</code>. <a href="https://github.com/PyO3/pyo3/pull/1169">#1169</a></li>
<li>Fix unnecessary rebuild on PATH changes when the python interpreter is provided by PYO3_PYTHON. <a href="https://github.com/PyO3/pyo3/pull/1231">#1231</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0120v01210121a---2020-09-16"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0120v01210121a---2020-09-16"><a href="https://github.com/pyo3/pyo3/compare/v0.12.0...v0.12.1">0.12.1</a> - 2020-09-16</a></h2>
<h3 id="fixed-19"><a class="header" href="#fixed-19">Fixed</a></h3>
<ul>
<li>Fix building for a 32-bit Python on 64-bit Windows with a 64-bit Rust toolchain. <a href="https://github.com/PyO3/pyo3/pull/1179">#1179</a></li>
<li>Fix building on platforms where <code>c_char</code> is <code>u8</code>. <a href="https://github.com/PyO3/pyo3/pull/1182">#1182</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0111v01200120a---2020-09-12"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0111v01200120a---2020-09-12"><a href="https://github.com/pyo3/pyo3/compare/v0.11.1...v0.12.0">0.12.0</a> - 2020-09-12</a></h2>
<h3 id="added-16"><a class="header" href="#added-16">Added</a></h3>
<ul>
<li>Add FFI definitions <code>Py_FinalizeEx</code>, <code>PyOS_getsig</code>, and <code>PyOS_setsig</code>. <a href="https://github.com/PyO3/pyo3/pull/1021">#1021</a></li>
<li>Add <code>PyString::to_str</code> for accessing <code>PyString</code> as <code>&amp;str</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Add <code>Python::with_gil</code> for executing a closure with the Python GIL. <a href="https://github.com/PyO3/pyo3/pull/1037">#1037</a></li>
<li>Add type information to failures in <code>PyAny::downcast</code>. <a href="https://github.com/PyO3/pyo3/pull/1050">#1050</a></li>
<li>Implement <code>Debug</code> for <code>PyIterator</code>. <a href="https://github.com/PyO3/pyo3/pull/1051">#1051</a></li>
<li>Add <code>PyBytes::new_with</code> and <code>PyByteArray::new_with</code> for initialising <code>bytes</code> and <code>bytearray</code> objects using a closure. <a href="https://github.com/PyO3/pyo3/pull/1074">#1074</a></li>
<li>Add <code>#[derive(FromPyObject)]</code> macro for enums and structs. <a href="https://github.com/PyO3/pyo3/pull/1065">#1065</a></li>
<li>Add <code>Py::as_ref</code> and <code>Py::into_ref</code> for converting <code>Py&lt;T&gt;</code> to <code>&amp;T</code>. <a href="https://github.com/PyO3/pyo3/pull/1098">#1098</a></li>
<li>Add ability to return <code>Result</code> types other than <code>PyResult</code> from <code>#[pyfunction]</code>, <code>#[pymethod]</code> and <code>#[pyproto]</code> functions. <a href="https://github.com/PyO3/pyo3/pull/1118">#1106</a>.</li>
<li>Implement <code>ToPyObject</code>, <code>IntoPy</code>, and <code>FromPyObject</code> for <a href="https://crates.io/crates/hashbrown">hashbrown</a>'s <code>HashMap</code> and <code>HashSet</code> types (requires the <code>hashbrown</code> feature). <a href="https://github.com/PyO3/pyo3/pull/1114">#1114</a></li>
<li>Add <code>#[pyfunction(pass_module)]</code> and <code>#[pyfn(pass_module)]</code> to pass the module object as the first function argument. <a href="https://github.com/PyO3/pyo3/pull/1143">#1143</a></li>
<li>Add <code>PyModule::add_function</code> and <code>PyModule::add_submodule</code> as typed alternatives to <code>PyModule::add_wrapped</code>. <a href="https://github.com/PyO3/pyo3/pull/1143">#1143</a></li>
<li>Add native <code>PyCFunction</code> and <code>PyFunction</code> types. <a href="https://github.com/PyO3/pyo3/pull/1163">#1163</a></li>
</ul>
<h3 id="changed-12"><a class="header" href="#changed-12">Changed</a></h3>
<ul>
<li>Rework exception types: <a href="https://github.com/PyO3/pyo3/pull/1024">#1024</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a>
<ul>
<li>Rename exception types from e.g. <code>RuntimeError</code> to <code>PyRuntimeError</code>. The old names continue to exist but are deprecated.</li>
<li>Exception objects are now accessible as <code>&amp;T</code> or <code>Py&lt;T&gt;</code>, just like other Python-native types.</li>
<li>Rename <code>PyException::py_err</code> to <code>PyException::new_err</code>.</li>
<li>Rename <code>PyUnicodeDecodeErr::new_err</code> to <code>PyUnicodeDecodeErr::new</code>.</li>
<li>Remove <code>PyStopIteration::stop_iteration</code>.</li>
</ul>
</li>
<li>Require <code>T: Send</code> for the return value <code>T</code> of <code>Python::allow_threads</code>. <a href="https://github.com/PyO3/pyo3/pull/1036">#1036</a></li>
<li>Rename <code>PYTHON_SYS_EXECUTABLE</code> to <code>PYO3_PYTHON</code>. The old name will continue to work (undocumented) but will be removed in a future release. <a href="https://github.com/PyO3/pyo3/pull/1039">#1039</a></li>
<li>Remove <code>unsafe</code> from signature of <code>PyType::as_type_ptr</code>. <a href="https://github.com/PyO3/pyo3/pull/1047">#1047</a></li>
<li>Change return type of <code>PyIterator::from_object</code> to <code>PyResult&lt;PyIterator&gt;</code> (was <code>Result&lt;PyIterator, PyDowncastError&gt;</code>). <a href="https://github.com/PyO3/pyo3/pull/1051">#1051</a></li>
<li><code>IntoPy</code> is no longer implied by <code>FromPy</code>. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Change <code>PyObject</code> to be a type alias for <code>Py&lt;PyAny&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Rework <code>PyErr</code> to be compatible with the <code>std::error::Error</code> trait: <a href="https://github.com/PyO3/pyo3/pull/1067">#1067</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a>
<ul>
<li>Implement <code>Display</code>, <code>Error</code>, <code>Send</code> and <code>Sync</code> for <code>PyErr</code> and <code>PyErrArguments</code>.</li>
<li>Add <code>PyErr::instance</code> for accessing <code>PyErr</code> as <code>&amp;PyBaseException</code>.</li>
<li><code>PyErr</code>'s fields are now an implementation detail. The equivalent values can be accessed with <code>PyErr::ptype</code>, <code>PyErr::pvalue</code> and <code>PyErr::ptraceback</code>.</li>
<li>Change receiver of <code>PyErr::print</code> and <code>PyErr::print_and_set_sys_last_vars</code> to <code>&amp;self</code> (was <code>self</code>).</li>
<li>Remove <code>PyErrValue</code>, <code>PyErr::from_value</code>, <code>PyErr::into_normalized</code>, and <code>PyErr::normalize</code>.</li>
<li>Remove <code>PyException::into</code>.</li>
<li>Remove <code>Into&lt;PyResult&lt;T&gt;&gt;</code> for <code>PyErr</code> and <code>PyException</code>.</li>
</ul>
</li>
<li>Change methods generated by <code>#[pyproto]</code> to return <code>NotImplemented</code> if Python should try a reversed operation. #<a href="https://github.com/PyO3/pyo3/pull/1072">1072</a></li>
<li>Change argument to <code>PyModule::add</code> to <code>impl IntoPy&lt;PyObject&gt;</code> (was <code>impl ToPyObject</code>). #<a href="https://github.com/PyO3/pyo3/pull/1124">1124</a></li>
</ul>
<h3 id="removed-4"><a class="header" href="#removed-4">Removed</a></h3>
<ul>
<li>Remove many exception and <code>PyErr</code> APIs; see the &quot;changed&quot; section above. <a href="https://github.com/PyO3/pyo3/pull/1024">#1024</a> <a href="https://github.com/PyO3/pyo3/pull/1067">#1067</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a></li>
<li>Remove <code>PyString::to_string</code> (use new <code>PyString::to_str</code>). <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>PyString::as_bytes</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>Python::register_any</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>GILGuard::acquire</code> from the public API. Use <code>Python::acquire_gil</code> or <code>Python::with_gil</code>. <a href="https://github.com/PyO3/pyo3/pull/1036">#1036</a></li>
<li>Remove the <code>FromPy</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Remove the <code>AsPyRef</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1098">#1098</a></li>
</ul>
<h3 id="fixed-20"><a class="header" href="#fixed-20">Fixed</a></h3>
<ul>
<li>Correct FFI definitions <code>Py_SetProgramName</code> and <code>Py_SetPythonHome</code> to take <code>*const</code> arguments (was <code>*mut</code>). <a href="https://github.com/PyO3/pyo3/pull/1021">#1021</a></li>
<li>Fix <code>FromPyObject</code> for <code>num_bigint::BigInt</code> for Python objects with an <code>__index__</code> method. <a href="https://github.com/PyO3/pyo3/pull/1027">#1027</a></li>
<li>Correct FFI definition <code>_PyLong_AsByteArray</code> to take <code>*mut c_uchar</code> argument (was <code>*const c_uchar</code>). <a href="https://github.com/PyO3/pyo3/pull/1029">#1029</a></li>
<li>Fix segfault with <code>#[pyclass(dict, unsendable)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1058">#1058</a> <a href="https://github.com/PyO3/pyo3/pull/1059">#1059</a></li>
<li>Fix using <code>&amp;Self</code> as an argument type for functions in a <code>#[pymethods]</code> block. <a href="https://github.com/PyO3/pyo3/pull/1071">#1071</a></li>
<li>Fix best-effort build against PyPy 3.6. <a href="https://github.com/PyO3/pyo3/pull/1092">#1092</a></li>
<li>Fix many cases of lifetime elision in <code>#[pyproto]</code> implementations. <a href="https://github.com/PyO3/pyo3/pull/1093">#1093</a></li>
<li>Fix detection of Python build configuration when cross-compiling. <a href="https://github.com/PyO3/pyo3/pull/1095">#1095</a></li>
<li>Always link against libpython on android with the <code>extension-module</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1095">#1095</a></li>
<li>Fix the <code>+</code> operator not trying <code>__radd__</code> when both <code>__add__</code> and <code>__radd__</code> are defined in <code>PyNumberProtocol</code> (and similar for all other reversible operators). <a href="https://github.com/PyO3/pyo3/pull/1107">#1107</a></li>
<li>Fix building with Anaconda python. <a href="https://github.com/PyO3/pyo3/pull/1175">#1175</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0110v01110111a---2020-06-30"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0110v01110111a---2020-06-30"><a href="https://github.com/pyo3/pyo3/compare/v0.11.0...v0.11.1">0.11.1</a> - 2020-06-30</a></h2>
<h3 id="added-17"><a class="header" href="#added-17">Added</a></h3>
<ul>
<li><code>#[pyclass(unsendable)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1009">#1009</a></li>
</ul>
<h3 id="changed-13"><a class="header" href="#changed-13">Changed</a></h3>
<ul>
<li>Update <code>parking_lot</code> dependency to <code>0.11</code>. <a href="https://github.com/PyO3/pyo3/pull/1010">#1010</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0101v01100110a---2020-06-28"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0101v01100110a---2020-06-28"><a href="https://github.com/pyo3/pyo3/compare/v0.10.1...v0.11.0">0.11.0</a> - 2020-06-28</a></h2>
<h3 id="added-18"><a class="header" href="#added-18">Added</a></h3>
<ul>
<li>Support stable versions of Rust (&gt;=1.39). <a href="https://github.com/PyO3/pyo3/pull/969">#969</a></li>
<li>Add FFI definition <code>PyObject_AsFileDescriptor</code>. <a href="https://github.com/PyO3/pyo3/pull/938">#938</a></li>
<li>Add <code>PyByteArray::data</code>, <code>PyByteArray::as_bytes</code>, and <code>PyByteArray::as_bytes_mut</code>. <a href="https://github.com/PyO3/pyo3/pull/967">#967</a></li>
<li>Add <code>GILOnceCell</code> to use in situations where <code>lazy_static</code> or <code>once_cell</code> can deadlock. <a href="https://github.com/PyO3/pyo3/pull/975">#975</a></li>
<li>Add <code>Py::borrow</code>, <code>Py::borrow_mut</code>, <code>Py::try_borrow</code>, and <code>Py::try_borrow_mut</code> for accessing <code>#[pyclass]</code> values. <a href="https://github.com/PyO3/pyo3/pull/976">#976</a></li>
<li>Add <code>IterNextOutput</code> and <code>IterANextOutput</code> for returning from <code>__next__</code> / <code>__anext__</code>. <a href="https://github.com/PyO3/pyo3/pull/997">#997</a></li>
</ul>
<h3 id="changed-14"><a class="header" href="#changed-14">Changed</a></h3>
<ul>
<li>Simplify internals of <code>#[pyo3(get)]</code> attribute. (Remove the hidden API <code>GetPropertyValue</code>.) <a href="https://github.com/PyO3/pyo3/pull/934">#934</a></li>
<li>Call <code>Py_Finalize</code> at exit to flush buffers, etc. <a href="https://github.com/PyO3/pyo3/pull/943">#943</a></li>
<li>Add type parameter to PyBuffer. #<a href="https://github.com/PyO3/pyo3/pull/951">951</a></li>
<li>Require <code>Send</code> bound for <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/966">#966</a></li>
<li>Add <code>Python</code> argument to most methods on <code>PyObject</code> and <code>Py&lt;T&gt;</code> to ensure GIL safety. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change signature of <code>PyTypeObject::type_object</code> - now takes <code>Python</code> argument and returns <code>&amp;PyType</code>. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change return type of <code>PyTuple::slice</code> and <code>PyTuple::split_from</code> from <code>Py&lt;PyTuple&gt;</code> to <code>&amp;PyTuple</code>. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change return type of <code>PyTuple::as_slice</code> to <code>&amp;[&amp;PyAny]</code>. <a href="https://github.com/PyO3/pyo3/pull/971">#971</a></li>
<li>Rename <code>PyTypeInfo::type_object</code> to <code>type_object_raw</code>, and add <code>Python</code> argument. <a href="https://github.com/PyO3/pyo3/pull/975">#975</a></li>
<li>Update <code>num-complex</code> optional dependendency from <code>0.2</code> to <code>0.3</code>. <a href="https://github.com/PyO3/pyo3/pull/977">#977</a></li>
<li>Update <code>num-bigint</code> optional dependendency from <code>0.2</code> to <code>0.3</code>. <a href="https://github.com/PyO3/pyo3/pull/978">#978</a></li>
<li><code>#[pyproto]</code> is re-implemented without specialization. <a href="https://github.com/PyO3/pyo3/pull/961">#961</a></li>
<li><code>PyClassAlloc::alloc</code> is renamed to <code>PyClassAlloc::new</code>. <a href="https://github.com/PyO3/pyo3/pull/990">#990</a></li>
<li><code>#[pyproto]</code> methods can now have return value <code>T</code> or <code>PyResult&lt;T&gt;</code> (previously only <code>PyResult&lt;T&gt;</code> was supported). <a href="https://github.com/PyO3/pyo3/pull/996">#996</a></li>
<li><code>#[pyproto]</code> methods can now skip annotating the return type if it is <code>()</code>. <a href="https://github.com/PyO3/pyo3/pull/998">#998</a></li>
</ul>
<h3 id="removed-5"><a class="header" href="#removed-5">Removed</a></h3>
<ul>
<li>Remove <code>ManagedPyRef</code> (unused, and needs specialization) <a href="https://github.com/PyO3/pyo3/pull/930">#930</a></li>
</ul>
<h3 id="fixed-21"><a class="header" href="#fixed-21">Fixed</a></h3>
<ul>
<li>Fix passing explicit <code>None</code> to <code>Option&lt;T&gt;</code> argument <code>#[pyfunction]</code> with a default value. <a href="https://github.com/PyO3/pyo3/pull/936">#936</a></li>
<li>Fix <code>PyClass.__new__</code>'s not respecting subclasses when inherited by a Python class. <a href="https://github.com/PyO3/pyo3/pull/990">#990</a></li>
<li>Fix returning <code>Option&lt;T&gt;</code> from <code>#[pyproto]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/996">#996</a></li>
<li>Fix accepting <code>PyRef&lt;Self&gt;</code> and <code>PyRefMut&lt;Self&gt;</code> to <code>#[getter]</code> and <code>#[setter]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/999">#999</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev0100v01010101a---2020-05-14"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev0100v01010101a---2020-05-14"><a href="https://github.com/pyo3/pyo3/compare/v0.10.0...v0.10.1">0.10.1</a> - 2020-05-14</a></h2>
<h3 id="fixed-22"><a class="header" href="#fixed-22">Fixed</a></h3>
<ul>
<li>Fix deadlock in <code>Python::acquire_gil</code> after dropping a <code>PyObject</code> or <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/924">#924</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev092v01000100a---2020-05-13"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev092v01000100a---2020-05-13"><a href="https://github.com/pyo3/pyo3/compare/v0.9.2...v0.10.0">0.10.0</a> - 2020-05-13</a></h2>
<h3 id="added-19"><a class="header" href="#added-19">Added</a></h3>
<ul>
<li>Add FFI definition <code>_PyDict_NewPresized</code>. <a href="https://github.com/PyO3/pyo3/pull/849">#849</a></li>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>HashSet</code> and <code>BTreeSet</code>. <a href="https://github.com/PyO3/pyo3/pull/864">#864</a></li>
<li>Add <code>PyAny::dir</code> method. <a href="https://github.com/PyO3/pyo3/pull/886">#886</a></li>
<li>Gate macros behind a <code>macros</code> feature (enabled by default). <a href="https://github.com/PyO3/pyo3/pull/897">#897</a></li>
<li>Add ability to define class attributes using <code>#[classattr]</code> on functions in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/905">#905</a></li>
<li>Implement <code>Clone</code> for <code>PyObject</code> and <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/908">#908</a></li>
<li>Implement <code>Deref&lt;Target = PyAny&gt;</code> for all builtin types. (<code>PyList</code>, <code>PyTuple</code>, <code>PyDict</code> etc.) <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Implement <code>Deref&lt;Target = PyAny&gt;</code> for <code>PyCell&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Add <code>#[classattr]</code> support for associated constants in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/914">#914</a></li>
</ul>
<h3 id="changed-15"><a class="header" href="#changed-15">Changed</a></h3>
<ul>
<li>Panics will now be raised as a Python <code>PanicException</code>. <a href="https://github.com/PyO3/pyo3/pull/797">#797</a></li>
<li>Change <code>PyObject</code> and <code>Py&lt;T&gt;</code> reference counts to decrement immediately upon drop when the GIL is held. <a href="https://github.com/PyO3/pyo3/pull/851">#851</a></li>
<li>Allow <code>PyIterProtocol</code> methods to use either <code>PyRef</code> or <code>PyRefMut</code> as the receiver type. <a href="https://github.com/PyO3/pyo3/pull/856">#856</a></li>
<li>Change the implementation of <code>FromPyObject</code> for <code>Py&lt;T&gt;</code> to apply to a wider range of <code>T</code>, including all <code>T: PyClass</code>. <a href="https://github.com/PyO3/pyo3/pull/880">#880</a></li>
<li>Move all methods from the <code>ObjectProtocol</code> trait to the <code>PyAny</code> struct. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove need for <code>#![feature(specialization)]</code> in crates depending on PyO3. <a href="https://github.com/PyO3/pyo3/pull/917">#917</a></li>
</ul>
<h3 id="removed-6"><a class="header" href="#removed-6">Removed</a></h3>
<ul>
<li>Remove <code>PyMethodsProtocol</code> trait. <a href="https://github.com/PyO3/pyo3/pull/889">#889</a></li>
<li>Remove <code>num-traits</code> dependency. <a href="https://github.com/PyO3/pyo3/pull/895">#895</a></li>
<li>Remove <code>ObjectProtocol</code> trait. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove <code>PyAny::None</code>. Users should use <code>Python::None</code> instead. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove all <code>*ProtocolImpl</code> traits. <a href="https://github.com/PyO3/pyo3/pull/917">#917</a></li>
</ul>
<h3 id="fixed-23"><a class="header" href="#fixed-23">Fixed</a></h3>
<ul>
<li>Fix support for <code>__radd__</code> and other <code>__r*__</code> methods as implementations for Python mathematical operators. <a href="https://github.com/PyO3/pyo3/pull/839">#839</a></li>
<li>Fix panics during garbage collection when traversing objects that were already mutably borrowed. <a href="https://github.com/PyO3/pyo3/pull/855">#855</a></li>
<li>Prevent <code>&amp;'static</code> references to Python objects as arguments to <code>#[pyfunction]</code> and <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/869">#869</a></li>
<li>Fix lifetime safety bug with <code>AsPyRef::as_ref</code>. <a href="https://github.com/PyO3/pyo3/pull/876">#876</a></li>
<li>Fix <code>#[pyo3(get)]</code> attribute on <code>Py&lt;T&gt;</code> fields. <a href="https://github.com/PyO3/pyo3/pull/880">#880</a></li>
<li>Fix segmentation faults caused by functions such as <code>PyList::get_item</code> returning borrowed objects when it was not safe to do so. <a href="https://github.com/PyO3/pyo3/pull/890">#890</a></li>
<li>Fix segmentation faults caused by nested <code>Python::acquire_gil</code> calls creating dangling references. <a href="https://github.com/PyO3/pyo3/pull/893">#893</a></li>
<li>Fix segmentatation faults when a panic occurs during a call to <code>Python::allow_threads</code>. <a href="https://github.com/PyO3/pyo3/pull/912">#912</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev091v092092a---2020-04-09"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev091v092092a---2020-04-09"><a href="https://github.com/pyo3/pyo3/compare/v0.9.1...v0.9.2">0.9.2</a> - 2020-04-09</a></h2>
<h3 id="added-20"><a class="header" href="#added-20">Added</a></h3>
<ul>
<li><code>FromPyObject</code> implementations for <code>HashSet</code> and <code>BTreeSet</code>. <a href="https://github.com/PyO3/pyo3/pull/842">#842</a></li>
</ul>
<h3 id="fixed-24"><a class="header" href="#fixed-24">Fixed</a></h3>
<ul>
<li>Correctly detect 32bit architecture. <a href="https://github.com/PyO3/pyo3/pull/830">#830</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev090v091091a---2020-03-23"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev090v091091a---2020-03-23"><a href="https://github.com/pyo3/pyo3/compare/v0.9.0...v0.9.1">0.9.1</a> - 2020-03-23</a></h2>
<h3 id="fixed-25"><a class="header" href="#fixed-25">Fixed</a></h3>
<ul>
<li>Error messages for <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/826">#826</a></li>
<li><code>FromPyObject</code> implementation for <code>PySequence</code>. <a href="https://github.com/PyO3/pyo3/pull/827">#827</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev085v090090a---2020-03-19"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev085v090090a---2020-03-19"><a href="https://github.com/pyo3/pyo3/compare/v0.8.5...v0.9.0">0.9.0</a> - 2020-03-19</a></h2>
<h3 id="added-21"><a class="header" href="#added-21">Added</a></h3>
<ul>
<li><code>PyCell</code>, which has RefCell-like features. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyClass</code>, <code>PyLayout</code>, <code>PyClassInitializer</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li>Implemented <code>IntoIterator</code> for <code>PySet</code> and <code>PyFrozenSet</code>. <a href="https://github.com/PyO3/pyo3/pull/716">#716</a></li>
<li><code>FromPyObject</code> is now automatically implemented for <code>T: Clone</code> pyclasses. <a href="https://github.com/PyO3/pyo3/pull/730">#730</a></li>
<li><code>#[pyo3(get)]</code> and <code>#[pyo3(set)]</code> will now use the Rust doc-comment from the field for the Python property. <a href="https://github.com/PyO3/pyo3/pull/755">#755</a></li>
<li><code>#[setter]</code> functions may now take an argument of <code>Pyo3::Python</code>. <a href="https://github.com/PyO3/pyo3/pull/760">#760</a></li>
<li><code>PyTypeInfo::BaseLayout</code> and <code>PyClass::BaseNativeType</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyDowncastImpl</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li>Implement <code>FromPyObject</code> and <code>IntoPy&lt;PyObject&gt;</code> traits for arrays (up to 32). <a href="https://github.com/PyO3/pyo3/pull/778">#778</a></li>
<li><code>migration.md</code> and <code>types.md</code> in the guide. <a href="https://github.com/PyO3/pyo3/pull/795">#795</a>, #<a href="https://github.com/PyO3/pyo3/pull/802">802</a></li>
<li><code>ffi::{_PyBytes_Resize, _PyDict_Next, _PyDict_Contains, _PyDict_GetDictPtr}</code>. #<a href="https://github.com/PyO3/pyo3/pull/820">820</a></li>
</ul>
<h3 id="changed-16"><a class="header" href="#changed-16">Changed</a></h3>
<ul>
<li><code>#[new]</code> does not take <code>PyRawObject</code> and can return <code>Self</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li>The blanket implementations for <code>FromPyObject</code> for <code>&amp;T</code> and <code>&amp;mut T</code> are no longer specializable. Implement <code>PyTryFrom</code> for your type to control the behavior of <code>FromPyObject::extract</code> for your types. <a href="https://github.com/PyO3/pyo3/pull/713">#713</a></li>
<li>The implementation for <code>IntoPy&lt;U&gt; for T</code> where <code>U: FromPy&lt;T&gt;</code> is no longer specializable. Control the behavior of this via the implementation of <code>FromPy</code>. <a href="https://github.com/PyO3/pyo3/pull/713">#713</a></li>
<li>Use <code>parking_lot::Mutex</code> instead of <code>spin::Mutex</code>. <a href="https://github.com/PyO3/pyo3/pull/734">#734</a></li>
<li>Bumped minimum Rust version to <code>1.42.0-nightly 2020-01-21</code>. <a href="https://github.com/PyO3/pyo3/pull/761">#761</a></li>
<li><code>PyRef</code> and <code>PyRefMut</code> are renewed for <code>PyCell</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li>Some new FFI functions for Python 3.8. <a href="https://github.com/PyO3/pyo3/pull/784">#784</a></li>
<li><code>PyAny</code> is now on the top level module and prelude. <a href="https://github.com/PyO3/pyo3/pull/816">#816</a></li>
</ul>
<h3 id="removed-7"><a class="header" href="#removed-7">Removed</a></h3>
<ul>
<li><code>PyRawObject</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li><code>PyNoArgsFunction</code>. <a href="https://github.com/PyO3/pyo3/pull/741">#741</a></li>
<li><code>initialize_type</code>. To set the module name for a <code>#[pyclass]</code>, use the <code>module</code> argument to the macro. #<a href="https://github.com/PyO3/pyo3/pull/751">751</a></li>
<li><code>AsPyRef::as_mut/with/with_mut/into_py/into_mut_py</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyTryFrom::try_from_mut/try_from_mut_exact/try_from_mut_unchecked</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>Python::mut_from_owned_ptr/mut_from_borrowed_ptr</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>ObjectProtocol::get_base/get_mut_base</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
</ul>
<h3 id="fixed-26"><a class="header" href="#fixed-26">Fixed</a></h3>
<ul>
<li>Fixed unsoundness of subclassing. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a>.</li>
<li>Clear error indicator when the exception is handled on the Rust side. <a href="https://github.com/PyO3/pyo3/pull/719">#719</a></li>
<li>Usage of raw identifiers with <code>#[pyo3(set)]</code>. <a href="https://github.com/PyO3/pyo3/pull/745">#745</a></li>
<li>Usage of <code>PyObject</code> with <code>#[pyo3(get)]</code>. <a href="https://github.com/PyO3/pyo3/pull/760">#760</a></li>
<li><code>#[pymethods]</code> used in conjunction with <code>#[cfg]</code>. #<a href="https://github.com/PyO3/pyo3/pull/769">769</a></li>
<li><code>&quot;*&quot;</code> in a <code>#[pyfunction()]</code> argument list incorrectly accepting any number of positional arguments (use <code>args = &quot;*&quot;</code> when this behaviour is desired). #<a href="https://github.com/PyO3/pyo3/pull/792">792</a></li>
<li><code>PyModule::dict</code>. #<a href="https://github.com/PyO3/pyo3/pull/809">809</a></li>
<li>Fix the case where <code>DESCRIPTION</code> is not null-terminated. #<a href="https://github.com/PyO3/pyo3/pull/822">822</a></li>
</ul>
<h2 id="085---2020-01-05"><a class="header" href="#085---2020-01-05">[0.8.5] - 2020-01-05</a></h2>
<h3 id="added-22"><a class="header" href="#added-22">Added</a></h3>
<ul>
<li>Implemented <code>FromPyObject</code> for <code>HashMap</code> and <code>BTreeMap</code></li>
<li>Support for <code>#[name = &quot;foo&quot;]</code> attribute for <code>#[pyfunction]</code> and in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/692">#692</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev084v085084a---2019-12-14"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev084v085084a---2019-12-14"><a href="https://github.com/pyo3/pyo3/compare/v0.8.4...v0.8.5">0.8.4</a> - 2019-12-14</a></h2>
<h3 id="added-23"><a class="header" href="#added-23">Added</a></h3>
<ul>
<li>Support for <code>#[text_signature]</code> attribute. <a href="https://github.com/PyO3/pyo3/pull/675">#675</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev082v083083a---2019-11-23"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev082v083083a---2019-11-23"><a href="https://github.com/pyo3/pyo3/compare/v0.8.2...v0.8.3">0.8.3</a> - 2019-11-23</a></h2>
<h3 id="removed-8"><a class="header" href="#removed-8">Removed</a></h3>
<ul>
<li><code>#[init]</code> is removed. <a href="https://github.com/PyO3/pyo3/pull/658">#658</a></li>
</ul>
<h3 id="fixed-27"><a class="header" href="#fixed-27">Fixed</a></h3>
<ul>
<li>Now all <code>&amp;Py~</code> types have <code>!Send</code> bound. <a href="https://github.com/PyO3/pyo3/pull/655">#655</a></li>
<li>Fix a compile error raised by the stabilization of <code>!</code> type. <a href="https://github.com/PyO3/pyo3/issues/672">#672</a>.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev081v082082a---2019-10-27"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev081v082082a---2019-10-27"><a href="https://github.com/pyo3/pyo3/compare/v0.8.1...v0.8.2">0.8.2</a> - 2019-10-27</a></h2>
<h3 id="added-24"><a class="header" href="#added-24">Added</a></h3>
<ul>
<li>FFI compatibility for PEP 590 Vectorcall. <a href="https://github.com/PyO3/pyo3/pull/641">#641</a></li>
</ul>
<h3 id="fixed-28"><a class="header" href="#fixed-28">Fixed</a></h3>
<ul>
<li>Fix PySequenceProtocol::set_item. <a href="https://github.com/PyO3/pyo3/pull/624">#624</a></li>
<li>Fix a corner case of BigInt::FromPyObject. <a href="https://github.com/PyO3/pyo3/pull/630">#630</a></li>
<li>Fix index errors in parameter conversion. <a href="https://github.com/PyO3/pyo3/pull/631">#631</a></li>
<li>Fix handling of invalid utf-8 sequences in <code>PyString::as_bytes</code>. <a href="https://github.com/PyO3/pyo3/pull/639">#639</a>
and <code>PyString::to_string_lossy</code> <a href="https://github.com/PyO3/pyo3/pull/642">#642</a>.</li>
<li>Remove <code>__contains__</code> and <code>__iter__</code> from PyMappingProtocol. <a href="https://github.com/PyO3/pyo3/pull/644">#644</a></li>
<li>Fix proc-macro definition of PySetAttrProtocol. <a href="https://github.com/PyO3/pyo3/pull/645">#645</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev080v081081a---2019-10-08"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev080v081081a---2019-10-08"><a href="https://github.com/pyo3/pyo3/compare/v0.8.0...v0.8.1">0.8.1</a> - 2019-10-08</a></h2>
<h3 id="added-25"><a class="header" href="#added-25">Added</a></h3>
<ul>
<li>Conversion between <a href="https://github.com/rust-num/num-bigint">num-bigint</a> and Python int. <a href="https://github.com/PyO3/pyo3/pull/608">#608</a></li>
</ul>
<h3 id="fixed-29"><a class="header" href="#fixed-29">Fixed</a></h3>
<ul>
<li>Make sure the right Python interpreter is used in OSX builds. <a href="https://github.com/PyO3/pyo3/pull/604">#604</a></li>
<li>Patch specialization being broken by Rust 1.40. <a href="https://github.com/PyO3/pyo3/issues/614">#614</a></li>
<li>Fix a segfault around PyErr. <a href="https://github.com/PyO3/pyo3/pull/597">#597</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev070v080080a---2019-09-16"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev070v080080a---2019-09-16"><a href="https://github.com/pyo3/pyo3/compare/v0.7.0...v0.8.0">0.8.0</a> - 2019-09-16</a></h2>
<h3 id="added-26"><a class="header" href="#added-26">Added</a></h3>
<ul>
<li><code>module</code> argument to <code>pyclass</code> macro. <a href="https://github.com/PyO3/pyo3/pull/499">#499</a></li>
<li><code>py_run!</code> macro <a href="https://github.com/PyO3/pyo3/pull/512">#512</a></li>
<li>Use existing fields and methods before calling custom <strong>getattr</strong>. <a href="https://github.com/PyO3/pyo3/pull/505">#505</a></li>
<li><code>PyBytes</code> can now be indexed just like <code>Vec&lt;u8&gt;</code></li>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>PyRef</code> and <code>PyRefMut</code>.</li>
</ul>
<h3 id="changed-17"><a class="header" href="#changed-17">Changed</a></h3>
<ul>
<li>Implementing the Using the <code>gc</code> parameter for <code>pyclass</code> (e.g. <code>#[pyclass(gc)]</code>) without implementing the <code>class::PyGCProtocol</code> trait is now a compile-time error. Failing to implement this trait could lead to segfaults. <a href="https://github.com/PyO3/pyo3/pull/532">#532</a></li>
<li><code>PyByteArray::data</code> has been replaced with <code>PyDataArray::to_vec</code> because returning a <code>&amp;[u8]</code> is unsound. (See <a href="https://github.com/PyO3/pyo3/issues/373#issuecomment-512332696">this comment</a> for a great write-up for why that was unsound)</li>
<li>Replace <code>mashup</code> with <code>paste</code>.</li>
<li><code>GILPool</code> gained a <code>Python</code> marker to prevent it from being misused to release Python objects without the GIL held.</li>
</ul>
<h3 id="removed-9"><a class="header" href="#removed-9">Removed</a></h3>
<ul>
<li><code>IntoPyObject</code> was replaced with <code>IntoPy&lt;PyObject&gt;</code></li>
<li><code>#[pyclass(subclass)]</code> is hidden a <code>unsound-subclass</code> feature because it's causing segmentation faults.</li>
</ul>
<h3 id="fixed-30"><a class="header" href="#fixed-30">Fixed</a></h3>
<ul>
<li>More readable error message for generics in pyclass <a href="https://github.com/PyO3/pyo3/pull/503">#503</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev060v070070a---2019-05-26"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev060v070070a---2019-05-26"><a href="https://github.com/pyo3/pyo3/compare/v0.6.0...v0.7.0">0.7.0</a> - 2019-05-26</a></h2>
<h3 id="added-27"><a class="header" href="#added-27">Added</a></h3>
<ul>
<li>PyPy support by omerbenamram in <a href="https://github.com/PyO3/pyo3/pull/393">#393</a></li>
<li>Have <code>PyModule</code> generate an index of its members (<code>__all__</code> list).</li>
<li>Allow <code>slf: PyRef&lt;T&gt;</code> for pyclass(#419)</li>
<li>Allow to use lifetime specifiers in <code>pymethods</code></li>
<li>Add <code>marshal</code> module. <a href="https://github.com/PyO3/pyo3/pull/460">#460</a></li>
</ul>
<h3 id="changed-18"><a class="header" href="#changed-18">Changed</a></h3>
<ul>
<li><code>Python::run</code> returns <code>PyResult&lt;()&gt;</code> instead of <code>PyResult&lt;&amp;PyAny&gt;</code>.</li>
<li>Methods decorated with <code>#[getter]</code> and <code>#[setter]</code> can now omit wrapping the
result type in <code>PyResult</code> if they don't raise exceptions.</li>
</ul>
<h3 id="fixed-31"><a class="header" href="#fixed-31">Fixed</a></h3>
<ul>
<li><code>type_object::PyTypeObject</code> has been marked unsafe because breaking the contract <code>type_object::PyTypeObject::init_type</code> can lead to UB.</li>
<li>Fixed automatic derive of <code>PySequenceProtocol</code> implementation in <a href="https://github.com/PyO3/pyo3/pull/423">#423</a>.</li>
<li>Capitalization &amp; better wording to README.md.</li>
<li>Docstrings of properties is now properly set using the doc of the <code>#[getter]</code> method.</li>
<li>Fixed issues with <code>pymethods</code> crashing on doc comments containing double quotes.</li>
<li><code>PySet::new</code> and <code>PyFrozenSet::new</code> now return <code>PyResult&lt;&amp;Py[Frozen]Set&gt;</code>; exceptions are raised if
the items are not hashable.</li>
<li>Fixed building using <code>venv</code> on Windows.</li>
<li><code>PyTuple::new</code> now returns <code>&amp;PyTuple</code> instead of <code>Py&lt;PyTuple&gt;</code>.</li>
<li>Fixed several issues with argument parsing; notable, the <code>*args</code> and <code>**kwargs</code>
tuple/dict now doesn't contain arguments that are otherwise assigned to parameters.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev053v060060a---2019-03-28"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev053v060060a---2019-03-28"><a href="https://github.com/pyo3/pyo3/compare/v0.5.3...v0.6.0">0.6.0</a> - 2019-03-28</a></h2>
<h3 id="regressions"><a class="header" href="#regressions">Regressions</a></h3>
<ul>
<li>Currently, <a href="https://github.com/PyO3/pyo3/issues/341">#341</a> causes <code>cargo test</code> to fail with weird linking errors when the <code>extension-module</code> feature is activated. For now you can work around this by making the <code>extension-module</code> feature optional and running the tests with <code>cargo test --no-default-features</code>:</li>
</ul>
<pre><code class="language-toml">[dependencies.pyo3]
version = &quot;0.6.0&quot;

[features]
extension-module = [&quot;pyo3/extension-module&quot;]
default = [&quot;extension-module&quot;]
</code></pre>
<h3 id="added-28"><a class="header" href="#added-28">Added</a></h3>
<ul>
<li>Added a <code>wrap_pymodule!</code> macro similar to the existing <code>wrap_pyfunction!</code> macro. Only available on python 3</li>
<li>Added support for cross compiling (e.g. to arm v7) by mtp401 in <a href="https://github.com/PyO3/pyo3/pull/327">#327</a>. See the &quot;Cross Compiling&quot; section in the &quot;Building and Distribution&quot; chapter of the guide for more details.</li>
<li>The <code>PyRef</code> and <code>PyRefMut</code> types, which allow to differentiate between an instance of a rust struct on the rust heap and an instance that is embedded inside a python object. By kngwyu in <a href="https://github.com/PyO3/pyo3/pull/335">#335</a></li>
<li>Added <code>FromPy&lt;T&gt;</code> and <code>IntoPy&lt;T&gt;</code> which are equivalent to <code>From&lt;T&gt;</code> and <code>Into&lt;T&gt;</code> except that they require a gil token.</li>
<li>Added <code>ManagedPyRef</code>, which should eventually replace <code>ToBorrowedObject</code>.</li>
</ul>
<h3 id="changed-19"><a class="header" href="#changed-19">Changed</a></h3>
<ul>
<li>Renamed <code>PyObjectRef</code> to <code>PyAny</code> in #388</li>
<li>Renamed <code>add_function</code> to <code>add_wrapped</code> as it now also supports modules.</li>
<li>Renamed <code>#[pymodinit]</code> to <code>#[pymodule]</code></li>
<li><code>py.init(|| value)</code> becomes <code>Py::new(value)</code></li>
<li><code>py.init_ref(|| value)</code> becomes <code>PyRef::new(value)</code></li>
<li><code>py.init_mut(|| value)</code> becomes <code>PyRefMut::new(value)</code>.</li>
<li><code>PyRawObject::init</code> is now infallible, e.g. it returns <code>()</code> instead of <code>PyResult&lt;()&gt;</code>.</li>
<li>Renamed <code>py_exception!</code> to <code>create_exception!</code> and refactored the error macros.</li>
<li>Renamed <code>wrap_function!</code> to <code>wrap_pyfunction!</code></li>
<li>Renamed <code>#[prop(get, set)]</code> to <code>#[pyo3(get, set)]</code></li>
<li><code>#[pyfunction]</code> now supports the same arguments as <code>#[pyfn()]</code></li>
<li>Some macros now emit proper spanned errors instead of panics.</li>
<li>Migrated to the 2018 edition</li>
<li><code>crate::types::exceptions</code> moved to <code>crate::exceptions</code></li>
<li>Replace <code>IntoPyTuple</code> with <code>IntoPy&lt;Py&lt;PyTuple&gt;&gt;</code>.</li>
<li><code>IntoPyPointer</code> and <code>ToPyPointer</code> moved into the crate root.</li>
<li><code>class::CompareOp</code> moved into <code>class::basic::CompareOp</code></li>
<li>PyTypeObject is now a direct subtrait PyTypeCreate, removing the old cyclical implementation in <a href="https://github.com/PyO3/pyo3/pull/350">#350</a></li>
<li>Add <code>PyList::{sort, reverse}</code> by chr1sj0nes in <a href="https://github.com/PyO3/pyo3/pull/357">#357</a> and <a href="https://github.com/PyO3/pyo3/pull/358">#358</a></li>
<li>Renamed the <code>typeob</code> module to <code>type_object</code></li>
</ul>
<h3 id="removed-10"><a class="header" href="#removed-10">Removed</a></h3>
<ul>
<li><code>PyToken</code> was removed due to unsoundness (See <a href="https://github.com/PyO3/pyo3/issues/94">#94</a>).</li>
<li>Removed the unnecessary type parameter from <code>PyObjectAlloc</code></li>
<li><code>NoArgs</code>. Just use an empty tuple</li>
<li><code>PyObjectWithGIL</code>. <code>PyNativeType</code> is sufficient now that PyToken is removed.</li>
</ul>
<h3 id="fixed-32"><a class="header" href="#fixed-32">Fixed</a></h3>
<ul>
<li>A soudness hole where every instances of a <code>#[pyclass]</code> struct was considered to be part of a python object, even though you can create instances that are not part of the python heap. This was fixed through <code>PyRef</code> and <code>PyRefMut</code>.</li>
<li>Fix kwargs support in <a href="https://github.com/PyO3/pyo3/pull/328">#328</a>.</li>
<li>Add full support for <code>__dict__</code> in <a href="https://github.com/PyO3/pyo3/pull/403">#403</a>.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev052v053053a---2019-01-04"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev052v053053a---2019-01-04"><a href="https://github.com/pyo3/pyo3/compare/v0.5.2...v0.5.3">0.5.3</a> - 2019-01-04</a></h2>
<h3 id="fixed-33"><a class="header" href="#fixed-33">Fixed</a></h3>
<ul>
<li>Fix memory leak in ArrayList by kngwyu <a href="https://github.com/PyO3/pyo3/pull/316">#316</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev050v052052a---2018-11-25"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev050v052052a---2018-11-25"><a href="https://github.com/pyo3/pyo3/compare/v0.5.0...v0.5.2">0.5.2</a> - 2018-11-25</a></h2>
<h3 id="fixed-34"><a class="header" href="#fixed-34">Fixed</a></h3>
<ul>
<li>Fix undeterministic segfaults when creating many objects by kngwyu in <a href="https://github.com/PyO3/pyo3/pull/281">#281</a></li>
</ul>
<h2 id="051---2018-11-24"><a class="header" href="#051---2018-11-24">[0.5.1] - 2018-11-24</a></h2>
<p>Yanked</p>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev041v050050a---2018-11-11"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev041v050050a---2018-11-11"><a href="https://github.com/pyo3/pyo3/compare/v0.4.1...v0.5.0">0.5.0</a> - 2018-11-11</a></h2>
<h3 id="added-29"><a class="header" href="#added-29">Added</a></h3>
<ul>
<li><code>#[pyclass]</code> objects can now be returned from rust functions</li>
<li><code>PyComplex</code> by kngwyu in <a href="https://github.com/PyO3/pyo3/pull/226">#226</a></li>
<li><code>PyDict::from_sequence</code>, equivalent to <code>dict([(key, val), ...])</code></li>
<li>Bindings for the <code>datetime</code> standard library types: <code>PyDate</code>, <code>PyTime</code>, <code>PyDateTime</code>, <code>PyTzInfo</code>, <code>PyDelta</code> with associated <code>ffi</code> types, by pganssle <a href="https://github.com/PyO3/pyo3/pull/200">#200</a>.</li>
<li><code>PyString</code>, <code>PyUnicode</code>, and <code>PyBytes</code> now have an <code>as_bytes</code> method that returns <code>&amp;[u8]</code>.</li>
<li><code>PyObjectProtocol::get_type_ptr</code> by ijl in <a href="https://github.com/PyO3/pyo3/pull/242">#242</a></li>
</ul>
<h3 id="changed-20"><a class="header" href="#changed-20">Changed</a></h3>
<ul>
<li>Removes the types from the root module and the prelude. They now live in <code>pyo3::types</code> instead.</li>
<li>All exceptions are constructed with <code>py_err</code> instead of <code>new</code>, as they return <code>PyErr</code> and not <code>Self</code>.</li>
<li><code>as_mut</code> and friends take and <code>&amp;mut self</code> instead of <code>&amp;self</code></li>
<li><code>ObjectProtocol::call</code> now takes an <code>Option&lt;&amp;PyDict&gt;</code> for the kwargs instead of an <code>IntoPyDictPointer</code>.</li>
<li><code>IntoPyDictPointer</code> was replace by <code>IntoPyDict</code> which doesn't convert <code>PyDict</code> itself anymore and returns a <code>PyDict</code> instead of <code>*mut PyObject</code>.</li>
<li><code>PyTuple::new</code> now takes an <code>IntoIterator</code> instead of a slice</li>
<li>Updated to syn 0.15</li>
<li>Splitted <code>PyTypeObject</code> into <code>PyTypeObject</code> without the create method and <code>PyTypeCreate</code> with requires <code>PyObjectAlloc&lt;Self&gt; + PyTypeInfo + Sized</code>.</li>
<li>Ran <code>cargo edition --fix</code> which prefixed path with <code>crate::</code> for rust 2018</li>
<li>Renamed <code>async</code> to <code>pyasync</code> as async will be a keyword in the 2018 edition.</li>
<li>Starting to use <code>NonNull&lt;*mut PyObject&gt;</code> for Py and PyObject by ijl <a href="https://github.com/PyO3/pyo3/pull/260">#260</a></li>
</ul>
<h3 id="removed-11"><a class="header" href="#removed-11">Removed</a></h3>
<ul>
<li>Removed most entries from the prelude. The new prelude is small and clear.</li>
<li>Slowly removing specialization uses</li>
<li><code>PyString</code>, <code>PyUnicode</code>, and <code>PyBytes</code> no longer have a <code>data</code> method
(replaced by <code>as_bytes</code>) and <code>PyStringData</code> has been removed.</li>
<li>The pyobject_extract macro</li>
</ul>
<h3 id="fixed-35"><a class="header" href="#fixed-35">Fixed</a></h3>
<ul>
<li>Added an explanation that the GIL can temporarily be released even while holding a GILGuard.</li>
<li>Lots of clippy errors</li>
<li>Fix segfault on calling an unknown method on a PyObject</li>
<li>Work around a <a href="https://github.com/rust-lang/rust/issues/55380">bug</a> in the rust compiler by kngwyu <a href="https://github.com/PyO3/pyo3/pull/252">#252</a></li>
<li>Fixed a segfault with subclassing pyo3 create classes and using <code>__class__</code> by kngwyu <a href="https://github.com/PyO3/pyo3/pull/263">#263</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev040v041041a---2018-08-20"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev040v041041a---2018-08-20"><a href="https://github.com/pyo3/pyo3/compare/v0.4.0...v0.4.1">0.4.1</a> - 2018-08-20</a></h2>
<h3 id="changed-21"><a class="header" href="#changed-21">Changed</a></h3>
<ul>
<li>PyTryFrom's error is always to <code>PyDowncastError</code></li>
</ul>
<h3 id="fixed-36"><a class="header" href="#fixed-36">Fixed</a></h3>
<ul>
<li>Fixed compilation on nightly since <code>use_extern_macros</code> was stabilized</li>
</ul>
<h3 id="removed-12"><a class="header" href="#removed-12">Removed</a></h3>
<ul>
<li>The pyobject_downcast macro</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev032v040040a---2018-07-30"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev032v040040a---2018-07-30"><a href="https://github.com/pyo3/pyo3/compare/v0.3.2...v0.4.0">0.4.0</a> - 2018-07-30</a></h2>
<h3 id="changed-22"><a class="header" href="#changed-22">Changed</a></h3>
<ul>
<li>Merged both examples into one</li>
<li>Rustfmt all the things :heavy_check_mark:</li>
<li>Switched to <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a></li>
</ul>
<h3 id="removed-13"><a class="header" href="#removed-13">Removed</a></h3>
<ul>
<li>Conversions from tuples to PyDict due to <a href="https://github.com/rust-lang/rust/issues/52050">rust-lang/rust#52050</a></li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev031v032032a---2018-07-22"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev031v032032a---2018-07-22"><a href="https://github.com/pyo3/pyo3/compare/v0.3.1...v0.3.2">0.3.2</a> - 2018-07-22</a></h2>
<h3 id="changed-23"><a class="header" href="#changed-23">Changed</a></h3>
<ul>
<li>Replaced <code>concat_idents</code> with mashup</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev030v031031a---2018-07-18"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev030v031031a---2018-07-18"><a href="https://github.com/pyo3/pyo3/compare/v0.3.0...v0.3.1">0.3.1</a> - 2018-07-18</a></h2>
<h3 id="fixed-37"><a class="header" href="#fixed-37">Fixed</a></h3>
<ul>
<li>Fixed scoping bug in pyobject_native_type that would break rust-numpy</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev027v030030a---2018-07-18"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev027v030030a---2018-07-18"><a href="https://github.com/pyo3/pyo3/compare/v0.2.7...v0.3.0">0.3.0</a> - 2018-07-18</a></h2>
<h3 id="added-30"><a class="header" href="#added-30">Added</a></h3>
<ul>
<li>A few internal macros became part of the public api (<a href="https://github.com/PyO3/pyo3/pull/155">#155</a>, <a href="https://github.com/PyO3/pyo3/pull/186">#186</a>)</li>
<li>Always clone in getters. This allows using the get-annotation on all Clone-Types</li>
</ul>
<h3 id="changed-24"><a class="header" href="#changed-24">Changed</a></h3>
<ul>
<li>Upgraded to syn 0.14 which means much better error messages :tada:</li>
<li>128 bit integer support by <a href="https://github.com/kngwyu">kngwyu</a> (<a href="https://github.com/PyO3/pyo3/pull/173">#137</a>)</li>
<li><code>proc_macro</code> has been stabilized on nightly (<a href="https://github.com/rust-lang/rust/pull/52081">rust-lang/rust#52081</a>). This means that we can remove the <code>proc_macro</code> feature, but now we need the <code>use_extern_macros</code> from the 2018 edition instead.</li>
<li>All proc macro are now prefixed with <code>py</code> and live in the prelude. This means you can use <code>#[pyclass]</code>, <code>#[pymethods]</code>, <code>#[pyproto]</code>, <code>#[pyfunction]</code> and <code>#[pymodinit]</code> directly, at least after a <code>use pyo3::prelude::*</code>. They were also moved into a module called <code>proc_macro</code>. You shouldn't use <code>#[pyo3::proc_macro::pyclass]</code> or other longer paths in attributes because <code>proc_macro_path_invoc</code> isn't going to be stabilized soon.</li>
<li>Renamed the <code>base</code> option in the <code>pyclass</code> macro to <code>extends</code>.</li>
<li><code>#[pymodinit]</code> uses the function name as module name, unless the name is overrriden with <code>#[pymodinit(name)]</code></li>
<li>The guide is now properly versioned.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev026v027027a---2018-05-18"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev026v027027a---2018-05-18"><a href="https://github.com/pyo3/pyo3/compare/v0.2.6...v0.2.7">0.2.7</a> - 2018-05-18</a></h2>
<h3 id="fixed-38"><a class="header" href="#fixed-38">Fixed</a></h3>
<ul>
<li>Fix nightly breakage with proc_macro_path</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev025v026026a---2018-04-03"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev025v026026a---2018-04-03"><a href="https://github.com/pyo3/pyo3/compare/v0.2.5...v0.2.6">0.2.6</a> - 2018-04-03</a></h2>
<h3 id="fixed-39"><a class="header" href="#fixed-39">Fixed</a></h3>
<ul>
<li>Fix compatibility with TryFrom trait #137</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev024v025025a---2018-02-21"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev024v025025a---2018-02-21"><a href="https://github.com/pyo3/pyo3/compare/v0.2.4...v0.2.5">0.2.5</a> - 2018-02-21</a></h2>
<h3 id="added-31"><a class="header" href="#added-31">Added</a></h3>
<ul>
<li>CPython 3.7 support</li>
</ul>
<h3 id="fixed-40"><a class="header" href="#fixed-40">Fixed</a></h3>
<ul>
<li>Embedded CPython 3.7b1 crashes on initialization #110</li>
<li>Generated extension functions are weakly typed #108</li>
<li>call_method* crashes when the method does not exist #113</li>
<li>Allow importing exceptions from nested modules #116</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev023v024024a---2018-01-19"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev023v024024a---2018-01-19"><a href="https://github.com/pyo3/pyo3/compare/v0.2.3...v0.2.4">0.2.4</a> - 2018-01-19</a></h2>
<h3 id="added-32"><a class="header" href="#added-32">Added</a></h3>
<ul>
<li>Allow to get mutable ref from PyObject #106</li>
<li>Drop <code>RefFromPyObject</code> trait</li>
<li>Add Python::register_any method</li>
</ul>
<h3 id="fixed-41"><a class="header" href="#fixed-41">Fixed</a></h3>
<ul>
<li>Fix impl <code>FromPyObject</code> for <code>Py&lt;T&gt;</code></li>
<li>Mark method that work with raw pointers as unsafe #95</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev022v023023a---11-27-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev022v023023a---11-27-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.2...v0.2.3">0.2.3</a> - 11-27-2017</a></h2>
<h3 id="changed-25"><a class="header" href="#changed-25">Changed</a></h3>
<ul>
<li>Rustup to 1.23.0-nightly 2017-11-07</li>
</ul>
<h3 id="fixed-42"><a class="header" href="#fixed-42">Fixed</a></h3>
<ul>
<li>Proper <code>c_char</code> usage #93</li>
</ul>
<h3 id="removed-14"><a class="header" href="#removed-14">Removed</a></h3>
<ul>
<li>Remove use of now unneeded 'AsciiExt' trait</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev021v022022a---09-26-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev021v022022a---09-26-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.1...v0.2.2">0.2.2</a> - 09-26-2017</a></h2>
<h3 id="changed-26"><a class="header" href="#changed-26">Changed</a></h3>
<ul>
<li>Rustup to 1.22.0-nightly 2017-09-30</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev020v021021a---09-26-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev020v021021a---09-26-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.0...v0.2.1">0.2.1</a> - 09-26-2017</a></h2>
<h3 id="fixed-43"><a class="header" href="#fixed-43">Fixed</a></h3>
<ul>
<li>Fix rustc const_fn nightly breakage</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3comparev010v020020a---08-12-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3comparev010v020020a---08-12-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.1.0...v0.2.0">0.2.0</a> - 08-12-2017</a></h2>
<h3 id="added-33"><a class="header" href="#added-33">Added</a></h3>
<ul>
<li>Added inheritance support #15</li>
<li>Added weakref support #56</li>
<li>Added subclass support #64</li>
<li>Added <code>self.__dict__</code> supoort #68</li>
<li>Added <code>pyo3::prelude</code> module #70</li>
<li>Better <code>Iterator</code> support for PyTuple, PyList, PyDict #75</li>
<li>Introduce IntoPyDictPointer similar to IntoPyTuple #69</li>
</ul>
<h3 id="changed-27"><a class="header" href="#changed-27">Changed</a></h3>
<ul>
<li>Allow to add gc support without implementing PyGCProtocol #57</li>
<li>Refactor <code>PyErr</code> implementation. Drop <code>py</code> parameter from constructor.</li>
</ul>
<h2 id="a-hrefhttpsgithubcompyo3pyo3tree010010a---07-23-2017"><a class="header" href="#a-hrefhttpsgithubcompyo3pyo3tree010010a---07-23-2017"><a href="https://github.com/PyO3/pyo3/tree/0.1.0">0.1.0</a> - 07-23-2017</a></h2>
<h3 id="added-34"><a class="header" href="#added-34">Added</a></h3>
<ul>
<li>Initial release</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h1>
<p>Thank you for your interest in contributing to PyO3! All are welcome - please consider reading our <a href="https://github.com/PyO3/pyo3/blob/main/Code-of-Conduct.md">Code of Conduct</a> to keep our community positive and inclusive.</p>
<p>If you are searching for ideas how to contribute, proceed to the <a href="contributing.html#getting-started-contributing">&quot;Getting started contributing&quot;</a> section. If you have found a specific issue to contribute to and need information about the development process, you may find the section <a href="contributing.html#writing-pull-requests">&quot;Writing pull requests&quot;</a> helpful.</p>
<p>If you want to become familiar with the codebase, see
<a href="https://github.com/PyO3/pyo3/blob/main/Architecture.md">Architecture.md</a>.</p>
<h2 id="getting-started-contributing"><a class="header" href="#getting-started-contributing">Getting started contributing</a></h2>
<p>Please join in with any part of PyO3 which interests you. We use GitHub issues to record all bugs and ideas. Feel free to request an issue to be assigned to you if you want to work on it.</p>
<p>You can browse the API of the non-public parts of PyO3 <a href="https://pyo3.rs/internal/doc/pyo3/index.html">here</a>.</p>
<p>The following sections also contain specific ideas on where to start contributing to PyO3.</p>
<h2 id="setting-up-a-development-environment"><a class="header" href="#setting-up-a-development-environment">Setting up a development environment</a></h2>
<p>To work and develop PyO3, you need Python &amp; Rust installed on your system.</p>
<ul>
<li>We encourage the use of <a href="https://rustup.rs/">rustup</a> to be able to select and choose specific toolchains based on the project.</li>
<li><a href="https://github.com/pyenv/pyenv">Pyenv</a> is also highly recommended for being able to choose a specific Python version.</li>
<li><a href="https://virtualenv.pypa.io/en/latest/">virtualenv</a> can also be used with or without Pyenv to use specific installed Python versions.</li>
<li><a href="https://github.com/theacodes/nox"><code>nox</code></a> is used to automate many of our CI tasks.</li>
</ul>
<h3 id="caveats"><a class="header" href="#caveats">Caveats</a></h3>
<ul>
<li>When using pyenv on macOS, installing a Python version using <code>--enable-shared</code> is required to make it work. i.e <code>env PYTHON_CONFIGURE_OPTS=&quot;--enable-shared&quot; pyenv install 3.7.12</code></li>
</ul>
<h3 id="help-users-identify-bugs"><a class="header" href="#help-users-identify-bugs">Help users identify bugs</a></h3>
<p>The <a href="https://gitter.im/PyO3/Lobby">PyO3 Gitter channel</a> is very active with users who are new to PyO3, and often completely new to Rust. Helping them debug is a great way to get experience with the PyO3 codebase.</p>
<p>Helping others often reveals bugs, documentation weaknesses, and missing APIs. It's a good idea to open GitHub issues for these immediately so the resolution can be designed and implemented!</p>
<h3 id="implement-issues-ready-for-development"><a class="header" href="#implement-issues-ready-for-development">Implement issues ready for development</a></h3>
<p>Issues where the solution is clear and work is not in progress use the <a href="https://github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Aneeds-implemeter">needs-implementer</a> label.</p>
<p>Don't be afraid if the solution is not clear to you! The core PyO3 contributors will be happy to mentor you through any questions you have to help you write the solution.</p>
<h3 id="help-write-great-docs"><a class="header" href="#help-write-great-docs">Help write great docs</a></h3>
<p>PyO3 has a user guide (using mdbook) as well as the usual Rust API docs. The aim is for both of these to be detailed, easy to understand, and up-to-date. Pull requests are always welcome to fix typos, change wording, add examples, etc.</p>
<p>There are some specific areas of focus where help is currently needed for the documentation:</p>
<ul>
<li>Issues requesting documentation improvements are tracked with the <a href="https://github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Adocumentation">documentation</a> label.</li>
<li>Not all APIs had docs or examples when they were made. The goal is to have documentation on all PyO3 APIs (<a href="https://github.com/PyO3/pyo3/issues/306">#306</a>). If you see an API lacking a doc, please write one and open a PR!</li>
</ul>
<p>You can build the docs (including all features) with</p>
<pre><code class="language-shell">cargo xtask doc --open
</code></pre>
<h4 id="doctests"><a class="header" href="#doctests">Doctests</a></h4>
<p>We use lots of code blocks in our docs. Run <code>cargo test --doc</code> when making changes to check that
the doctests still work, or <code>cargo test</code> to run all the tests including doctests. See
https://doc.rust-lang.org/rustdoc/documentation-tests.html for a guide on doctests.</p>
<h4 id="building-the-guide"><a class="header" href="#building-the-guide">Building the guide</a></h4>
<p>You can preview the user guide by building it locally with <code>mdbook</code>.</p>
<p>First, install <a href="https://rust-lang.github.io/mdBook/cli/index.html"><code>mdbook</code></a> and <a href="https://github.com/theacodes/nox"><code>nox</code></a>. Then, run</p>
<pre><code class="language-shell">nox -s build-guide -- --open
</code></pre>
<h3 id="help-design-the-next-pyo3"><a class="header" href="#help-design-the-next-pyo3">Help design the next PyO3</a></h3>
<p>Issues which don't yet have a clear solution use the <a href="https://github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Aneeds-design">needs-design</a> label.</p>
<p>If any of these issues interest you, please join in with the conversation on the issue! All opinions are valued, and if you're interested in going further with e.g. draft PRs to experiment with API designs, even better!</p>
<h3 id="review-pull-requests"><a class="header" href="#review-pull-requests">Review pull requests</a></h3>
<p>Everybody is welcome to submit comments on open PRs. Please help ensure new PyO3 APIs are safe, performant, tidy, and easy to use!</p>
<h2 id="writing-pull-requests"><a class="header" href="#writing-pull-requests">Writing pull requests</a></h2>
<p>Here are a few things to note when you are writing PRs.</p>
<h3 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h3>
<p>The PyO3 repo uses GitHub Actions. PRs are blocked from merging if CI is not successful.</p>
<p>Formatting, linting and tests are checked for all Rust and Python code. In addition, all warnings in Rust code are disallowed (using <code>RUSTFLAGS=&quot;-D warnings&quot;</code>).</p>
<p>Tests run with all supported Python versions with the latest stable Rust compiler, as well as for Python 3.9 with the minimum supported Rust version.</p>
<p>If you are adding a new feature, you should add it to the <code>full</code> feature in our <em>Cargo.toml</em>* so that it is tested in CI.</p>
<p>You can run these tests yourself with
<code>cargo xtask ci</code>
See <a href="https://github.com/PyO3/pyo3/tree/main/xtask#readme">it's documentation</a>for more commands you can run.</p>
<h2 id="python-and-rust-version-support-policy"><a class="header" href="#python-and-rust-version-support-policy">Python and Rust version support policy</a></h2>
<p>PyO3 aims to keep sufficient compatibility to make packaging Python extensions built with PyO3 feasible on most common package managers.</p>
<p>To keep package maintainers' lives simpler, PyO3 will commit, wherever possible, to only adjust minimum supported Rust and Python versions at the same time. This bump will only come in an <code>0.x</code> release, roughly once per year, after the oldest supported Python version reaches its end-of-life. (Check https://endoflife.date/python for a clear timetable on these.)</p>
<p>Below are guidelines on what compatibility all PRs are expected to deliver for each language.</p>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>PyO3 supports all officially supported Python versions, as well as the latest PyPy3 release. All of these versions are tested in CI.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>PyO3 aims to make use of up-to-date Rust language features to keep the implementation as efficient as possible.</p>
<p>The minimum Rust version supported will be decided when the release which bumps Python and Rust versions is made. At the time, the minimum Rust version will be set no higher than the lowest Rust version shipped in the current Debian, RHEL and Alpine Linux distributions.</p>
<p>CI tests both the most recent stable Rust version and the minimum supported Rust version. Because of Rust's stability guarantees this is sufficient to confirm support for all Rust versions in between.</p>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<p>PyO3 has two sets of benchmarks for evaluating some aspects of its performance. The benchmark suite is currently very small - please open PRs with new benchmarks if you're interested in helping to expand it!</p>
<p>First, there are Rust-based benchmarks located in the <code>benches</code> subdirectory. As long as you have a nightly rust compiler available on your system, you can run these benchmarks with:</p>
<pre><code>cargo +nightly bench
</code></pre>
<p>Second, there is a Python-based benchmark contained in the <code>pytests</code> subdirectory. You can read more about it <a href="pytests">here</a>.</p>
<h2 id="sponsor-this-project"><a class="header" href="#sponsor-this-project">Sponsor this project</a></h2>
<p>At the moment there is no official organisation that accepts sponsorship on PyO3's behalf. If you're seeking to provide significant funding to the PyO3 ecosystem, please reach out to us on <a href="https://github.com/PyO3/pyo3/issues/new">GitHub</a> or <a href="https://gitter.im/PyO3/Lobby">Gitter</a> and we can discuss.</p>
<p>In the meanwhile, some of our maintainers have personal GitHub sponsorship pages and would be grateful for your support:</p>
<ul>
<li><a href="https://github.com/sponsors/davidhewitt">davidhewitt</a></li>
<li><a href="https://github.com/sponsors/messense">messense</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
