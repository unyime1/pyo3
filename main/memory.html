<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memory Management - PyO3 user guide</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="module.html"><strong aria-hidden="true">1.</strong> Python Modules</a></li><li class="chapter-item expanded "><a href="function.html"><strong aria-hidden="true">2.</strong> Python Functions</a></li><li class="chapter-item expanded "><a href="class.html"><strong aria-hidden="true">3.</strong> Python Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/protocols.html"><strong aria-hidden="true">3.1.</strong> Class customizations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/object.html"><strong aria-hidden="true">3.1.1.</strong> Basic object customization</a></li><li class="chapter-item expanded "><a href="class/numeric.html"><strong aria-hidden="true">3.1.2.</strong> Emulating numeric types</a></li><li class="chapter-item expanded "><a href="class/call.html"><strong aria-hidden="true">3.1.3.</strong> Emulating callable objects</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> Type Conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversions/tables.html"><strong aria-hidden="true">4.1.</strong> Mapping of Rust types to Python types</a></li><li class="chapter-item expanded "><a href="conversions/traits.html"><strong aria-hidden="true">4.2.</strong> Conversion traits</a></li></ol></li><li class="chapter-item expanded "><a href="exception.html"><strong aria-hidden="true">5.</strong> Python Exceptions</a></li><li class="chapter-item expanded "><a href="python_from_rust.html"><strong aria-hidden="true">6.</strong> Calling Python from Rust</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">7.</strong> GIL, mutability and object types</a></li><li class="chapter-item expanded "><a href="parallelism.html"><strong aria-hidden="true">8.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">9.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">10.</strong> Features Reference</a></li><li class="chapter-item expanded "><a href="memory.html" class="active"><strong aria-hidden="true">11.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">12.</strong> Advanced Topics</a></li><li class="chapter-item expanded "><a href="building_and_distribution.html"><strong aria-hidden="true">13.</strong> Building and Distribution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building_and_distribution/multiple_python_versions.html"><strong aria-hidden="true">13.1.</strong> Supporting multiple Python versions</a></li></ol></li><li class="chapter-item expanded "><a href="ecosystem.html"><strong aria-hidden="true">14.</strong> Useful Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecosystem/logging.html"><strong aria-hidden="true">14.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="ecosystem/async-await.html"><strong aria-hidden="true">14.2.</strong> Async / Await</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">15.</strong> FAQ &amp; Troubleshooting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="migration.html">Appendix A: Migration Guide</a></li><li class="chapter-item expanded affix "><a href="rust_cpython.html">Appendix B: PyO3 and rust-cpython</a></li><li class="chapter-item expanded affix "><a href="trait_bounds.html">Appendix C: Trait bounds</a></li><li class="chapter-item expanded affix "><a href="python_typing_hints.html">Appendix D: Python typing hints</a></li><li class="chapter-item expanded affix "><a href="changelog.html">CHANGELOG</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributing.html">Contributing</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Rust and Python have very different notions of memory management.  Rust has
a strict memory model with concepts of ownership, borrowing, and lifetimes,
where memory is freed at predictable points in program execution.  Python has
a looser memory model in which variables are reference-counted with shared,
mutable state by default. A global interpreter lock (GIL) is needed to prevent
race conditions, and a garbage collector is needed to break reference cycles.
Memory in Python is freed eventually by the garbage collector, but not usually
in a predictable way.</p>
<p>PyO3 bridges the Rust and Python memory models with two different strategies for
accessing memory allocated on Python's heap from inside Rust.  These are
GIL-bound, or &quot;owned&quot; references, and GIL-independent <code>Py&lt;Any&gt;</code> smart pointers.</p>
<h2 id="gil-bound-memory"><a class="header" href="#gil-bound-memory">GIL-bound Memory</a></h2>
<p>PyO3's GIL-bound, &quot;owned references&quot; (<code>&amp;PyAny</code> etc.) make PyO3 more ergonomic to
use by ensuring that their lifetime can never be longer than the duration the
Python GIL is held.  This means that most of PyO3's API can assume the GIL is
held. (If PyO3 could not assume this, every PyO3 API would need to take a
<code>Python</code> GIL token to prove that the GIL is held.)  This allows us to write
very simple and easy-to-understand programs like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    let hello: &amp;PyString = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
    println!(&quot;Python says: {}&quot;, hello);
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>Internally, calling <code>Python::with_gil()</code> or <code>Python::acquire_gil()</code> creates a
<code>GILPool</code> which owns the memory pointed to by the reference.  In the example
above, the lifetime of the reference <code>hello</code> is bound to the <code>GILPool</code>.  When
the <code>with_gil()</code> closure ends or the <code>GILGuard</code> from <code>acquire_gil()</code> is dropped,
the <code>GILPool</code> is also dropped and the Python reference counts of the variables
it owns are decreased, releasing them to the Python garbage collector.  Most
of the time we don't have to think about this, but consider the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    for _ in 0..10 {
        let hello: &amp;PyString = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
        println!(&quot;Python says: {}&quot;, hello);
    }
    // There are 10 copies of `hello` on Python's heap here.
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>We might assume that the <code>hello</code> variable's memory is freed at the end of each
loop iteration, but in fact we create 10 copies of <code>hello</code> on Python's heap.
This may seem surprising at first, but it is completely consistent with Rust's
memory model.  The <code>hello</code> variable is dropped at the end of each loop, but it
is only a reference to the memory owned by the <code>GILPool</code>, and its lifetime is
bound to the <code>GILPool</code>, not the for loop.  The <code>GILPool</code> isn't dropped until
the end of the <code>with_gil()</code> closure, at which point the 10 copies of <code>hello</code>
are finally released to the Python garbage collector.</p>
<p>In general we don't want unbounded memory growth during loops!  One workaround
is to acquire and release the GIL with each iteration of the loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>for _ in 0..10 {
    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
        let hello: &amp;PyString = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
        println!(&quot;Python says: {}&quot;, hello);
        Ok(())
    })?; // only one copy of `hello` at a time
}
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>It might not be practical or performant to acquire and release the GIL so many
times.  Another workaround is to work with the <code>GILPool</code> object directly, but
this is unsafe.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    for _ in 0..10 {
        let pool = unsafe { py.new_pool() };
        let py = pool.python();
        let hello: &amp;PyString = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
        println!(&quot;Python says: {}&quot;, hello);
    }
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>The unsafe method <code>Python::new_pool</code> allows you to create a nested <code>GILPool</code>
from which you can retrieve a new <code>py: Python</code> GIL token.  Variables created
with this new GIL token are bound to the nested <code>GILPool</code> and will be released
when the nested <code>GILPool</code> is dropped.  Here, the nested <code>GILPool</code> is dropped
at the end of each loop iteration, before the <code>with_gil()</code> closure ends.</p>
<p>When doing this, you must be very careful to ensure that once the <code>GILPool</code> is
dropped you do not retain access to any owned references created after the
<code>GILPool</code> was created.  Read the
<a href="https://pyo3.rs/main/doc/pyo3/prelude/struct.Python.html#method.new_pool">documentation for <code>Python::new_pool()</code></a>
for more information on safety.</p>
<h2 id="gil-independent-memory"><a class="header" href="#gil-independent-memory">GIL-independent Memory</a></h2>
<p>Sometimes we need a reference to memory on Python's heap that can outlive the
GIL.  Python's <code>Py&lt;PyAny&gt;</code> is analogous to <code>Rc&lt;T&gt;</code>, but for variables whose
memory is allocated on Python's heap.  Cloning a <code>Py&lt;PyAny&gt;</code> increases its
internal reference count just like cloning <code>Rc&lt;T&gt;</code>.  The smart pointer can
outlive the GIL from which it was created.  It isn't magic, though.  We need to
reacquire the GIL to access the memory pointed to by the <code>Py&lt;PyAny&gt;</code>.</p>
<p>What happens to the memory when the last <code>Py&lt;PyAny&gt;</code> is dropped and its
reference count reaches zero?  It depends whether or not we are holding the GIL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    let hello: Py&lt;PyString&gt; = py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()?;
    println!(&quot;Python says: {}&quot;, hello.as_ref(py));
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>At the end of the <code>Python::with_gil()</code> closure <code>hello</code> is dropped, and then the
GIL is dropped.  Since <code>hello</code> is dropped while the GIL is still held by the
current thread, its memory is released to the Python garbage collector
immediately.</p>
<p>This example wasn't very interesting.  We could have just used a GIL-bound
<code>&amp;PyString</code> reference.  What happens when the last <code>Py&lt;Any&gt;</code> is dropped while
we are <em>not</em> holding the GIL?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>let hello: Py&lt;PyString&gt; = Python::with_gil(|py| {
    py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()
})?;
// Do some stuff...
// Now sometime later in the program we want to access `hello`.
Python::with_gil(|py| {
    println!(&quot;Python says: {}&quot;, hello.as_ref(py));
});
// Now we're done with `hello`.
drop(hello); // Memory *not* released here.
// Sometime later we need the GIL again for something...
Python::with_gil(|py|
    // Memory for `hello` is released here.
<span class="boring">()
</span>);
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>When <code>hello</code> is dropped <em>nothing</em> happens to the pointed-to memory on Python's
heap because nothing <em>can</em> happen if we're not holding the GIL.  Fortunately,
the memory isn't leaked.  PyO3 keeps track of the memory internally and will
release it the next time we acquire the GIL.</p>
<p>We can avoid the delay in releasing memory if we are careful to drop the
<code>Py&lt;Any&gt;</code> while the GIL is held.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>let hello: Py&lt;PyString&gt; = Python::with_gil(|py| {
    py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()
})?;
// Do some stuff...
// Now sometime later in the program:
Python::with_gil(|py| {
    println!(&quot;Python says: {}&quot;, hello.as_ref(py));
    drop(hello); // Memory released here.
});
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>We could also have used <code>Py::into_ref()</code>, which consumes <code>self</code>, instead of
<code>Py::as_ref()</code>.  But note that in addition to being slower than <code>as_ref()</code>,
<code>into_ref()</code> binds the memory to the lifetime of the <code>GILPool</code>, which means
that rather than being released immediately, the memory will not be released
until the GIL is dropped.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>let hello: Py&lt;PyString&gt; = Python::with_gil(|py| {
    py.eval(&quot;\&quot;Hello World!\&quot;&quot;, None, None)?.extract()
})?;
// Do some stuff...
// Now sometime later in the program:
Python::with_gil(|py| {
    println!(&quot;Python says: {}&quot;, hello.into_ref(py));
    // Memory not released yet.
    // Do more stuff...
    // Memory released here at end of `with_gil()` closure.
});
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="advanced.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="advanced.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
